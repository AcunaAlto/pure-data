CHANGELOG.txt:add support for callback-based audio I/O
CHANGELOG.txt:finally figured out how to do "-enable-", etc., flags in the configure
CHANGELOG.txt:64-bit fix to externs makefiles
CHANGELOG.txt:Pd now uses portaudio out-of-the-box; customized files are moved to
CHANGELOG.txt:All "tags" are printf'd as %lx to make 64-bit safe.  
CHANGELOG.txt:add -fno-strict-aliasing to config script (linux&mac) to improve underflow,
CHANGELOG.txt:fixed bug in -inchannels/-outchannels arg parsing
CHANGELOG.txt:finally fixed OSS to open audio with NODELAY... also cleared dup-on-exec flag.
CHANGELOG.txt:removed "-Werror" from default makefile; fixed  configure script to respect
CHANGELOG.txt:"setenv CFLAGS -Werror".
CHANGELOG.txt:added "-alsaadd" flag so people can specify alsa devnames to add to list.
CHANGELOG.txt:took out the 2-pixel padding for MSW in g_canvas.g (HORIZBORDER/VERTBORDER)
CHANGELOG.txt:fixed "-alsaadd" (never worked before)
CHANGELOG.txt:------------------- original source notes -------------
CHANGELOG.txt:------------ BFFORE 0.35: ---------
CHANGELOG.txt:------------ AFTER 0.35: ---------
CHANGELOG.txt:g_canvas.h  t_selection -- linked list of gobjs
CHANGELOG.txt:    	    t_editor -- editor state, allocated for visible glists
CHANGELOG.txt:m_imp.h     t_methodentry -- method handler
CHANGELOG.txt:    	    t_widgetbehavior -- class-dependent editing behavior for gobjs
CHANGELOG.txt:    	    t_parentwidgetbehavior -- objects' behavior on parent window
CHANGELOG.txt:    	    t_class -- method definitions, instance size, flags, etc.
CHANGELOG.txt:(-Wall on linux, for instance; see the makefile.)  Some informalities
CHANGELOG.txt:have a K&R-style prefix, as in ((t_atom)x)->a_type, where the "a_" prefix
CHANGELOG.txt:2.  Max patch-level compatibility.  "Import" and "Export" functions are
CHANGELOG.txt:3.  Compatibility with Max 0.26 "externs", i.e., source-level compatibility. Pd
CHANGELOG.txt:3.2.  Pd passes true single-precision floating-point arguments to methods;
CHANGELOG.txt:3.3.  Badly-named entities got name changes:
CHANGELOG.txt:    w_long --> w_int (in the "union word" structure)
CHANGELOG.txt:(pd-gui:)   pdgui -- everything
CHANGELOG.txt:(pd:)	    pd -- functions common to all "pd" objects
CHANGELOG.txt:    	    obj -- fuctions common to all "patchable" objects ala Max
CHANGELOG.txt:    	    sys -- "system" level functions
CHANGELOG.txt:    	    binbuf -- functions manipulating binbufs
CHANGELOG.txt:    	    class -- functions manipulating classes
CHANGELOG.txt:    	    (other) -- functions common to the named Pd class
CHANGELOG.txt:PD-GUI:
d_arithmetic.c:/* Copyright (c) 1997-1999 Miller Puckette.
d_arithmetic.c:/*  arithmetic binops (+, -, *, /).
d_arithmetic.c:/* ----------------------------- plus ----------------------------- */
d_arithmetic.c:        floatinlet_new(&x->x_obj, &x->x_g);
d_arithmetic.c:        x->x_g = atom_getfloatarg(0, argc, argv);
d_arithmetic.c:        outlet_new(&x->x_obj, &s_signal);
d_arithmetic.c:        x->x_f = 0;
d_arithmetic.c:        inlet_new(&x->x_obj, &x->x_obj.ob_pd, &s_signal, &s_signal);
d_arithmetic.c:        outlet_new(&x->x_obj, &s_signal);
d_arithmetic.c:        x->x_f = 0;
d_arithmetic.c:    while (n--) *out++ = *in1++ + *in2++; 
d_arithmetic.c:    for (; n; n -= 8, in1 += 8, in2 += 8, out += 8)
d_arithmetic.c:    while (n--) *out++ = *in++ + f; 
d_arithmetic.c:    for (; n; n -= 8, in += 8, out += 8)
d_arithmetic.c:    dsp_add_plus(sp[0]->s_vec, sp[1]->s_vec, sp[2]->s_vec, sp[0]->s_n);
d_arithmetic.c:    if (sp[0]->s_n&7)
d_arithmetic.c:        dsp_add(scalarplus_perform, 4, sp[0]->s_vec, &x->x_g,
d_arithmetic.c:            sp[1]->s_vec, sp[0]->s_n);
d_arithmetic.c:        dsp_add(scalarplus_perf8, 4, sp[0]->s_vec, &x->x_g,
d_arithmetic.c:            sp[1]->s_vec, sp[0]->s_n);
d_arithmetic.c:/* ----------------------------- minus ----------------------------- */
d_arithmetic.c:    if (argc > 1) post("-~: extra arguments ignored");
d_arithmetic.c:        floatinlet_new(&x->x_obj, &x->x_g);
d_arithmetic.c:        x->x_g = atom_getfloatarg(0, argc, argv);
d_arithmetic.c:        outlet_new(&x->x_obj, &s_signal);
d_arithmetic.c:        x->x_f = 0;
d_arithmetic.c:        inlet_new(&x->x_obj, &x->x_obj.ob_pd, &s_signal, &s_signal);
d_arithmetic.c:        outlet_new(&x->x_obj, &s_signal);
d_arithmetic.c:        x->x_f = 0;
d_arithmetic.c:    while (n--) *out++ = *in1++ - *in2++; 
d_arithmetic.c:    for (; n; n -= 8, in1 += 8, in2 += 8, out += 8)
d_arithmetic.c:        out[0] = f0 - g0; out[1] = f1 - g1; out[2] = f2 - g2; out[3] = f3 - g3;
d_arithmetic.c:        out[4] = f4 - g4; out[5] = f5 - g5; out[6] = f6 - g6; out[7] = f7 - g7;
d_arithmetic.c:    while (n--) *out++ = *in++ - f; 
d_arithmetic.c:    for (; n; n -= 8, in += 8, out += 8)
d_arithmetic.c:        out[0] = f0 - g; out[1] = f1 - g; out[2] = f2 - g; out[3] = f3 - g;
d_arithmetic.c:        out[4] = f4 - g; out[5] = f5 - g; out[6] = f6 - g; out[7] = f7 - g;
d_arithmetic.c:    if (sp[0]->s_n&7)
d_arithmetic.c:            sp[0]->s_vec, sp[1]->s_vec, sp[2]->s_vec, sp[0]->s_n);
d_arithmetic.c:            sp[0]->s_vec, sp[1]->s_vec, sp[2]->s_vec, sp[0]->s_n);
d_arithmetic.c:    if (sp[0]->s_n&7)
d_arithmetic.c:        dsp_add(scalarminus_perform, 4, sp[0]->s_vec, &x->x_g,
d_arithmetic.c:            sp[1]->s_vec, sp[0]->s_n);
d_arithmetic.c:        dsp_add(scalarminus_perf8, 4, sp[0]->s_vec, &x->x_g,
d_arithmetic.c:            sp[1]->s_vec, sp[0]->s_n);
d_arithmetic.c:    minus_class = class_new(gensym("-~"), (t_newmethod)minus_new, 0,
d_arithmetic.c:    scalarminus_class = class_new(gensym("-~"), 0, 0,
d_arithmetic.c:/* ----------------------------- times ----------------------------- */
d_arithmetic.c:        floatinlet_new(&x->x_obj, &x->x_g);
d_arithmetic.c:        x->x_g = atom_getfloatarg(0, argc, argv);
d_arithmetic.c:        outlet_new(&x->x_obj, &s_signal);
d_arithmetic.c:        x->x_f = 0;
d_arithmetic.c:        inlet_new(&x->x_obj, &x->x_obj.ob_pd, &s_signal, &s_signal);
d_arithmetic.c:        outlet_new(&x->x_obj, &s_signal);
d_arithmetic.c:        x->x_f = 0;
d_arithmetic.c:    while (n--) *out++ = *in1++ * *in2++; 
d_arithmetic.c:    for (; n; n -= 8, in1 += 8, in2 += 8, out += 8)
d_arithmetic.c:    while (n--) *out++ = *in++ * f; 
d_arithmetic.c:    for (; n; n -= 8, in += 8, out += 8)
d_arithmetic.c:    if (sp[0]->s_n&7)
d_arithmetic.c:            sp[0]->s_vec, sp[1]->s_vec, sp[2]->s_vec, sp[0]->s_n);
d_arithmetic.c:            sp[0]->s_vec, sp[1]->s_vec, sp[2]->s_vec, sp[0]->s_n);
d_arithmetic.c:    if (sp[0]->s_n&7)
d_arithmetic.c:        dsp_add(scalartimes_perform, 4, sp[0]->s_vec, &x->x_g,
d_arithmetic.c:            sp[1]->s_vec, sp[0]->s_n);
d_arithmetic.c:        dsp_add(scalartimes_perf8, 4, sp[0]->s_vec, &x->x_g,
d_arithmetic.c:            sp[1]->s_vec, sp[0]->s_n);
d_arithmetic.c:/* ----------------------------- over ----------------------------- */
d_arithmetic.c:        floatinlet_new(&x->x_obj, &x->x_g);
d_arithmetic.c:        x->x_g = atom_getfloatarg(0, argc, argv);
d_arithmetic.c:        outlet_new(&x->x_obj, &s_signal);
d_arithmetic.c:        x->x_f = 0;
d_arithmetic.c:        inlet_new(&x->x_obj, &x->x_obj.ob_pd, &s_signal, &s_signal);
d_arithmetic.c:        outlet_new(&x->x_obj, &s_signal);
d_arithmetic.c:        x->x_f = 0;
d_arithmetic.c:    while (n--)
d_arithmetic.c:    for (; n; n -= 8, in1 += 8, in2 += 8, out += 8)
d_arithmetic.c:    while (n--) *out++ = *in++ * f; 
d_arithmetic.c:    for (; n; n -= 8, in += 8, out += 8)
d_arithmetic.c:    if (sp[0]->s_n&7)
d_arithmetic.c:            sp[0]->s_vec, sp[1]->s_vec, sp[2]->s_vec, sp[0]->s_n);
d_arithmetic.c:            sp[0]->s_vec, sp[1]->s_vec, sp[2]->s_vec, sp[0]->s_n);
d_arithmetic.c:    if (sp[0]->s_n&7)
d_arithmetic.c:        dsp_add(scalarover_perform, 4, sp[0]->s_vec, &x->x_g,
d_arithmetic.c:            sp[1]->s_vec, sp[0]->s_n);
d_arithmetic.c:        dsp_add(scalarover_perf8, 4, sp[0]->s_vec, &x->x_g,
d_arithmetic.c:            sp[1]->s_vec, sp[0]->s_n);
d_arithmetic.c:/* ----------------------------- max ----------------------------- */
d_arithmetic.c:        floatinlet_new(&x->x_obj, &x->x_g);
d_arithmetic.c:        x->x_g = atom_getfloatarg(0, argc, argv);
d_arithmetic.c:        outlet_new(&x->x_obj, &s_signal);
d_arithmetic.c:        x->x_f = 0;
d_arithmetic.c:        inlet_new(&x->x_obj, &x->x_obj.ob_pd, &s_signal, &s_signal);
d_arithmetic.c:        outlet_new(&x->x_obj, &s_signal);
d_arithmetic.c:        x->x_f = 0;
d_arithmetic.c:    while (n--)
d_arithmetic.c:    for (; n; n -= 8, in1 += 8, in2 += 8, out += 8)
d_arithmetic.c:    while (n--)
d_arithmetic.c:    for (; n; n -= 8, in += 8, out += 8)
d_arithmetic.c:    if (sp[0]->s_n&7)
d_arithmetic.c:            sp[0]->s_vec, sp[1]->s_vec, sp[2]->s_vec, sp[0]->s_n);
d_arithmetic.c:            sp[0]->s_vec, sp[1]->s_vec, sp[2]->s_vec, sp[0]->s_n);
d_arithmetic.c:    if (sp[0]->s_n&7)
d_arithmetic.c:        dsp_add(scalarmax_perform, 4, sp[0]->s_vec, &x->x_g,
d_arithmetic.c:            sp[1]->s_vec, sp[0]->s_n);
d_arithmetic.c:        dsp_add(scalarmax_perf8, 4, sp[0]->s_vec, &x->x_g,
d_arithmetic.c:            sp[1]->s_vec, sp[0]->s_n);
d_arithmetic.c:/* ----------------------------- min ----------------------------- */
d_arithmetic.c:        floatinlet_new(&x->x_obj, &x->x_g);
d_arithmetic.c:        x->x_g = atom_getfloatarg(0, argc, argv);
d_arithmetic.c:        outlet_new(&x->x_obj, &s_signal);
d_arithmetic.c:        x->x_f = 0;
d_arithmetic.c:        inlet_new(&x->x_obj, &x->x_obj.ob_pd, &s_signal, &s_signal);
d_arithmetic.c:        outlet_new(&x->x_obj, &s_signal);
d_arithmetic.c:        x->x_f = 0;
d_arithmetic.c:    while (n--)
d_arithmetic.c:    for (; n; n -= 8, in1 += 8, in2 += 8, out += 8)
d_arithmetic.c:    while (n--)
d_arithmetic.c:    for (; n; n -= 8, in += 8, out += 8)
d_arithmetic.c:    if (sp[0]->s_n&7)
d_arithmetic.c:            sp[0]->s_vec, sp[1]->s_vec, sp[2]->s_vec, sp[0]->s_n);
d_arithmetic.c:            sp[0]->s_vec, sp[1]->s_vec, sp[2]->s_vec, sp[0]->s_n);
d_arithmetic.c:    if (sp[0]->s_n&7)
d_arithmetic.c:        dsp_add(scalarmin_perform, 4, sp[0]->s_vec, &x->x_g,
d_arithmetic.c:            sp[1]->s_vec, sp[0]->s_n);
d_arithmetic.c:        dsp_add(scalarmin_perf8, 4, sp[0]->s_vec, &x->x_g,
d_arithmetic.c:            sp[1]->s_vec, sp[0]->s_n);
d_arithmetic.c:/* ----------------------- global setup routine ---------------- */
d_array.c:/* Copyright (c) 1997-1999 Miller Puckette and others.
d_array.c:/* ------------------------- tabwrite~ -------------------------- */
d_array.c:    x->x_phase = 0x7fffffff;
d_array.c:    x->x_arrayname = s;
d_array.c:    x->x_f = 0;
d_array.c:    t_garray *a = (t_garray *)pd_findbyclass(x->x_arrayname, garray_class);
d_array.c:    int n = (int)(w[3]), phase = x->x_phase, endphase = x->x_nsampsintab;
d_array.c:    if (!x->x_vec) goto bad;
d_array.c:        int nxfer = endphase - phase;
d_array.c:        t_word *wp = x->x_vec + phase;
d_array.c:        while (nxfer--)
d_array.c:            (wp++)->w_float = f;
d_array.c:        x->x_phase = phase;
d_array.c:    else x->x_phase = 0x7fffffff;
d_array.c:    x->x_arrayname = s;
d_array.c:    if (!(a = (t_garray *)pd_findbyclass(x->x_arrayname, garray_class)))
d_array.c:        if (*s->s_name) pd_error(x, "tabwrite~: %s: no such array",
d_array.c:            x->x_arrayname->s_name);
d_array.c:        x->x_vec = 0;
d_array.c:    else if (!garray_getfloatwords(a, &x->x_nsampsintab, &x->x_vec))
d_array.c:        pd_error(x, "%s: bad template for tabwrite~", x->x_arrayname->s_name);
d_array.c:        x->x_vec = 0;
d_array.c:    tabwrite_tilde_set(x, x->x_arrayname);
d_array.c:    dsp_add(tabwrite_tilde_perform, 3, x, sp[0]->s_vec, sp[0]->s_n);
d_array.c:    x->x_phase = 0;
d_array.c:    x->x_phase = (f > 0 ? f : 0);
d_array.c:    if (x->x_phase != 0x7fffffff)
d_array.c:        x->x_phase = 0x7fffffff;
d_array.c:/* ------------ tabplay~ - non-transposing sample playback --------------- */
d_array.c:    x->x_clock = clock_new(x, (t_method)tabplay_tilde_tick);
d_array.c:    x->x_phase = 0x7fffffff;
d_array.c:    x->x_limit = 0;
d_array.c:    x->x_arrayname = s;
d_array.c:    outlet_new(&x->x_obj, &s_signal);
d_array.c:    x->x_bangout = outlet_new(&x->x_obj, &s_bang);
d_array.c:    int n = (int)(w[3]), phase = x->x_phase,
d_array.c:        endphase = (x->x_nsampsintab < x->x_limit ?
d_array.c:            x->x_nsampsintab : x->x_limit), nxfer, n3;
d_array.c:    if (!x->x_vec || phase >= endphase)
d_array.c:    nxfer = endphase - phase;
d_array.c:    wp = x->x_vec + phase;
d_array.c:    n3 = n - nxfer;
d_array.c:    while (nxfer--)
d_array.c:        *out++ = (wp++)->w_float;
d_array.c:        clock_delay(x->x_clock, 0);
d_array.c:        x->x_phase = 0x7fffffff;
d_array.c:        while (n3--)
d_array.c:    else x->x_phase = phase;
d_array.c:    while (n--) *out++ = 0;
d_array.c:    x->x_arrayname = s;
d_array.c:    if (!(a = (t_garray *)pd_findbyclass(x->x_arrayname, garray_class)))
d_array.c:        if (*s->s_name) pd_error(x, "tabplay~: %s: no such array",
d_array.c:            x->x_arrayname->s_name);
d_array.c:        x->x_vec = 0;
d_array.c:    else if (!garray_getfloatwords(a, &x->x_nsampsintab, &x->x_vec))
d_array.c:        pd_error(x, "%s: bad template for tabplay~", x->x_arrayname->s_name);
d_array.c:        x->x_vec = 0;
d_array.c:    tabplay_tilde_set(x, x->x_arrayname);
d_array.c:    dsp_add(tabplay_tilde_perform, 3, x, sp[0]->s_vec, sp[0]->s_n);
d_array.c:        x->x_limit = 0x7fffffff;
d_array.c:        x->x_limit = start + length;
d_array.c:    x->x_phase = start;
d_array.c:    x->x_phase = 0x7fffffff;
d_array.c:    outlet_bang(x->x_bangout);
d_array.c:    clock_free(x->x_clock);
d_array.c:    x->x_arrayname = s;
d_array.c:    x->x_vec = 0;
d_array.c:    outlet_new(&x->x_obj, gensym("signal"));
d_array.c:    x->x_f = 0;
d_array.c:    t_word *buf = x->x_vec;
d_array.c:    maxindex = x->x_npoints - 1;
d_array.c:    while (n--) *out++ = 0;
d_array.c:    x->x_arrayname = s;
d_array.c:    if (!(a = (t_garray *)pd_findbyclass(x->x_arrayname, garray_class)))
d_array.c:        if (*s->s_name)
d_array.c:            pd_error(x, "tabread~: %s: no such array", x->x_arrayname->s_name);
d_array.c:        x->x_vec = 0;
d_array.c:    else if (!garray_getfloatwords(a, &x->x_npoints, &x->x_vec))
d_array.c:        pd_error(x, "%s: bad template for tabread~", x->x_arrayname->s_name);
d_array.c:        x->x_vec = 0;
d_array.c:    tabread_tilde_set(x, x->x_arrayname);
d_array.c:        sp[0]->s_vec, sp[1]->s_vec, sp[0]->s_n);
d_array.c:    x->x_arrayname = s;
d_array.c:    x->x_vec = 0;
d_array.c:    outlet_new(&x->x_obj, gensym("signal"));
d_array.c:    floatinlet_new(&x->x_obj, &x->x_onset);
d_array.c:    x->x_f = 0;
d_array.c:    x->x_onset = 0;
d_array.c:    t_word *buf = x->x_vec, *wp;
d_array.c:    double onset = x->x_onset;
d_array.c:    maxindex = x->x_npoints - 3;
d_array.c:#if 0       /* test for spam -- I'm not ready to deal with this */
d_array.c:    if (xmax < xmin + x->c_maxextent) xmax = xmin + x->c_maxextent;
d_array.c:    for (i = 0, splitlo = xmin+ x->c_maxextent, splithi = xmax - x->c_maxextent,
d_array.c:        else frac = findex - index;
d_array.c:        a = wp[-1].w_float;
d_array.c:        cminusb = c-b;
d_array.c:            cminusb - 0.1666667f * (1.-frac) * (
d_array.c:                (d - a - 3.0f * cminusb) * frac + (d + 2.0f*a - 3.0f*b)
d_array.c:    while (n--) *out++ = 0;
d_array.c:    x->x_arrayname = s;
d_array.c:    if (!(a = (t_garray *)pd_findbyclass(x->x_arrayname, garray_class)))
d_array.c:        if (*s->s_name)
d_array.c:            pd_error(x, "tabread4~: %s: no such array", x->x_arrayname->s_name);
d_array.c:        x->x_vec = 0;
d_array.c:    else if (!garray_getfloatwords(a, &x->x_npoints, &x->x_vec))
d_array.c:        pd_error(x, "%s: bad template for tabread4~", x->x_arrayname->s_name);
d_array.c:        x->x_vec = 0;
d_array.c:    tabread4_tilde_set(x, x->x_arrayname);
d_array.c:        sp[0]->s_vec, sp[1]->s_vec, sp[0]->s_n);
d_array.c:    x->x_arrayname = s;
d_array.c:    x->x_vec = 0;
d_array.c:    x->x_fnpoints = 512.;
d_array.c:    x->x_finvnpoints = (1./512.);
d_array.c:    outlet_new(&x->x_obj, gensym("signal"));
d_array.c:    inlet_new(&x->x_obj, &x->x_obj.ob_pd, &s_float, gensym("ft1"));
d_array.c:    x->x_f = 0;
d_array.c:    t_float fnpoints = x->x_fnpoints;
d_array.c:    int mask = fnpoints - 1;
d_array.c:    t_float conv = fnpoints * x->x_conv;
d_array.c:    t_word *tab = x->x_vec, *addr;
d_array.c:    double dphase = fnpoints * x->x_phase + UNITBIT32;
d_array.c:    while (n--)
d_array.c:        frac = tf.tf_d - UNITBIT32;
d_array.c:        cminusb = c-b;
d_array.c:            cminusb - 0.1666667f * (1.-frac) * (
d_array.c:                (d - a - 3.0f * cminusb) * frac + (d + 2.0f*a - 3.0f*b)
d_array.c:    tf.tf_d = dphase + (UNITBIT32 * fnpoints - UNITBIT32);
d_array.c:    x->x_phase = (tf.tf_d - UNITBIT32 * fnpoints)  * x->x_finvnpoints;
d_array.c:    while (n--) *out++ = 0;
d_array.c:    x->x_arrayname = s;
d_array.c:    if (!(a = (t_garray *)pd_findbyclass(x->x_arrayname, garray_class)))
d_array.c:        if (*s->s_name)
d_array.c:            pd_error(x, "tabosc4~: %s: no such array", x->x_arrayname->s_name);
d_array.c:        x->x_vec = 0;
d_array.c:    else if (!garray_getfloatwords(a, &pointsinarray, &x->x_vec))
d_array.c:        pd_error(x, "%s: bad template for tabosc4~", x->x_arrayname->s_name);
d_array.c:        x->x_vec = 0;
d_array.c:    else if ((npoints = pointsinarray - 3) != (1 << ilog2(pointsinarray - 3)))
d_array.c:            x->x_arrayname->s_name, pointsinarray);
d_array.c:        x->x_vec = 0;
d_array.c:        x->x_fnpoints = npoints;
d_array.c:        x->x_finvnpoints = 1./npoints;
d_array.c:    x->x_phase = f;
d_array.c:    x->x_conv = 1. / sp[0]->s_sr;
d_array.c:    tabosc4_tilde_set(x, x->x_arrayname);
d_array.c:        sp[0]->s_vec, sp[1]->s_vec, sp[0]->s_n);
d_array.c:/* ------------------------ tabsend~ ------------------------- */
d_array.c:    x->x_graphcount = 0;
d_array.c:    x->x_arrayname = s;
d_array.c:    x->x_f = 0;
d_array.c:    t_word *dest = x->x_vec;
d_array.c:    int i = x->x_graphcount;
d_array.c:    if (!x->x_vec) goto bad;
d_array.c:    if (n > x->x_npoints)
d_array.c:        n = x->x_npoints;
d_array.c:    while (n--)
d_array.c:         (dest++)->w_float = f;
d_array.c:    if (!i--)
d_array.c:        t_garray *a = (t_garray *)pd_findbyclass(x->x_arrayname, garray_class);
d_array.c:        i = x->x_graphperiod;
d_array.c:    x->x_graphcount = i;
d_array.c:    x->x_arrayname = s;
d_array.c:    if (!(a = (t_garray *)pd_findbyclass(x->x_arrayname, garray_class)))
d_array.c:        if (*s->s_name)
d_array.c:            pd_error(x, "tabsend~: %s: no such array", x->x_arrayname->s_name);
d_array.c:        x->x_vec = 0;
d_array.c:    else if (!garray_getfloatwords(a, &x->x_npoints, &x->x_vec))
d_array.c:        pd_error(x, "%s: bad template for tabsend~", x->x_arrayname->s_name);
d_array.c:        x->x_vec = 0;
d_array.c:    int n = sp[0]->s_n;
d_array.c:    int ticksper = sp[0]->s_sr/n;
d_array.c:    tabsend_set(x, x->x_arrayname);
d_array.c:    x->x_graphperiod = ticksper;
d_array.c:    if (x->x_graphcount > ticksper) x->x_graphcount = ticksper;
d_array.c:    dsp_add(tabsend_perform, 3, x, sp[0]->s_vec, n);
d_array.c:/* ------------------------ tabreceive~ ------------------------- */
d_array.c:    t_word *from = x->x_vec;
d_array.c:        int vecsize = x->x_npoints;
d_array.c:        while (vecsize--)
d_array.c:            *out++ = (from++)->w_float;
d_array.c:        vecsize = n - x->x_npoints;
d_array.c:            while (vecsize--)
d_array.c:    else while (n--) *out++ = 0;
d_array.c:    x->x_arrayname = s;
d_array.c:    if (!(a = (t_garray *)pd_findbyclass(x->x_arrayname, garray_class)))
d_array.c:        if (*s->s_name)
d_array.c:                x->x_arrayname->s_name);
d_array.c:        x->x_vec = 0;
d_array.c:    else if (!garray_getfloatwords(a, &x->x_npoints, &x->x_vec))
d_array.c:            x->x_arrayname->s_name);
d_array.c:        x->x_vec = 0;
d_array.c:    tabreceive_set(x, x->x_arrayname);
d_array.c:    dsp_add(tabreceive_perform, 3, x, sp[0]->s_vec, sp[0]->s_n);
d_array.c:    x->x_arrayname = s;
d_array.c:    outlet_new(&x->x_obj, &s_signal);
d_array.c:/* ---------- tabread: control, non-interpolating ------------------------ */
d_array.c:    if (!(a = (t_garray *)pd_findbyclass(x->x_arrayname, garray_class)))
d_array.c:        pd_error(x, "%s: no such array", x->x_arrayname->s_name);
d_array.c:        pd_error(x, "%s: bad template for tabread", x->x_arrayname->s_name);
d_array.c:        else if (n >= npoints) n = npoints - 1;
d_array.c:        outlet_float(x->x_obj.ob_outlet, (npoints ? vec[n].w_float : 0));
d_array.c:    x->x_arrayname = s;
d_array.c:    x->x_arrayname = s;
d_array.c:    outlet_new(&x->x_obj, &s_float);
d_array.c:/* ---------- tabread4: control, 4-point interpolation --------------- */
d_array.c:    if (!(a = (t_garray *)pd_findbyclass(x->x_arrayname, garray_class)))
d_array.c:        pd_error(x, "%s: no such array", x->x_arrayname->s_name);
d_array.c:        pd_error(x, "%s: bad template for tabread4", x->x_arrayname->s_name);
d_array.c:        outlet_float(x->x_obj.ob_outlet, 0);
d_array.c:        outlet_float(x->x_obj.ob_outlet, vec[1].w_float);
d_array.c:    else if (f >= npoints - 2)
d_array.c:        outlet_float(x->x_obj.ob_outlet, vec[npoints - 2].w_float);
d_array.c:        if (n >= npoints - 2)
d_array.c:            n = npoints - 3;
d_array.c:        frac = f - n;
d_array.c:        a = wp[-1].w_float;
d_array.c:        cminusb = c-b;
d_array.c:        outlet_float(x->x_obj.ob_outlet, b + frac * (
d_array.c:            cminusb - 0.1666667f * (1.-frac) * (
d_array.c:                (d - a - 3.0f * cminusb) * frac + (d + 2.0f*a - 3.0f*b))));
d_array.c:    x->x_arrayname = s;
d_array.c:    x->x_arrayname = s;
d_array.c:    outlet_new(&x->x_obj, &s_float);
d_array.c:/* ------------------ tabwrite: control ------------------------ */
d_array.c:    if (!(a = (t_garray *)pd_findbyclass(x->x_arrayname, garray_class)))
d_array.c:        pd_error(x, "%s: no such array", x->x_arrayname->s_name);
d_array.c:        pd_error(x, "%s: bad template for tabwrite", x->x_arrayname->s_name);
d_array.c:        int n = x->x_ft1;
d_array.c:            n = vecsize-1;
d_array.c:    x->x_arrayname = s;
d_array.c:    x->x_ft1 = 0;
d_array.c:    x->x_arrayname = s;
d_array.c:    floatinlet_new(&x->x_obj, &x->x_ft1);
d_array.c:/* ------------------------ global setup routine ------------------------- */
d_ctl.c:/* Copyright (c) 1997-1999 Miller Puckette.
d_ctl.c:/*  sig~ and line~ control-to-signal converters;
d_ctl.c:    snapshot~ signal-to-control converter.
d_ctl.c:/* -------------------------- sig~ ------------------------------ */
d_ctl.c:    while (n--)
d_ctl.c:    for (; n; n -= 8, out += 8)
d_ctl.c:    x->x_f = f;
d_ctl.c:    dsp_add(sig_tilde_perform, 3, &x->x_f, sp[0]->s_vec, sp[0]->s_n);
d_ctl.c:    x->x_f = f;
d_ctl.c:    outlet_new(&x->x_obj, gensym("signal"));
d_ctl.c:/* -------------------------- line~ ------------------------------ */
d_ctl.c:    t_sample x_value; /* current value of ramp at block-borders */
d_ctl.c:    t_sample f = x->x_value;
d_ctl.c:            x->x_value = f = 0;
d_ctl.c:    if (x->x_retarget)
d_ctl.c:        int nticks = x->x_inletwas * x->x_dspticktomsec;
d_ctl.c:        x->x_ticksleft = nticks;
d_ctl.c:        x->x_biginc = (x->x_target - x->x_value)/(t_float)nticks;
d_ctl.c:        x->x_inc = x->x_1overn * x->x_biginc;
d_ctl.c:        x->x_retarget = 0;
d_ctl.c:    if (x->x_ticksleft)
d_ctl.c:        t_sample f = x->x_value;
d_ctl.c:        while (n--) *out++ = f, f += x->x_inc;
d_ctl.c:        x->x_value += x->x_biginc;
d_ctl.c:        x->x_ticksleft--;
d_ctl.c:        t_sample g = x->x_value = x->x_target;
d_ctl.c:        while (n--)
d_ctl.c:    t_sample f = x->x_value;
d_ctl.c:        x->x_value = f = 0;
d_ctl.c:    if (x->x_retarget)
d_ctl.c:        int nticks = x->x_inletwas * x->x_dspticktomsec;
d_ctl.c:        x->x_ticksleft = nticks;
d_ctl.c:        x->x_biginc = (x->x_target - x->x_value)/(t_sample)nticks;
d_ctl.c:        x->x_inc = x->x_1overn * x->x_biginc;
d_ctl.c:        x->x_retarget = 0;
d_ctl.c:    if (x->x_ticksleft)
d_ctl.c:        t_sample f = x->x_value;
d_ctl.c:        while (n--) *out++ = f, f += x->x_inc;
d_ctl.c:        x->x_value += x->x_biginc;
d_ctl.c:        x->x_ticksleft--;
d_ctl.c:        t_sample f = x->x_value = x->x_target;
d_ctl.c:        for (; n; n -= 8, out += 8)
d_ctl.c:    if (x->x_inletvalue <= 0)
d_ctl.c:        x->x_target = x->x_value = f;
d_ctl.c:        x->x_ticksleft = x->x_retarget = 0;
d_ctl.c:        x->x_target = f;
d_ctl.c:        x->x_retarget = 1;
d_ctl.c:        x->x_inletwas = x->x_inletvalue;
d_ctl.c:        x->x_inletvalue = 0;
d_ctl.c:    x->x_target = x->x_value;
d_ctl.c:    x->x_ticksleft = x->x_retarget = 0;
d_ctl.c:    if(sp[0]->s_n&7)
d_ctl.c:        dsp_add(line_tilde_perform, 3, x, sp[0]->s_vec, sp[0]->s_n);
d_ctl.c:        dsp_add(line_tilde_perf8, 3, x, sp[0]->s_vec, sp[0]->s_n);
d_ctl.c:    x->x_1overn = 1./sp[0]->s_n;
d_ctl.c:    x->x_dspticktomsec = sp[0]->s_sr / (1000 * sp[0]->s_n);
d_ctl.c:    outlet_new(&x->x_obj, gensym("signal"));
d_ctl.c:    floatinlet_new(&x->x_obj, &x->x_inletvalue);
d_ctl.c:    x->x_ticksleft = x->x_retarget = 0;
d_ctl.c:    x->x_value = x->x_target = x->x_inletvalue = x->x_inletwas = 0;
d_ctl.c:/* -------------------------- vline~ ------------------------------ */
d_ctl.c:    double f = x->x_value;
d_ctl.c:    double inc = x->x_inc;
d_ctl.c:    double msecpersamp = x->x_msecpersamp;
d_ctl.c:    double samppermsec = x->x_samppermsec;
d_ctl.c:    double timenow, logicaltimenow = clock_gettimesince(x->x_referencetime);
d_ctl.c:    t_vseg *s = x->x_list;
d_ctl.c:    if (logicaltimenow != x->x_lastlogicaltime)
d_ctl.c:        x->x_lastlogicaltime = logicaltimenow;
d_ctl.c:        x->x_nextblocktime = logicaltimenow - sampstotime * msecpersamp;
d_ctl.c:    timenow = x->x_nextblocktime;
d_ctl.c:    x->x_nextblocktime = timenow + n * msecpersamp;
d_ctl.c:            if (s->s_starttime < timenext)
d_ctl.c:                if (x->x_targettime <= timenext)
d_ctl.c:                    f = x->x_target, inc = 0;
d_ctl.c:                    /* if zero-length segment bash output value */
d_ctl.c:                if (s->s_targettime <= s->s_starttime)
d_ctl.c:                    f = s->s_target;
d_ctl.c:                    double incpermsec = (s->s_target - f)/
d_ctl.c:                        (s->s_targettime - s->s_starttime);
d_ctl.c:                    f = f + incpermsec * (timenext - s->s_starttime);
d_ctl.c:                x->x_inc = inc;
d_ctl.c:                x->x_target = s->s_target;
d_ctl.c:                x->x_targettime = s->s_targettime;
d_ctl.c:                x->x_list = s->s_next;
d_ctl.c:                s = x->x_list;
d_ctl.c:        if (x->x_targettime <= timenext)
d_ctl.c:            f = x->x_target, inc = x->x_inc = 0, x->x_targettime = 1e20;
d_ctl.c:    x->x_value = f;
d_ctl.c:    for (s1 = x->x_list; s1; s1 = s2)
d_ctl.c:        s2 = s1->s_next, t_freebytes(s1, sizeof(*s1));
d_ctl.c:    x->x_list = 0;
d_ctl.c:    x->x_inc = 0;
d_ctl.c:    x->x_inlet1 = x->x_inlet2 = 0;
d_ctl.c:    x->x_target = x->x_value;
d_ctl.c:    x->x_targettime = 1e20;
d_ctl.c:    double timenow = clock_gettimesince(x->x_referencetime);
d_ctl.c:    t_float inlet1 = (x->x_inlet1 < 0 ? 0 : x->x_inlet1);
d_ctl.c:    t_float inlet2 = x->x_inlet2;
d_ctl.c:        x->x_value = f;
d_ctl.c:        we'll do a jump-and-slide starting at that time.) */
d_ctl.c:    if (!x->x_list || x->x_list->s_starttime > starttime ||
d_ctl.c:        (x->x_list->s_starttime == starttime &&
d_ctl.c:            (x->x_list->s_targettime > x->x_list->s_starttime || inlet1 <= 0)))
d_ctl.c:        deletefrom = x->x_list;
d_ctl.c:        x->x_list = snew;
d_ctl.c:        for (s1 = x->x_list; s2 = s1->s_next; s1 = s2)
d_ctl.c:            if (s2->s_starttime > starttime ||
d_ctl.c:                (s2->s_starttime == starttime &&
d_ctl.c:                    (s2->s_targettime > s2->s_starttime || inlet1 <= 0)))
d_ctl.c:                s1->s_next = snew;
d_ctl.c:        s1->s_next = snew;
d_ctl.c:        s1 = deletefrom->s_next;
d_ctl.c:    snew->s_next = 0;
d_ctl.c:    snew->s_target = f;
d_ctl.c:    snew->s_starttime = starttime;
d_ctl.c:    snew->s_targettime = starttime + inlet1;
d_ctl.c:    x->x_inlet1 = x->x_inlet2 = 0;
d_ctl.c:    dsp_add(vline_tilde_perform, 3, x, sp[0]->s_vec, sp[0]->s_n);
d_ctl.c:    x->x_samppermsec = ((double)(sp[0]->s_sr)) / 1000;
d_ctl.c:    x->x_msecpersamp = ((double)1000) / sp[0]->s_sr;
d_ctl.c:    outlet_new(&x->x_obj, gensym("signal"));
d_ctl.c:    floatinlet_new(&x->x_obj, &x->x_inlet1);
d_ctl.c:    floatinlet_new(&x->x_obj, &x->x_inlet2);
d_ctl.c:    x->x_inlet1 = x->x_inlet2 = 0;
d_ctl.c:    x->x_value = x->x_inc = 0;
d_ctl.c:    x->x_referencetime = x->x_lastlogicaltime = x->x_nextblocktime =
d_ctl.c:    x->x_list = 0;
d_ctl.c:    x->x_samppermsec = 0;
d_ctl.c:    x->x_targettime = 1e20;
d_ctl.c:/* -------------------------- snapshot~ ------------------------------ */
d_ctl.c:    x->x_value = 0;
d_ctl.c:    outlet_new(&x->x_obj, &s_float);
d_ctl.c:    x->x_f = 0;
d_ctl.c:    dsp_add(snapshot_tilde_perform, 2, sp[0]->s_vec + (sp[0]->s_n-1),
d_ctl.c:        &x->x_value);
d_ctl.c:    outlet_float(x->x_obj.ob_outlet, x->x_value);
d_ctl.c:    x->x_value = f;
d_ctl.c:/* -------------------------- vsnapshot~ ------------------------------ */
d_ctl.c:    outlet_new(&x->x_obj, &s_float);
d_ctl.c:    x->x_f = 0;
d_ctl.c:    x->x_n = 0;
d_ctl.c:    x->x_vec = 0;
d_ctl.c:    x->x_gotone = 0;
d_ctl.c:    t_sample *out = x->x_vec;
d_ctl.c:    int n = x->x_n, i;
d_ctl.c:    x->x_time = clock_getlogicaltime();
d_ctl.c:    x->x_gotone = 1;
d_ctl.c:    int n = sp[0]->s_n;
d_ctl.c:    if (n != x->x_n)
d_ctl.c:        if (x->x_vec)
d_ctl.c:            t_freebytes(x->x_vec, x->x_n * sizeof(t_sample));
d_ctl.c:        x->x_vec = (t_sample *)getbytes(n * sizeof(t_sample));
d_ctl.c:        x->x_gotone = 0;
d_ctl.c:        x->x_n = n;
d_ctl.c:    x->x_sampspermsec = sp[0]->s_sr / 1000;
d_ctl.c:    dsp_add(vsnapshot_tilde_perform, 2, sp[0]->s_vec, x);
d_ctl.c:    if (x->x_gotone)
d_ctl.c:        int indx = clock_gettimesince(x->x_time) * x->x_sampspermsec;
d_ctl.c:        else if (indx >= x->x_n)
d_ctl.c:            indx = x->x_n - 1;
d_ctl.c:        val = x->x_vec[indx];
d_ctl.c:    outlet_float(x->x_obj.ob_outlet, val);
d_ctl.c:    if (x->x_vec)
d_ctl.c:        t_freebytes(x->x_vec, x->x_n * sizeof(t_sample));
d_ctl.c:/* ---------------- env~ - simple envelope follower. ----------------- */
d_ctl.c:    x->x_buf = buf;
d_ctl.c:    x->x_npoints = npoints;
d_ctl.c:    x->x_phase = 0;
d_ctl.c:    x->x_period = period;
d_ctl.c:    for (i = 0; i < MAXOVERLAP; i++) x->x_sumbuf[i] = 0;
d_ctl.c:        buf[i] = (1. - cos((2 * 3.14159 * i) / npoints))/npoints;
d_ctl.c:    x->x_clock = clock_new(x, (t_method)env_tilde_tick);
d_ctl.c:    x->x_outlet = outlet_new(&x->x_obj, gensym("float"));
d_ctl.c:    x->x_f = 0;
d_ctl.c:    x->x_allocforvs = INITVSTAKEN;
d_ctl.c:    for (count = x->x_phase, sump = x->x_sumbuf;
d_ctl.c:        count < x->x_npoints; count += x->x_realperiod, sump++)
d_ctl.c:        t_sample *hp = x->x_buf + count;
d_ctl.c:            fp--;
d_ctl.c:    x->x_phase -= n;
d_ctl.c:    if (x->x_phase < 0)
d_ctl.c:        x->x_result = x->x_sumbuf[0];
d_ctl.c:        for (count = x->x_realperiod, sump = x->x_sumbuf;
d_ctl.c:            count < x->x_npoints; count += x->x_realperiod, sump++)
d_ctl.c:        x->x_phase = x->x_realperiod - n;
d_ctl.c:        clock_delay(x->x_clock, 0L);
d_ctl.c:    if (x->x_period % sp[0]->s_n) x->x_realperiod =
d_ctl.c:        x->x_period + sp[0]->s_n - (x->x_period % sp[0]->s_n);
d_ctl.c:    else x->x_realperiod = x->x_period;
d_ctl.c:    if (sp[0]->s_n > x->x_allocforvs)
d_ctl.c:        void *xx = resizebytes(x->x_buf,
d_ctl.c:            (x->x_npoints + x->x_allocforvs) * sizeof(t_sample),
d_ctl.c:            (x->x_npoints + sp[0]->s_n) * sizeof(t_sample));
d_ctl.c:        x->x_buf = (t_sample *)xx;
d_ctl.c:        x->x_allocforvs = sp[0]->s_n;
d_ctl.c:    dsp_add(env_tilde_perform, 3, x, sp[0]->s_vec, sp[0]->s_n);
d_ctl.c:    outlet_float(x->x_outlet, powtodb(x->x_result));
d_ctl.c:    clock_free(x->x_clock);
d_ctl.c:    freebytes(x->x_buf, (x->x_npoints + x->x_allocforvs) * sizeof(*x->x_buf));
d_ctl.c:/* --------------------- threshold~ ----------------------------- */
d_ctl.c:    x->x_state = 0;             /* low state */
d_ctl.c:    x->x_deadwait = 0;          /* no dead time */
d_ctl.c:    x->x_clock = clock_new(x, (t_method)threshold_tilde_tick);
d_ctl.c:    x->x_outlet1 = outlet_new(&x->x_obj, &s_bang);
d_ctl.c:    x->x_outlet2 = outlet_new(&x->x_obj, &s_bang);
d_ctl.c:    inlet_new(&x->x_obj, &x->x_obj.ob_pd, &s_float, gensym("ft1"));
d_ctl.c:    x->x_msecpertick = 0.;
d_ctl.c:    x->x_f = 0;
d_ctl.c:    x->x_hithresh = hithresh;
d_ctl.c:    x->x_hideadtime = hideadtime;
d_ctl.c:    x->x_lothresh = lothresh;
d_ctl.c:    x->x_lodeadtime = lodeadtime;
d_ctl.c:    /* number in inlet sets state -- note incompatible with JMAX which used
d_ctl.c:    x->x_state = (f != 0);
d_ctl.c:    x->x_deadwait = 0;
d_ctl.c:    if (x->x_state)
d_ctl.c:        outlet_bang(x->x_outlet1);
d_ctl.c:    else outlet_bang(x->x_outlet2);
d_ctl.c:    if (x->x_deadwait > 0)
d_ctl.c:        x->x_deadwait -= x->x_msecpertick;
d_ctl.c:    else if (x->x_state)
d_ctl.c:        for (; n--; in1++)
d_ctl.c:            if (*in1 < x->x_lothresh)
d_ctl.c:                clock_delay(x->x_clock, 0L);
d_ctl.c:                x->x_state = 0;
d_ctl.c:                x->x_deadwait = x->x_lodeadtime;
d_ctl.c:        for (; n--; in1++)
d_ctl.c:            if (*in1 >= x->x_hithresh)
d_ctl.c:                clock_delay(x->x_clock, 0L);
d_ctl.c:                x->x_state = 1;
d_ctl.c:                x->x_deadwait = x->x_hideadtime;
d_ctl.c:    x->x_msecpertick = 1000. * sp[0]->s_n / sp[0]->s_sr;
d_ctl.c:    dsp_add(threshold_tilde_perform, 3, sp[0]->s_vec, x, sp[0]->s_n);
d_ctl.c:    clock_free(x->x_clock);
d_ctl.c:/* ------------------------ global setup routine ------------------------- */
d_dac.c:/* Copyright (c) 1997-1999 Miller Puckette.
d_dac.c:/* ----------------------------- dac~ --------------------------- */
d_dac.c:    x->x_n = argc;
d_dac.c:    x->x_vec = (t_int *)getbytes(argc * sizeof(*x->x_vec));
d_dac.c:        x->x_vec[i] = atom_getintarg(i, argc, argv);
d_dac.c:        inlet_new(&x->x_obj, &x->x_obj.ob_pd, &s_signal, &s_signal);
d_dac.c:    x->x_f = 0;
d_dac.c:    for (i = x->x_n, ip = x->x_vec, sp2 = sp; i--; ip++, sp2++)
d_dac.c:        int ch = *ip - 1;
d_dac.c:        if ((*sp2)->s_n != DEFDACBLKSIZE)
d_dac.c:                (*sp2)->s_vec, sys_soundout + DEFDACBLKSIZE*ch, DEFDACBLKSIZE);
d_dac.c:    freebytes(x->x_vec, x->x_n * sizeof(*x->x_vec));
d_dac.c:/* ----------------------------- adc~ --------------------------- */
d_dac.c:    x->x_n = argc;
d_dac.c:    x->x_vec = (t_int *)getbytes(argc * sizeof(*x->x_vec));
d_dac.c:        x->x_vec[i] = atom_getintarg(i, argc, argv);
d_dac.c:        outlet_new(&x->x_obj, &s_signal);
d_dac.c:    while (n--) *out++ = *in1++; 
d_dac.c:    for (; n; n -= 8, in1 += 8, out += 8)
d_dac.c:    for (i = x->x_n, ip = x->x_vec, sp2 = sp; i--; ip++, sp2++)
d_dac.c:        int ch = *ip - 1;
d_dac.c:        if ((*sp2)->s_n != DEFDACBLKSIZE)
d_dac.c:                (*sp2)->s_vec, DEFDACBLKSIZE);
d_dac.c:        else dsp_add_zero((*sp2)->s_vec, DEFDACBLKSIZE);
d_dac.c:    freebytes(x->x_vec, x->x_n * sizeof(*x->x_vec));
d_delay.c:/* Copyright (c) 1997-1999 Miller Puckette.
d_delay.c:/* ----------------------------- delwrite~ ----------------------------- */
d_delay.c:    int nsamps = x->x_deltime * sr * (t_float)(0.001f);
d_delay.c:    nsamps += ((- nsamps) & (SAMPBLK - 1));
d_delay.c:    if (x->x_cspace.c_n != nsamps) {
d_delay.c:      x->x_cspace.c_vec = (t_sample *)resizebytes(x->x_cspace.c_vec,
d_delay.c:        (x->x_cspace.c_n + XTRASAMPS) * sizeof(t_sample),
d_delay.c:      x->x_cspace.c_n = nsamps;
d_delay.c:      x->x_cspace.c_phase = XTRASAMPS;
d_delay.c:    if (x->x_rsortno != ugen_getsortno())
d_delay.c:        x->x_vecsize = vecsize;
d_delay.c:        x->x_rsortno = ugen_getsortno();
d_delay.c:    else if (vecsize != x->x_vecsize)
d_delay.c:    if (!*s->s_name) s = gensym("delwrite~");
d_delay.c:    pd_bind(&x->x_obj.ob_pd, s);
d_delay.c:    x->x_sym = s;
d_delay.c:    x->x_deltime = msec;
d_delay.c:    x->x_cspace.c_n = 0;
d_delay.c:    x->x_cspace.c_vec = getbytes(XTRASAMPS * sizeof(t_sample));
d_delay.c:    x->x_sortno = 0;
d_delay.c:    x->x_vecsize = 0;
d_delay.c:    x->x_f = 0;
d_delay.c:    int phase = c->c_phase, nsamps = c->c_n;
d_delay.c:    t_sample *vp = c->c_vec, *bp = vp + phase, *ep = vp + (c->c_n + XTRASAMPS);
d_delay.c:    while (n--)
d_delay.c:            vp[0] = ep[-4];
d_delay.c:            vp[1] = ep[-3];
d_delay.c:            vp[2] = ep[-2];
d_delay.c:            vp[3] = ep[-1];
d_delay.c:            phase -= nsamps;
d_delay.c:    c->c_phase = phase; 
d_delay.c:    dsp_add(sigdelwrite_perform, 3, sp[0]->s_vec, &x->x_cspace, sp[0]->s_n);
d_delay.c:    x->x_sortno = ugen_getsortno();
d_delay.c:    sigdelwrite_checkvecsize(x, sp[0]->s_n);
d_delay.c:    sigdelwrite_updatesr(x, sp[0]->s_sr);
d_delay.c:    pd_unbind(&x->x_obj.ob_pd, x->x_sym);
d_delay.c:    freebytes(x->x_cspace.c_vec,
d_delay.c:        (x->x_cspace.c_n + XTRASAMPS) * sizeof(t_sample));
d_delay.c:/* ----------------------------- delread~ ----------------------------- */
d_delay.c:    x->x_sym = s;
d_delay.c:    x->x_sr = 1;
d_delay.c:    x->x_n = 1;
d_delay.c:    x->x_zerodel = 0;
d_delay.c:    outlet_new(&x->x_obj, &s_signal);
d_delay.c:        (t_sigdelwrite *)pd_findbyclass(x->x_sym, sigdelwrite_class);
d_delay.c:    x->x_deltime = f;
d_delay.c:        int delsize = delwriter->x_cspace.c_n;
d_delay.c:        x->x_delsamps = (int)(0.5 + x->x_sr * x->x_deltime)
d_delay.c:            + x->x_n - x->x_zerodel;
d_delay.c:        if (x->x_delsamps < x->x_n) x->x_delsamps = x->x_n;
d_delay.c:        else if (x->x_delsamps > delwriter->x_cspace.c_n - DEFDELVS)
d_delay.c:            x->x_delsamps = delwriter->x_cspace.c_n - DEFDELVS;
d_delay.c:    int phase = c->c_phase - delsamps, nsamps = c->c_n;
d_delay.c:    t_sample *vp = c->c_vec, *bp, *ep = vp + (c->c_n + XTRASAMPS);
d_delay.c:    while (n--)
d_delay.c:        if (bp == ep) bp -= nsamps;
d_delay.c:        (t_sigdelwrite *)pd_findbyclass(x->x_sym, sigdelwrite_class);
d_delay.c:    x->x_sr = sp[0]->s_sr * 0.001;
d_delay.c:    x->x_n = sp[0]->s_n;
d_delay.c:        sigdelwrite_updatesr(delwriter, sp[0]->s_sr);
d_delay.c:        sigdelwrite_checkvecsize(delwriter, sp[0]->s_n);
d_delay.c:        x->x_zerodel = (delwriter->x_sortno == ugen_getsortno() ?
d_delay.c:            0 : delwriter->x_vecsize);
d_delay.c:        sigdelread_float(x, x->x_deltime);
d_delay.c:            sp[0]->s_vec, &delwriter->x_cspace, &x->x_delsamps, sp[0]->s_n);
d_delay.c:    else if (*x->x_sym->s_name)
d_delay.c:        error("delread~: %s: no such delwrite~",x->x_sym->s_name);
d_delay.c:/* ----------------------------- vd~ ----------------------------- */
d_delay.c:    if (!*s->s_name) s = gensym("vd~");
d_delay.c:    x->x_sym = s;
d_delay.c:    x->x_sr = 1;
d_delay.c:    x->x_zerodel = 0;
d_delay.c:    outlet_new(&x->x_obj, &s_signal);
d_delay.c:    x->x_f = 0;
d_delay.c:    int nsamps = ctl->c_n;
d_delay.c:    t_sample limit = nsamps - n - 1;
d_delay.c:    t_sample fn = n-1;
d_delay.c:    t_sample *vp = ctl->c_vec, *bp, *wp = vp + ctl->c_phase;
d_delay.c:    t_sample zerodel = x->x_zerodel;
d_delay.c:    while (n--)
d_delay.c:        t_sample delsamps = x->x_sr * *in++ - zerodel, frac;
d_delay.c:        fn = fn - 1.0f;
d_delay.c:        frac = delsamps - (t_sample)idelsamps;
d_delay.c:        bp = wp - idelsamps;
d_delay.c:        d = bp[-3];
d_delay.c:        c = bp[-2];
d_delay.c:        b = bp[-1];
d_delay.c:        cminusb = c-b;
d_delay.c:            cminusb - 0.1666667f * (1.-frac) * (
d_delay.c:                (d - a - 3.0f * cminusb) * frac + (d + 2.0f*a - 3.0f*b)
d_delay.c:        (t_sigdelwrite *)pd_findbyclass(x->x_sym, sigdelwrite_class);
d_delay.c:    x->x_sr = sp[0]->s_sr * 0.001;
d_delay.c:        sigdelwrite_checkvecsize(delwriter, sp[0]->s_n);
d_delay.c:        x->x_zerodel = (delwriter->x_sortno == ugen_getsortno() ?
d_delay.c:            0 : delwriter->x_vecsize);
d_delay.c:            sp[0]->s_vec, sp[1]->s_vec,
d_delay.c:                &delwriter->x_cspace, x, sp[0]->s_n);
d_delay.c:    else error("vd~: %s: no such delwrite~",x->x_sym->s_name);
d_delay.c:/* ----------------------- global setup routine ---------------- */
d_fft.c:/* Copyright (c) 1997- Miller Puckette and others.
d_fft.c:/* ---------------- utility functions for DSP chains ---------------------- */
d_fft.c:    for (;n--; in1++, in2++)
d_fft.c:    while (n--)
d_fft.c:        *(--out) = - *in++;
d_fft.c:/* ------------------------ fft~ and ifft~ -------------------------------- */
d_fft.c:    outlet_new(&x->x_obj, gensym("signal"));
d_fft.c:    outlet_new(&x->x_obj, gensym("signal"));
d_fft.c:    inlet_new(&x->x_obj, &x->x_obj.ob_pd, &s_signal, &s_signal);
d_fft.c:    x->x_f = 0;
d_fft.c:    outlet_new(&x->x_obj, gensym("signal"));
d_fft.c:    outlet_new(&x->x_obj, gensym("signal"));
d_fft.c:    inlet_new(&x->x_obj, &x->x_obj.ob_pd, &s_signal, &s_signal);
d_fft.c:    x->x_f = 0;
d_fft.c:    int n = sp[0]->s_n;
d_fft.c:    t_sample *in1 = sp[0]->s_vec;
d_fft.c:    t_sample *in2 = sp[1]->s_vec;
d_fft.c:    t_sample *out1 = sp[2]->s_vec;
d_fft.c:    t_sample *out2 = sp[3]->s_vec;
d_fft.c:    dsp_add(f, 3, sp[2]->s_vec, sp[3]->s_vec, n);
d_fft.c:/* ----------------------- rfft~ -------------------------------- */
d_fft.c:    outlet_new(&x->x_obj, gensym("signal"));
d_fft.c:    outlet_new(&x->x_obj, gensym("signal"));
d_fft.c:    x->x_f = 0;
d_fft.c:    int n = sp[0]->s_n, n2 = (n>>1);
d_fft.c:    t_sample *in1 = sp[0]->s_vec;
d_fft.c:    t_sample *out1 = sp[1]->s_vec;
d_fft.c:    t_sample *out2 = sp[2]->s_vec;
d_fft.c:    dsp_add(sigrfft_flip, 3, out1 + (n2+1), out2 + n2, n2-1);
d_fft.c:    dsp_add_zero(out1 + (n2+1), ((n2-1)&(~7)));
d_fft.c:    dsp_add_zero(out1 + (n2+1) + ((n2-1)&(~7)), ((n2-1)&7));
d_fft.c:/* ----------------------- rifft~ -------------------------------- */
d_fft.c:    inlet_new(&x->x_obj, &x->x_obj.ob_pd, &s_signal, &s_signal);
d_fft.c:    outlet_new(&x->x_obj, gensym("signal"));
d_fft.c:    x->x_f = 0;
d_fft.c:    int n = sp[0]->s_n, n2 = (n>>1);
d_fft.c:    t_sample *in1 = sp[0]->s_vec;
d_fft.c:    t_sample *in2 = sp[1]->s_vec;
d_fft.c:    t_sample *out1 = sp[2]->s_vec;
d_fft.c:        dsp_add(sigrfft_flip, 3, out1+1, out1 + n, n2-1);
d_fft.c:        dsp_add(sigrfft_flip, 3, in2+1, out1 + n, n2-1);
d_fft.c:/* ----------------------- framp~ -------------------------------- */
d_fft.c:    inlet_new(&x->x_obj, &x->x_obj.ob_pd, &s_signal, &s_signal);
d_fft.c:    outlet_new(&x->x_obj, gensym("signal"));
d_fft.c:    outlet_new(&x->x_obj, gensym("signal"));
d_fft.c:    x->x_f = 0;
d_fft.c:    n -= 2;
d_fft.c:    while (n--)
d_fft.c:        re = currentreal - 0.5f * (lastreal + nextreal);
d_fft.c:        im = currentimag - 0.5f * (lastimag + nextimag);
d_fft.c:        if (pow > 1e-19)
d_fft.c:            t_sample detune = ((lastreal - nextreal) * re +
d_fft.c:                    (lastimag - nextimag) * im) / (2.0f * pow);
d_fft.c:            if (detune > 2 || detune < -2) freq = pow = 0;
d_fft.c:    while (m--) *outamp++ = *outfreq++ = 0;
d_fft.c:    int n = sp[0]->s_n, n2 = (n>>1);
d_fft.c:    dsp_add(sigframp_perform, 5, sp[0]->s_vec, sp[1]->s_vec,
d_fft.c:        sp[2]->s_vec, sp[3]->s_vec, n2);
d_fft.c:    dsp_add(sigsqrt_perform, 3, sp[3]->s_vec, sp[3]->s_vec, n2);
d_fft.c:/* ------------------------ global setup routine ------------------------- */
d_fft_fftsg.c:/****************** begin Pd-specific prologue ***********************/
d_fft_fftsg.c:    Copyright(C) 1996-2001 Takuya OOURA
d_fft_fftsg.c:    email: ooura@mmm.t.u-tokyo.ac.jp
d_fft_fftsg.c:    download: http://momonga.t.u-tokyo.ac.jp/~ooura/fft.html
d_fft_fftsg.c:for another, more permissive-sounding copyright notice.  -MSP
d_fft_fftsg.c:/* ---------- Pd interface to OOURA FFT; imitate Mayer API ---------- */
d_fft_fftsg.c:    mayer_dofft(fz1, fz2, n, -1);
d_fft_fftsg.c:    for (i = 1, fp1 = fz+1, fp2 = fz+(n-1), fp3 = buf+2; i < nover2;
d_fft_fftsg.c:        i++, fp1++, fp2--, fp3 += 2)
d_fft_fftsg.c:    for (i = 1, fp1 = fz+1, fp2 = fz+(n-1), fp3 = buf+2; i < nover2;
d_fft_fftsg.c:        i++, fp1++, fp2--, fp3 += 2)
d_fft_fftsg.c:    rdft(n, -1, buf, ooura_bitrev, ooura_costab);
d_fft_fftsg.c:/****************** end Pd-specific prologue ***********************/
d_fft_fftsg.c:    radix       :split-radix
d_fft_fftsg.c:    dfst: Sine Transform of RDFT (Real Anti-symmetric DFT)
d_fft_fftsg.c:-------- Complex DFT (Discrete Fourier Transform) --------
d_fft_fftsg.c:            X[k] = sum_j=0^n-1 x[j]*exp(2*pi*i*j*k/n), 0<=k<n
d_fft_fftsg.c:            X[k] = sum_j=0^n-1 x[j]*exp(-2*pi*i*j*k/n), 0<=k<n
d_fft_fftsg.c:        (notes: sum_j=0^n-1 is a summation from j=0 to n-1)
d_fft_fftsg.c:            cdft(2*n, -1, a, ip, w);
d_fft_fftsg.c:        a[0...2*n-1]   :input/output data (double *)
d_fft_fftsg.c:        w[0...n/2-1]   :cos/sin table (double *)
d_fft_fftsg.c:            cdft(2*n, -1, a, ip, w);
d_fft_fftsg.c:            for (j = 0; j <= 2 * n - 1; j++) {
d_fft_fftsg.c:-------- Real DFT / Inverse of Real DFT --------
d_fft_fftsg.c:            R[k] = sum_j=0^n-1 a[j]*cos(2*pi*j*k/n), 0<=k<=n/2
d_fft_fftsg.c:            I[k] = sum_j=0^n-1 a[j]*sin(2*pi*j*k/n), 0<k<n/2
d_fft_fftsg.c:                   sum_j=1^n/2-1 R[j]*cos(2*pi*j*k/n) + 
d_fft_fftsg.c:                   sum_j=1^n/2-1 I[j]*sin(2*pi*j*k/n), 0<=k<n
d_fft_fftsg.c:            rdft(n, -1, a, ip, w);
d_fft_fftsg.c:        a[0...n-1]     :input/output data (double *)
d_fft_fftsg.c:        w[0...n/2-1]   :cos/sin table (double *)
d_fft_fftsg.c:            rdft(n, -1, a, ip, w);
d_fft_fftsg.c:            for (j = 0; j <= n - 1; j++) {
d_fft_fftsg.c:-------- DCT (Discrete Cosine Transform) / Inverse of DCT --------
d_fft_fftsg.c:            C[k] = sum_j=0^n-1 a[j]*cos(pi*j*(k+1/2)/n), 0<=k<n
d_fft_fftsg.c:            C[k] = sum_j=0^n-1 a[j]*cos(pi*(j+1/2)*k/n), 0<=k<n
d_fft_fftsg.c:            ddct(n, -1, a, ip, w);
d_fft_fftsg.c:        a[0...n-1]     :input/output data (double *)
d_fft_fftsg.c:        w[0...n*5/4-1] :cos/sin table (double *)
d_fft_fftsg.c:            ddct(n, -1, a, ip, w);
d_fft_fftsg.c:            for (j = 0; j <= n - 1; j++) {
d_fft_fftsg.c:-------- DST (Discrete Sine Transform) / Inverse of DST --------
d_fft_fftsg.c:            S[k] = sum_j=0^n-1 a[j]*sin(pi*(j+1/2)*k/n), 0<k<=n
d_fft_fftsg.c:            ddst(n, -1, a, ip, w);
d_fft_fftsg.c:        a[0...n-1]     :input/output data (double *)
d_fft_fftsg.c:        w[0...n*5/4-1] :cos/sin table (double *)
d_fft_fftsg.c:            ddst(n, -1, a, ip, w);
d_fft_fftsg.c:            for (j = 0; j <= n - 1; j++) {
d_fft_fftsg.c:-------- Cosine Transform of RDFT (Real Symmetric DFT) --------
d_fft_fftsg.c:        n              :data length - 1 (int)
d_fft_fftsg.c:        w[0...n*5/8-1] :cos/sin table (double *)
d_fft_fftsg.c:-------- Sine Transform of RDFT (Real Anti-symmetric DFT) --------
d_fft_fftsg.c:        S[k] = sum_j=1^n-1 a[j]*sin(pi*j*k/n), 0<k<n
d_fft_fftsg.c:        a[0...n-1]     :input/output data (double *)
d_fft_fftsg.c:        t[0...n/2-1]   :work area (double *)
d_fft_fftsg.c:        w[0...n*5/8-1] :cos/sin table (double *)
d_fft_fftsg.c:            for (j = 1; j <= n - 1; j++) {
d_fft_fftsg.c:        xi = a[0] - a[1];
d_fft_fftsg.c:        a[1] = 0.5 * (a[0] - a[1]);
d_fft_fftsg.c:        a[0] -= a[1];
d_fft_fftsg.c:        xr = a[n - 1];
d_fft_fftsg.c:        for (j = n - 2; j >= 2; j -= 2) {
d_fft_fftsg.c:            a[j + 1] = a[j] - a[j - 1];
d_fft_fftsg.c:            a[j] += a[j - 1];
d_fft_fftsg.c:        a[1] = a[0] - xr;
d_fft_fftsg.c:        xr = a[0] - a[1];
d_fft_fftsg.c:            a[j - 1] = a[j] - a[j + 1];
d_fft_fftsg.c:        a[n - 1] = xr;
d_fft_fftsg.c:        xr = a[n - 1];
d_fft_fftsg.c:        for (j = n - 2; j >= 2; j -= 2) {
d_fft_fftsg.c:            a[j + 1] = -a[j] - a[j - 1];
d_fft_fftsg.c:            a[j] -= a[j - 1];
d_fft_fftsg.c:        a[0] -= xr;
d_fft_fftsg.c:        xr = a[0] - a[1];
d_fft_fftsg.c:            a[j - 1] = -a[j] - a[j + 1];
d_fft_fftsg.c:            a[j] -= a[j + 1];
d_fft_fftsg.c:        a[n - 1] = -xr;
d_fft_fftsg.c:    a[0] -= a[n];
d_fft_fftsg.c:    t[0] = xi - yi;
d_fft_fftsg.c:            k = m - j;
d_fft_fftsg.c:            xr = a[j] - a[n - j];
d_fft_fftsg.c:            xi = a[j] + a[n - j];
d_fft_fftsg.c:            yr = a[k] - a[n - k];
d_fft_fftsg.c:            yi = a[k] + a[n - k];
d_fft_fftsg.c:            t[j] = xi - yi;
d_fft_fftsg.c:        t[mh] = a[mh] + a[n - mh];
d_fft_fftsg.c:        a[mh] -= a[n - mh];
d_fft_fftsg.c:        a[n - 1] = a[0] - a[1];
d_fft_fftsg.c:        for (j = m - 2; j >= 2; j -= 2) {
d_fft_fftsg.c:            a[2 * j - 1] = a[j] - a[j + 1];
d_fft_fftsg.c:            a[n - l] = t[0] - t[1];
d_fft_fftsg.c:                a[k - l] = t[j] - t[j + 1];
d_fft_fftsg.c:                k = m - j;
d_fft_fftsg.c:                t[j] = t[m + k] - t[m + j];
d_fft_fftsg.c:        a[n] = t[2] - t[1];
d_fft_fftsg.c:            k = m - j;
d_fft_fftsg.c:            xr = a[j] + a[n - j];
d_fft_fftsg.c:            xi = a[j] - a[n - j];
d_fft_fftsg.c:            yr = a[k] + a[n - k];
d_fft_fftsg.c:            yi = a[k] - a[n - k];
d_fft_fftsg.c:            t[k] = xi - yi;
d_fft_fftsg.c:        t[0] = a[mh] - a[n - mh];
d_fft_fftsg.c:        a[mh] += a[n - mh];
d_fft_fftsg.c:        a[n - 1] = a[1] - a[0];
d_fft_fftsg.c:        for (j = m - 2; j >= 2; j -= 2) {
d_fft_fftsg.c:            a[2 * j + 1] = a[j] - a[j + 1];
d_fft_fftsg.c:            a[2 * j - 1] = -a[j] - a[j + 1];
d_fft_fftsg.c:            a[n - l] = t[1] - t[0];
d_fft_fftsg.c:                a[k - l] = -t[j] - t[j + 1];
d_fft_fftsg.c:                a[k + l] = t[j] - t[j + 1];
d_fft_fftsg.c:                k = m - j;
d_fft_fftsg.c:                t[k] = t[m + k] - t[m + j];
d_fft_fftsg.c:/* -------- initializing routines -------- */
d_fft_fftsg.c:                w[j + 3] = -sin(3 * delta * j);
d_fft_fftsg.c:            c[nc - j] = 0.5 * sin(delta * j);
d_fft_fftsg.c:/* -------- child routines -------- */
d_fft_fftsg.c:            cftf1st(n, a, &w[nw - (n >> 2)]);
d_fft_fftsg.c:            cftf161(a, &w[nw - 8]);
d_fft_fftsg.c:            cftb1st(n, a, &w[nw - (n >> 2)]);
d_fft_fftsg.c:            cftf161(a, &w[nw - 8]);
d_fft_fftsg.c:                k1 -= nm;
d_fft_fftsg.c:                j1 -= nm;
d_fft_fftsg.c:                k1 -= 2 * nm;
d_fft_fftsg.c:                j1 -= nm;
d_fft_fftsg.c:                j1 -= nm;
d_fft_fftsg.c:                k1 -= 2 * nm;
d_fft_fftsg.c:                k1 -= nm;
d_fft_fftsg.c:                j1 -= nh;
d_fft_fftsg.c:                k1 -= 2;
d_fft_fftsg.c:                j1 -= nm;
d_fft_fftsg.c:                k1 -= 2 * nm;
d_fft_fftsg.c:                j1 -= nm;
d_fft_fftsg.c:                j1 -= nm;
d_fft_fftsg.c:                k1 -= 2 * nm;
d_fft_fftsg.c:            k1 -= nm;
d_fft_fftsg.c:            j1 -= 2;
d_fft_fftsg.c:            k1 -= nh;
d_fft_fftsg.c:            j1 -= nh - nm;
d_fft_fftsg.c:            k1 += 2 * nm - 2;
d_fft_fftsg.c:                j1 -= nm;
d_fft_fftsg.c:                k1 -= nm;
d_fft_fftsg.c:                j1 -= nh;
d_fft_fftsg.c:                k1 -= 2;
d_fft_fftsg.c:                j1 -= nm;
d_fft_fftsg.c:                k1 -= nm;
d_fft_fftsg.c:                xi = -a[j1 + 1];
d_fft_fftsg.c:                yi = -a[k1 + 1];
d_fft_fftsg.c:                xi = -a[j1 + 1];
d_fft_fftsg.c:                yi = -a[k1 + 1];
d_fft_fftsg.c:                k1 -= nm;
d_fft_fftsg.c:                xi = -a[j1 + 1];
d_fft_fftsg.c:                yi = -a[k1 + 1];
d_fft_fftsg.c:                xi = -a[j1 + 1];
d_fft_fftsg.c:                yi = -a[k1 + 1];
d_fft_fftsg.c:                xi = -a[j1 + 1];
d_fft_fftsg.c:                yi = -a[k1 + 1];
d_fft_fftsg.c:                j1 -= nm;
d_fft_fftsg.c:                k1 -= 2 * nm;
d_fft_fftsg.c:                xi = -a[j1 + 1];
d_fft_fftsg.c:                yi = -a[k1 + 1];
d_fft_fftsg.c:                j1 -= nm;
d_fft_fftsg.c:                xi = -a[j1 + 1];
d_fft_fftsg.c:                yi = -a[k1 + 1];
d_fft_fftsg.c:                j1 -= nm;
d_fft_fftsg.c:                k1 -= 2 * nm;
d_fft_fftsg.c:                xi = -a[j1 + 1];
d_fft_fftsg.c:                yi = -a[k1 + 1];
d_fft_fftsg.c:                xi = -a[j1 + 1];
d_fft_fftsg.c:                yi = -a[k1 + 1];
d_fft_fftsg.c:                xi = -a[j1 + 1];
d_fft_fftsg.c:                yi = -a[k1 + 1];
d_fft_fftsg.c:                k1 -= nm;
d_fft_fftsg.c:                xi = -a[j1 + 1];
d_fft_fftsg.c:                yi = -a[k1 + 1];
d_fft_fftsg.c:                xi = -a[j1 + 1];
d_fft_fftsg.c:                yi = -a[k1 + 1];
d_fft_fftsg.c:                j1 -= nh;
d_fft_fftsg.c:                k1 -= 2;
d_fft_fftsg.c:                xi = -a[j1 + 1];
d_fft_fftsg.c:                yi = -a[k1 + 1];
d_fft_fftsg.c:                j1 -= nm;
d_fft_fftsg.c:                k1 -= 2 * nm;
d_fft_fftsg.c:                xi = -a[j1 + 1];
d_fft_fftsg.c:                yi = -a[k1 + 1];
d_fft_fftsg.c:                j1 -= nm;
d_fft_fftsg.c:                xi = -a[j1 + 1];
d_fft_fftsg.c:                yi = -a[k1 + 1];
d_fft_fftsg.c:                j1 -= nm;
d_fft_fftsg.c:                k1 -= 2 * nm;
d_fft_fftsg.c:                xi = -a[j1 + 1];
d_fft_fftsg.c:                yi = -a[k1 + 1];
d_fft_fftsg.c:            a[j1 - 1] = -a[j1 - 1];
d_fft_fftsg.c:            xi = -a[j1 + 1];
d_fft_fftsg.c:            yi = -a[k1 + 1];
d_fft_fftsg.c:            a[k1 + 3] = -a[k1 + 3];
d_fft_fftsg.c:            xi = -a[j1 + 1];
d_fft_fftsg.c:            yi = -a[k1 + 1];
d_fft_fftsg.c:            k1 -= nm;
d_fft_fftsg.c:            xi = -a[j1 + 1];
d_fft_fftsg.c:            yi = -a[k1 + 1];
d_fft_fftsg.c:            j1 -= 2;
d_fft_fftsg.c:            k1 -= nh;
d_fft_fftsg.c:            xi = -a[j1 + 1];
d_fft_fftsg.c:            yi = -a[k1 + 1];
d_fft_fftsg.c:            xi = -a[j1 + 1];
d_fft_fftsg.c:            yi = -a[k1 + 1];
d_fft_fftsg.c:            j1 -= nh - nm;
d_fft_fftsg.c:            k1 += 2 * nm - 2;
d_fft_fftsg.c:            a[j1 - 1] = -a[j1 - 1];
d_fft_fftsg.c:            xi = -a[j1 + 1];
d_fft_fftsg.c:            yi = -a[k1 + 1];
d_fft_fftsg.c:            a[k1 + 3] = -a[k1 + 3];
d_fft_fftsg.c:                xi = -a[j1 + 1];
d_fft_fftsg.c:                yi = -a[k1 + 1];
d_fft_fftsg.c:                xi = -a[j1 + 1];
d_fft_fftsg.c:                yi = -a[k1 + 1];
d_fft_fftsg.c:                xi = -a[j1 + 1];
d_fft_fftsg.c:                yi = -a[k1 + 1];
d_fft_fftsg.c:                j1 -= nm;
d_fft_fftsg.c:                k1 -= nm;
d_fft_fftsg.c:                xi = -a[j1 + 1];
d_fft_fftsg.c:                yi = -a[k1 + 1];
d_fft_fftsg.c:                xi = -a[j1 + 1];
d_fft_fftsg.c:                yi = -a[k1 + 1];
d_fft_fftsg.c:                xi = -a[j1 + 1];
d_fft_fftsg.c:                yi = -a[k1 + 1];
d_fft_fftsg.c:                j1 -= nh;
d_fft_fftsg.c:                k1 -= 2;
d_fft_fftsg.c:                xi = -a[j1 + 1];
d_fft_fftsg.c:                yi = -a[k1 + 1];
d_fft_fftsg.c:                j1 -= nm;
d_fft_fftsg.c:                k1 -= nm;
d_fft_fftsg.c:                xi = -a[j1 + 1];
d_fft_fftsg.c:                yi = -a[k1 + 1];
d_fft_fftsg.c:            a[j1 - 1] = -a[j1 - 1];
d_fft_fftsg.c:            xi = -a[j1 + 1];
d_fft_fftsg.c:            yi = -a[k1 + 1];
d_fft_fftsg.c:            a[k1 + 3] = -a[k1 + 3];
d_fft_fftsg.c:            a[j1 - 1] = -a[j1 - 1];
d_fft_fftsg.c:            xi = -a[j1 + 1];
d_fft_fftsg.c:            yi = -a[k1 + 1];
d_fft_fftsg.c:            a[k1 + 3] = -a[k1 + 3];
d_fft_fftsg.c:    x1r = a[0] - a[j2];
d_fft_fftsg.c:    x1i = a[1] - a[j2 + 1];
d_fft_fftsg.c:    x3r = a[j1] - a[j3];
d_fft_fftsg.c:    x3i = a[j1 + 1] - a[j3 + 1];
d_fft_fftsg.c:    a[j1] = x0r - x2r;
d_fft_fftsg.c:    a[j1 + 1] = x0i - x2i;
d_fft_fftsg.c:    a[j2] = x1r - x3i;
d_fft_fftsg.c:    a[j3 + 1] = x1i - x3r;
d_fft_fftsg.c:    for (j = 2; j < mh - 2; j += 4) {
d_fft_fftsg.c:        x1r = a[j] - a[j2];
d_fft_fftsg.c:        x1i = a[j + 1] - a[j2 + 1];
d_fft_fftsg.c:        y1r = a[j + 2] - a[j2 + 2];
d_fft_fftsg.c:        y1i = a[j + 3] - a[j2 + 3];
d_fft_fftsg.c:        x3r = a[j1] - a[j3];
d_fft_fftsg.c:        x3i = a[j1 + 1] - a[j3 + 1];
d_fft_fftsg.c:        y3r = a[j1 + 2] - a[j3 + 2];
d_fft_fftsg.c:        y3i = a[j1 + 3] - a[j3 + 3];
d_fft_fftsg.c:        a[j1] = x0r - x2r;
d_fft_fftsg.c:        a[j1 + 1] = x0i - x2i;
d_fft_fftsg.c:        a[j1 + 2] = y0r - y2r;
d_fft_fftsg.c:        a[j1 + 3] = y0i - y2i;
d_fft_fftsg.c:        x0r = x1r - x3i;
d_fft_fftsg.c:        a[j2] = wk1r * x0r - wk1i * x0i;
d_fft_fftsg.c:        x0r = y1r - y3i;
d_fft_fftsg.c:        a[j2 + 2] = wd1r * x0r - wd1i * x0i;
d_fft_fftsg.c:        x0i = x1i - x3r;
d_fft_fftsg.c:        a[j3 + 1] = wk3r * x0i - wk3i * x0r;
d_fft_fftsg.c:        x0i = y1i - y3r;
d_fft_fftsg.c:        a[j3 + 3] = wd3r * x0i - wd3i * x0r;
d_fft_fftsg.c:        j0 = m - j;
d_fft_fftsg.c:        x1r = a[j0] - a[j2];
d_fft_fftsg.c:        x1i = a[j0 + 1] - a[j2 + 1];
d_fft_fftsg.c:        y0r = a[j0 - 2] + a[j2 - 2];
d_fft_fftsg.c:        y0i = a[j0 - 1] + a[j2 - 1];
d_fft_fftsg.c:        y1r = a[j0 - 2] - a[j2 - 2];
d_fft_fftsg.c:        y1i = a[j0 - 1] - a[j2 - 1];
d_fft_fftsg.c:        x3r = a[j1] - a[j3];
d_fft_fftsg.c:        x3i = a[j1 + 1] - a[j3 + 1];
d_fft_fftsg.c:        y2r = a[j1 - 2] + a[j3 - 2];
d_fft_fftsg.c:        y2i = a[j1 - 1] + a[j3 - 1];
d_fft_fftsg.c:        y3r = a[j1 - 2] - a[j3 - 2];
d_fft_fftsg.c:        y3i = a[j1 - 1] - a[j3 - 1];
d_fft_fftsg.c:        a[j0 - 2] = y0r + y2r;
d_fft_fftsg.c:        a[j0 - 1] = y0i + y2i;
d_fft_fftsg.c:        a[j1] = x0r - x2r;
d_fft_fftsg.c:        a[j1 + 1] = x0i - x2i;
d_fft_fftsg.c:        a[j1 - 2] = y0r - y2r;
d_fft_fftsg.c:        a[j1 - 1] = y0i - y2i;
d_fft_fftsg.c:        x0r = x1r - x3i;
d_fft_fftsg.c:        a[j2] = wk1i * x0r - wk1r * x0i;
d_fft_fftsg.c:        x0r = y1r - y3i;
d_fft_fftsg.c:        a[j2 - 2] = wd1i * x0r - wd1r * x0i;
d_fft_fftsg.c:        a[j2 - 1] = wd1i * x0i + wd1r * x0r;
d_fft_fftsg.c:        x0i = x1i - x3r;
d_fft_fftsg.c:        a[j3 + 1] = wk3i * x0i - wk3r * x0r;
d_fft_fftsg.c:        x0i = y1i - y3r;
d_fft_fftsg.c:        a[j3 - 2] = wd3i * x0r + wd3r * x0i;
d_fft_fftsg.c:        a[j3 - 1] = wd3i * x0i - wd3r * x0r;
d_fft_fftsg.c:    wk3r = csc3 * (wd3r - wn4r);
d_fft_fftsg.c:    wk3i = csc3 * (wd3i - wn4r);
d_fft_fftsg.c:    x0r = a[j0 - 2] + a[j2 - 2];
d_fft_fftsg.c:    x0i = a[j0 - 1] + a[j2 - 1];
d_fft_fftsg.c:    x1r = a[j0 - 2] - a[j2 - 2];
d_fft_fftsg.c:    x1i = a[j0 - 1] - a[j2 - 1];
d_fft_fftsg.c:    x2r = a[j1 - 2] + a[j3 - 2];
d_fft_fftsg.c:    x2i = a[j1 - 1] + a[j3 - 1];
d_fft_fftsg.c:    x3r = a[j1 - 2] - a[j3 - 2];
d_fft_fftsg.c:    x3i = a[j1 - 1] - a[j3 - 1];
d_fft_fftsg.c:    a[j0 - 2] = x0r + x2r;
d_fft_fftsg.c:    a[j0 - 1] = x0i + x2i;
d_fft_fftsg.c:    a[j1 - 2] = x0r - x2r;
d_fft_fftsg.c:    a[j1 - 1] = x0i - x2i;
d_fft_fftsg.c:    x0r = x1r - x3i;
d_fft_fftsg.c:    a[j2 - 2] = wk1r * x0r - wk1i * x0i;
d_fft_fftsg.c:    a[j2 - 1] = wk1r * x0i + wk1i * x0r;
d_fft_fftsg.c:    x0i = x1i - x3r;
d_fft_fftsg.c:    a[j3 - 2] = wk3r * x0r + wk3i * x0i;
d_fft_fftsg.c:    a[j3 - 1] = wk3r * x0i - wk3i * x0r;
d_fft_fftsg.c:    x1r = a[j0] - a[j2];
d_fft_fftsg.c:    x1i = a[j0 + 1] - a[j2 + 1];
d_fft_fftsg.c:    x3r = a[j1] - a[j3];
d_fft_fftsg.c:    x3i = a[j1 + 1] - a[j3 + 1];
d_fft_fftsg.c:    a[j1] = x0r - x2r;
d_fft_fftsg.c:    a[j1 + 1] = x0i - x2i;
d_fft_fftsg.c:    x0r = x1r - x3i;
d_fft_fftsg.c:    a[j2] = wn4r * (x0r - x0i);
d_fft_fftsg.c:    x0i = x1i - x3r;
d_fft_fftsg.c:    a[j3] = -wn4r * (x0r + x0i);
d_fft_fftsg.c:    a[j3 + 1] = -wn4r * (x0i - x0r);
d_fft_fftsg.c:    x1r = a[j0 + 2] - a[j2 + 2];
d_fft_fftsg.c:    x1i = a[j0 + 3] - a[j2 + 3];
d_fft_fftsg.c:    x3r = a[j1 + 2] - a[j3 + 2];
d_fft_fftsg.c:    x3i = a[j1 + 3] - a[j3 + 3];
d_fft_fftsg.c:    a[j1 + 2] = x0r - x2r;
d_fft_fftsg.c:    a[j1 + 3] = x0i - x2i;
d_fft_fftsg.c:    x0r = x1r - x3i;
d_fft_fftsg.c:    a[j2 + 2] = wk1i * x0r - wk1r * x0i;
d_fft_fftsg.c:    x0i = x1i - x3r;
d_fft_fftsg.c:    a[j3 + 3] = wk3i * x0i - wk3r * x0r;
d_fft_fftsg.c:    x0i = -a[1] - a[j2 + 1];
d_fft_fftsg.c:    x1r = a[0] - a[j2];
d_fft_fftsg.c:    x1i = -a[1] + a[j2 + 1];
d_fft_fftsg.c:    x3r = a[j1] - a[j3];
d_fft_fftsg.c:    x3i = a[j1 + 1] - a[j3 + 1];
d_fft_fftsg.c:    a[1] = x0i - x2i;
d_fft_fftsg.c:    a[j1] = x0r - x2r;
d_fft_fftsg.c:    a[j3] = x1r - x3i;
d_fft_fftsg.c:    a[j3 + 1] = x1i - x3r;
d_fft_fftsg.c:    for (j = 2; j < mh - 2; j += 4) {
d_fft_fftsg.c:        x0i = -a[j + 1] - a[j2 + 1];
d_fft_fftsg.c:        x1r = a[j] - a[j2];
d_fft_fftsg.c:        x1i = -a[j + 1] + a[j2 + 1];
d_fft_fftsg.c:        y0i = -a[j + 3] - a[j2 + 3];
d_fft_fftsg.c:        y1r = a[j + 2] - a[j2 + 2];
d_fft_fftsg.c:        y1i = -a[j + 3] + a[j2 + 3];
d_fft_fftsg.c:        x3r = a[j1] - a[j3];
d_fft_fftsg.c:        x3i = a[j1 + 1] - a[j3 + 1];
d_fft_fftsg.c:        y3r = a[j1 + 2] - a[j3 + 2];
d_fft_fftsg.c:        y3i = a[j1 + 3] - a[j3 + 3];
d_fft_fftsg.c:        a[j + 1] = x0i - x2i;
d_fft_fftsg.c:        a[j + 3] = y0i - y2i;
d_fft_fftsg.c:        a[j1] = x0r - x2r;
d_fft_fftsg.c:        a[j1 + 2] = y0r - y2r;
d_fft_fftsg.c:        a[j2] = wk1r * x0r - wk1i * x0i;
d_fft_fftsg.c:        a[j2 + 2] = wd1r * x0r - wd1i * x0i;
d_fft_fftsg.c:        x0r = x1r - x3i;
d_fft_fftsg.c:        x0i = x1i - x3r;
d_fft_fftsg.c:        a[j3 + 1] = wk3r * x0i - wk3i * x0r;
d_fft_fftsg.c:        x0r = y1r - y3i;
d_fft_fftsg.c:        x0i = y1i - y3r;
d_fft_fftsg.c:        a[j3 + 3] = wd3r * x0i - wd3i * x0r;
d_fft_fftsg.c:        j0 = m - j;
d_fft_fftsg.c:        x0i = -a[j0 + 1] - a[j2 + 1];
d_fft_fftsg.c:        x1r = a[j0] - a[j2];
d_fft_fftsg.c:        x1i = -a[j0 + 1] + a[j2 + 1];
d_fft_fftsg.c:        y0r = a[j0 - 2] + a[j2 - 2];
d_fft_fftsg.c:        y0i = -a[j0 - 1] - a[j2 - 1];
d_fft_fftsg.c:        y1r = a[j0 - 2] - a[j2 - 2];
d_fft_fftsg.c:        y1i = -a[j0 - 1] + a[j2 - 1];
d_fft_fftsg.c:        x3r = a[j1] - a[j3];
d_fft_fftsg.c:        x3i = a[j1 + 1] - a[j3 + 1];
d_fft_fftsg.c:        y2r = a[j1 - 2] + a[j3 - 2];
d_fft_fftsg.c:        y2i = a[j1 - 1] + a[j3 - 1];
d_fft_fftsg.c:        y3r = a[j1 - 2] - a[j3 - 2];
d_fft_fftsg.c:        y3i = a[j1 - 1] - a[j3 - 1];
d_fft_fftsg.c:        a[j0 + 1] = x0i - x2i;
d_fft_fftsg.c:        a[j0 - 2] = y0r + y2r;
d_fft_fftsg.c:        a[j0 - 1] = y0i - y2i;
d_fft_fftsg.c:        a[j1] = x0r - x2r;
d_fft_fftsg.c:        a[j1 - 2] = y0r - y2r;
d_fft_fftsg.c:        a[j1 - 1] = y0i + y2i;
d_fft_fftsg.c:        a[j2] = wk1i * x0r - wk1r * x0i;
d_fft_fftsg.c:        a[j2 - 2] = wd1i * x0r - wd1r * x0i;
d_fft_fftsg.c:        a[j2 - 1] = wd1i * x0i + wd1r * x0r;
d_fft_fftsg.c:        x0r = x1r - x3i;
d_fft_fftsg.c:        x0i = x1i - x3r;
d_fft_fftsg.c:        a[j3 + 1] = wk3i * x0i - wk3r * x0r;
d_fft_fftsg.c:        x0r = y1r - y3i;
d_fft_fftsg.c:        x0i = y1i - y3r;
d_fft_fftsg.c:        a[j3 - 2] = wd3i * x0r + wd3r * x0i;
d_fft_fftsg.c:        a[j3 - 1] = wd3i * x0i - wd3r * x0r;
d_fft_fftsg.c:    wk3r = csc3 * (wd3r - wn4r);
d_fft_fftsg.c:    wk3i = csc3 * (wd3i - wn4r);
d_fft_fftsg.c:    x0r = a[j0 - 2] + a[j2 - 2];
d_fft_fftsg.c:    x0i = -a[j0 - 1] - a[j2 - 1];
d_fft_fftsg.c:    x1r = a[j0 - 2] - a[j2 - 2];
d_fft_fftsg.c:    x1i = -a[j0 - 1] + a[j2 - 1];
d_fft_fftsg.c:    x2r = a[j1 - 2] + a[j3 - 2];
d_fft_fftsg.c:    x2i = a[j1 - 1] + a[j3 - 1];
d_fft_fftsg.c:    x3r = a[j1 - 2] - a[j3 - 2];
d_fft_fftsg.c:    x3i = a[j1 - 1] - a[j3 - 1];
d_fft_fftsg.c:    a[j0 - 2] = x0r + x2r;
d_fft_fftsg.c:    a[j0 - 1] = x0i - x2i;
d_fft_fftsg.c:    a[j1 - 2] = x0r - x2r;
d_fft_fftsg.c:    a[j1 - 1] = x0i + x2i;
d_fft_fftsg.c:    a[j2 - 2] = wk1r * x0r - wk1i * x0i;
d_fft_fftsg.c:    a[j2 - 1] = wk1r * x0i + wk1i * x0r;
d_fft_fftsg.c:    x0r = x1r - x3i;
d_fft_fftsg.c:    x0i = x1i - x3r;
d_fft_fftsg.c:    a[j3 - 2] = wk3r * x0r + wk3i * x0i;
d_fft_fftsg.c:    a[j3 - 1] = wk3r * x0i - wk3i * x0r;
d_fft_fftsg.c:    x0i = -a[j0 + 1] - a[j2 + 1];
d_fft_fftsg.c:    x1r = a[j0] - a[j2];
d_fft_fftsg.c:    x1i = -a[j0 + 1] + a[j2 + 1];
d_fft_fftsg.c:    x3r = a[j1] - a[j3];
d_fft_fftsg.c:    x3i = a[j1 + 1] - a[j3 + 1];
d_fft_fftsg.c:    a[j0 + 1] = x0i - x2i;
d_fft_fftsg.c:    a[j1] = x0r - x2r;
d_fft_fftsg.c:    a[j2] = wn4r * (x0r - x0i);
d_fft_fftsg.c:    x0r = x1r - x3i;
d_fft_fftsg.c:    x0i = x1i - x3r;
d_fft_fftsg.c:    a[j3] = -wn4r * (x0r + x0i);
d_fft_fftsg.c:    a[j3 + 1] = -wn4r * (x0i - x0r);
d_fft_fftsg.c:    x0i = -a[j0 + 3] - a[j2 + 3];
d_fft_fftsg.c:    x1r = a[j0 + 2] - a[j2 + 2];
d_fft_fftsg.c:    x1i = -a[j0 + 3] + a[j2 + 3];
d_fft_fftsg.c:    x3r = a[j1 + 2] - a[j3 + 2];
d_fft_fftsg.c:    x3i = a[j1 + 3] - a[j3 + 3];
d_fft_fftsg.c:    a[j0 + 3] = x0i - x2i;
d_fft_fftsg.c:    a[j1 + 2] = x0r - x2r;
d_fft_fftsg.c:    a[j2 + 2] = wk1i * x0r - wk1r * x0i;
d_fft_fftsg.c:    x0r = x1r - x3i;
d_fft_fftsg.c:    x0i = x1i - x3r;
d_fft_fftsg.c:    a[j3 + 3] = wk3i * x0i - wk3r * x0r;
d_fft_fftsg.c:    n0 = ((cdft_arg_t *) p)->n0;
d_fft_fftsg.c:    n = ((cdft_arg_t *) p)->n;
d_fft_fftsg.c:    a = ((cdft_arg_t *) p)->a;
d_fft_fftsg.c:    nw = ((cdft_arg_t *) p)->nw;
d_fft_fftsg.c:    w = ((cdft_arg_t *) p)->w;
d_fft_fftsg.c:        cftmdl1(m, &a[n - m], &w[nw - (m >> 1)]);
d_fft_fftsg.c:    cftleaf(m, 1, &a[n - m], nw, w);
d_fft_fftsg.c:    for (j = n - m; j > 0; j -= m) {
d_fft_fftsg.c:        cftleaf(m, isplt, &a[j - m], nw, w);
d_fft_fftsg.c:    n0 = ((cdft_arg_t *) p)->n0;
d_fft_fftsg.c:    n = ((cdft_arg_t *) p)->n;
d_fft_fftsg.c:    a = ((cdft_arg_t *) p)->a;
d_fft_fftsg.c:    nw = ((cdft_arg_t *) p)->nw;
d_fft_fftsg.c:    w = ((cdft_arg_t *) p)->w;
d_fft_fftsg.c:        cftmdl2(m, &a[n - m], &w[nw - m]);
d_fft_fftsg.c:    cftleaf(m, 0, &a[n - m], nw, w);
d_fft_fftsg.c:    for (j = n - m; j > 0; j -= m) {
d_fft_fftsg.c:        cftleaf(m, isplt, &a[j - m], nw, w);
d_fft_fftsg.c:        cftmdl1(m, &a[n - m], &w[nw - (m >> 1)]);
d_fft_fftsg.c:    cftleaf(m, 1, &a[n - m], nw, w);
d_fft_fftsg.c:    for (j = n - m; j > 0; j -= m) {
d_fft_fftsg.c:        cftleaf(m, isplt, &a[j - m], nw, w);
d_fft_fftsg.c:            cftmdl1(n, &a[j - n], &w[nw - (n >> 1)]);
d_fft_fftsg.c:            cftmdl2(n, &a[j - n], &w[nw - n]);
d_fft_fftsg.c:                cftmdl1(m, &a[j - m], &w[nw - (m >> 1)]);
d_fft_fftsg.c:                cftmdl2(m, &a[j - m], &w[nw - m]);
d_fft_fftsg.c:        cftmdl1(128, a, &w[nw - 64]);
d_fft_fftsg.c:        cftf161(a, &w[nw - 8]);
d_fft_fftsg.c:        cftf162(&a[32], &w[nw - 32]);
d_fft_fftsg.c:        cftf161(&a[64], &w[nw - 8]);
d_fft_fftsg.c:        cftf161(&a[96], &w[nw - 8]);
d_fft_fftsg.c:        cftmdl2(128, &a[128], &w[nw - 128]);
d_fft_fftsg.c:        cftf161(&a[128], &w[nw - 8]);
d_fft_fftsg.c:        cftf162(&a[160], &w[nw - 32]);
d_fft_fftsg.c:        cftf161(&a[192], &w[nw - 8]);
d_fft_fftsg.c:        cftf162(&a[224], &w[nw - 32]);
d_fft_fftsg.c:        cftmdl1(128, &a[256], &w[nw - 64]);
d_fft_fftsg.c:        cftf161(&a[256], &w[nw - 8]);
d_fft_fftsg.c:        cftf162(&a[288], &w[nw - 32]);
d_fft_fftsg.c:        cftf161(&a[320], &w[nw - 8]);
d_fft_fftsg.c:        cftf161(&a[352], &w[nw - 8]);
d_fft_fftsg.c:            cftmdl1(128, &a[384], &w[nw - 64]);
d_fft_fftsg.c:            cftf161(&a[480], &w[nw - 8]);
d_fft_fftsg.c:            cftmdl2(128, &a[384], &w[nw - 128]);
d_fft_fftsg.c:            cftf162(&a[480], &w[nw - 32]);
d_fft_fftsg.c:        cftf161(&a[384], &w[nw - 8]);
d_fft_fftsg.c:        cftf162(&a[416], &w[nw - 32]);
d_fft_fftsg.c:        cftf161(&a[448], &w[nw - 8]);
d_fft_fftsg.c:        cftmdl1(64, a, &w[nw - 32]);
d_fft_fftsg.c:        cftf081(a, &w[nw - 8]);
d_fft_fftsg.c:        cftf082(&a[16], &w[nw - 8]);
d_fft_fftsg.c:        cftf081(&a[32], &w[nw - 8]);
d_fft_fftsg.c:        cftf081(&a[48], &w[nw - 8]);
d_fft_fftsg.c:        cftmdl2(64, &a[64], &w[nw - 64]);
d_fft_fftsg.c:        cftf081(&a[64], &w[nw - 8]);
d_fft_fftsg.c:        cftf082(&a[80], &w[nw - 8]);
d_fft_fftsg.c:        cftf081(&a[96], &w[nw - 8]);
d_fft_fftsg.c:        cftf082(&a[112], &w[nw - 8]);
d_fft_fftsg.c:        cftmdl1(64, &a[128], &w[nw - 32]);
d_fft_fftsg.c:        cftf081(&a[128], &w[nw - 8]);
d_fft_fftsg.c:        cftf082(&a[144], &w[nw - 8]);
d_fft_fftsg.c:        cftf081(&a[160], &w[nw - 8]);
d_fft_fftsg.c:        cftf081(&a[176], &w[nw - 8]);
d_fft_fftsg.c:            cftmdl1(64, &a[192], &w[nw - 32]);
d_fft_fftsg.c:            cftf081(&a[240], &w[nw - 8]);
d_fft_fftsg.c:            cftmdl2(64, &a[192], &w[nw - 64]);
d_fft_fftsg.c:            cftf082(&a[240], &w[nw - 8]);
d_fft_fftsg.c:        cftf081(&a[192], &w[nw - 8]);
d_fft_fftsg.c:        cftf082(&a[208], &w[nw - 8]);
d_fft_fftsg.c:        cftf081(&a[224], &w[nw - 8]);
d_fft_fftsg.c:    x1r = a[0] - a[j2];
d_fft_fftsg.c:    x1i = a[1] - a[j2 + 1];
d_fft_fftsg.c:    x3r = a[j1] - a[j3];
d_fft_fftsg.c:    x3i = a[j1 + 1] - a[j3 + 1];
d_fft_fftsg.c:    a[j1] = x0r - x2r;
d_fft_fftsg.c:    a[j1 + 1] = x0i - x2i;
d_fft_fftsg.c:    a[j2] = x1r - x3i;
d_fft_fftsg.c:    a[j3 + 1] = x1i - x3r;
d_fft_fftsg.c:        x1r = a[j] - a[j2];
d_fft_fftsg.c:        x1i = a[j + 1] - a[j2 + 1];
d_fft_fftsg.c:        x3r = a[j1] - a[j3];
d_fft_fftsg.c:        x3i = a[j1 + 1] - a[j3 + 1];
d_fft_fftsg.c:        a[j1] = x0r - x2r;
d_fft_fftsg.c:        a[j1 + 1] = x0i - x2i;
d_fft_fftsg.c:        x0r = x1r - x3i;
d_fft_fftsg.c:        a[j2] = wk1r * x0r - wk1i * x0i;
d_fft_fftsg.c:        x0i = x1i - x3r;
d_fft_fftsg.c:        a[j3 + 1] = wk3r * x0i - wk3i * x0r;
d_fft_fftsg.c:        j0 = m - j;
d_fft_fftsg.c:        x1r = a[j0] - a[j2];
d_fft_fftsg.c:        x1i = a[j0 + 1] - a[j2 + 1];
d_fft_fftsg.c:        x3r = a[j1] - a[j3];
d_fft_fftsg.c:        x3i = a[j1 + 1] - a[j3 + 1];
d_fft_fftsg.c:        a[j1] = x0r - x2r;
d_fft_fftsg.c:        a[j1 + 1] = x0i - x2i;
d_fft_fftsg.c:        x0r = x1r - x3i;
d_fft_fftsg.c:        a[j2] = wk1i * x0r - wk1r * x0i;
d_fft_fftsg.c:        x0i = x1i - x3r;
d_fft_fftsg.c:        a[j3 + 1] = wk3i * x0i - wk3r * x0r;
d_fft_fftsg.c:    x1r = a[j0] - a[j2];
d_fft_fftsg.c:    x1i = a[j0 + 1] - a[j2 + 1];
d_fft_fftsg.c:    x3r = a[j1] - a[j3];
d_fft_fftsg.c:    x3i = a[j1 + 1] - a[j3 + 1];
d_fft_fftsg.c:    a[j1] = x0r - x2r;
d_fft_fftsg.c:    a[j1 + 1] = x0i - x2i;
d_fft_fftsg.c:    x0r = x1r - x3i;
d_fft_fftsg.c:    a[j2] = wn4r * (x0r - x0i);
d_fft_fftsg.c:    x0i = x1i - x3r;
d_fft_fftsg.c:    a[j3] = -wn4r * (x0r + x0i);
d_fft_fftsg.c:    a[j3 + 1] = -wn4r * (x0i - x0r);
d_fft_fftsg.c:    x0r = a[0] - a[j2 + 1];
d_fft_fftsg.c:    x1i = a[1] - a[j2];
d_fft_fftsg.c:    x2r = a[j1] - a[j3 + 1];
d_fft_fftsg.c:    x3i = a[j1 + 1] - a[j3];
d_fft_fftsg.c:    y0r = wn4r * (x2r - x2i);
d_fft_fftsg.c:    a[j1] = x0r - y0r;
d_fft_fftsg.c:    a[j1 + 1] = x0i - y0i;
d_fft_fftsg.c:    y0r = wn4r * (x3r - x3i);
d_fft_fftsg.c:    a[j2] = x1r - y0i;
d_fft_fftsg.c:    a[j3 + 1] = x1i - y0r;
d_fft_fftsg.c:        kr -= 4;
d_fft_fftsg.c:        x0r = a[j] - a[j2 + 1];
d_fft_fftsg.c:        x1i = a[j + 1] - a[j2];
d_fft_fftsg.c:        x2r = a[j1] - a[j3 + 1];
d_fft_fftsg.c:        x3i = a[j1 + 1] - a[j3];
d_fft_fftsg.c:        y0r = wk1r * x0r - wk1i * x0i;
d_fft_fftsg.c:        y2r = wd1r * x2r - wd1i * x2i;
d_fft_fftsg.c:        a[j1] = y0r - y2r;
d_fft_fftsg.c:        a[j1 + 1] = y0i - y2i;
d_fft_fftsg.c:        y0i = wk3r * x1i - wk3i * x1r;
d_fft_fftsg.c:        y2i = wd3r * x3i - wd3i * x3r;
d_fft_fftsg.c:        a[j3] = y0r - y2r;
d_fft_fftsg.c:        a[j3 + 1] = y0i - y2i;
d_fft_fftsg.c:        j0 = m - j;
d_fft_fftsg.c:        x0r = a[j0] - a[j2 + 1];
d_fft_fftsg.c:        x1i = a[j0 + 1] - a[j2];
d_fft_fftsg.c:        x2r = a[j1] - a[j3 + 1];
d_fft_fftsg.c:        x3i = a[j1 + 1] - a[j3];
d_fft_fftsg.c:        y0r = wd1i * x0r - wd1r * x0i;
d_fft_fftsg.c:        y2r = wk1i * x2r - wk1r * x2i;
d_fft_fftsg.c:        a[j1] = y0r - y2r;
d_fft_fftsg.c:        a[j1 + 1] = y0i - y2i;
d_fft_fftsg.c:        y0i = wd3i * x1i - wd3r * x1r;
d_fft_fftsg.c:        y2i = wk3i * x3i - wk3r * x3r;
d_fft_fftsg.c:        a[j3] = y0r - y2r;
d_fft_fftsg.c:        a[j3 + 1] = y0i - y2i;
d_fft_fftsg.c:    x0r = a[j0] - a[j2 + 1];
d_fft_fftsg.c:    x1i = a[j0 + 1] - a[j2];
d_fft_fftsg.c:    x2r = a[j1] - a[j3 + 1];
d_fft_fftsg.c:    x3i = a[j1 + 1] - a[j3];
d_fft_fftsg.c:    y0r = wk1r * x0r - wk1i * x0i;
d_fft_fftsg.c:    y2r = wk1i * x2r - wk1r * x2i;
d_fft_fftsg.c:    a[j1] = y0r - y2r;
d_fft_fftsg.c:    a[j1 + 1] = y0i - y2i;
d_fft_fftsg.c:    y0r = wk1i * x1r - wk1r * x1i;
d_fft_fftsg.c:    y2r = wk1r * x3r - wk1i * x3i;
d_fft_fftsg.c:    a[j2] = y0r - y2r;
d_fft_fftsg.c:    a[j2 + 1] = y0i - y2i;
d_fft_fftsg.c:        cftf161(a, &w[nw - 8]);
d_fft_fftsg.c:        cftf162(&a[32], &w[nw - 32]);
d_fft_fftsg.c:        cftf161(&a[64], &w[nw - 8]);
d_fft_fftsg.c:        cftf161(&a[96], &w[nw - 8]);
d_fft_fftsg.c:        cftf081(a, &w[nw - 8]);
d_fft_fftsg.c:        cftf082(&a[16], &w[nw - 8]);
d_fft_fftsg.c:        cftf081(&a[32], &w[nw - 8]);
d_fft_fftsg.c:        cftf081(&a[48], &w[nw - 8]);
d_fft_fftsg.c:    x1r = a[0] - a[16];
d_fft_fftsg.c:    x1i = a[1] - a[17];
d_fft_fftsg.c:    x3r = a[8] - a[24];
d_fft_fftsg.c:    x3i = a[9] - a[25];
d_fft_fftsg.c:    y4r = x0r - x2r;
d_fft_fftsg.c:    y4i = x0i - x2i;
d_fft_fftsg.c:    y8r = x1r - x3i;
d_fft_fftsg.c:    y12i = x1i - x3r;
d_fft_fftsg.c:    x1r = a[2] - a[18];
d_fft_fftsg.c:    x1i = a[3] - a[19];
d_fft_fftsg.c:    x3r = a[10] - a[26];
d_fft_fftsg.c:    x3i = a[11] - a[27];
d_fft_fftsg.c:    y5r = x0r - x2r;
d_fft_fftsg.c:    y5i = x0i - x2i;
d_fft_fftsg.c:    x0r = x1r - x3i;
d_fft_fftsg.c:    y9r = wk1r * x0r - wk1i * x0i;
d_fft_fftsg.c:    x0i = x1i - x3r;
d_fft_fftsg.c:    y13r = wk1i * x0r - wk1r * x0i;
d_fft_fftsg.c:    x1r = a[4] - a[20];
d_fft_fftsg.c:    x1i = a[5] - a[21];
d_fft_fftsg.c:    x3r = a[12] - a[28];
d_fft_fftsg.c:    x3i = a[13] - a[29];
d_fft_fftsg.c:    y6r = x0r - x2r;
d_fft_fftsg.c:    y6i = x0i - x2i;
d_fft_fftsg.c:    x0r = x1r - x3i;
d_fft_fftsg.c:    y10r = wn4r * (x0r - x0i);
d_fft_fftsg.c:    x0i = x1i - x3r;
d_fft_fftsg.c:    y14i = wn4r * (x0i - x0r);
d_fft_fftsg.c:    x1r = a[6] - a[22];
d_fft_fftsg.c:    x1i = a[7] - a[23];
d_fft_fftsg.c:    x3r = a[14] - a[30];
d_fft_fftsg.c:    x3i = a[15] - a[31];
d_fft_fftsg.c:    y7r = x0r - x2r;
d_fft_fftsg.c:    y7i = x0i - x2i;
d_fft_fftsg.c:    x0r = x1r - x3i;
d_fft_fftsg.c:    y11r = wk1i * x0r - wk1r * x0i;
d_fft_fftsg.c:    x0i = x1i - x3r;
d_fft_fftsg.c:    y15r = wk1r * x0r - wk1i * x0i;
d_fft_fftsg.c:    x0r = y12r - y14r;
d_fft_fftsg.c:    x0i = y12i - y14i;
d_fft_fftsg.c:    x2r = y13r - y15r;
d_fft_fftsg.c:    x2i = y13i - y15i;
d_fft_fftsg.c:    a[26] = x0r - x2r;
d_fft_fftsg.c:    a[27] = x0i - x2i;
d_fft_fftsg.c:    a[28] = x1r - x3i;
d_fft_fftsg.c:    a[31] = x1i - x3r;
d_fft_fftsg.c:    x1r = y8r - y10r;
d_fft_fftsg.c:    x1i = y8i - y10i;
d_fft_fftsg.c:    x3r = y9r - y11r;
d_fft_fftsg.c:    x3i = y9i - y11i;
d_fft_fftsg.c:    a[18] = x0r - x2r;
d_fft_fftsg.c:    a[19] = x0i - x2i;
d_fft_fftsg.c:    a[20] = x1r - x3i;
d_fft_fftsg.c:    a[23] = x1i - x3r;
d_fft_fftsg.c:    x0r = y5r - y7i;
d_fft_fftsg.c:    x2r = wn4r * (x0r - x0i);
d_fft_fftsg.c:    x0i = y5i - y7r;
d_fft_fftsg.c:    x3r = wn4r * (x0r - x0i);
d_fft_fftsg.c:    x0r = y4r - y6i;
d_fft_fftsg.c:    x1i = y4i - y6r;
d_fft_fftsg.c:    a[10] = x0r - x2r;
d_fft_fftsg.c:    a[11] = x0i - x2i;
d_fft_fftsg.c:    a[12] = x1r - x3i;
d_fft_fftsg.c:    a[15] = x1i - x3r;
d_fft_fftsg.c:    x1r = y0r - y2r;
d_fft_fftsg.c:    x1i = y0i - y2i;
d_fft_fftsg.c:    x3r = y1r - y3r;
d_fft_fftsg.c:    x3i = y1i - y3i;
d_fft_fftsg.c:    a[2] = x0r - x2r;
d_fft_fftsg.c:    a[3] = x0i - x2i;
d_fft_fftsg.c:    a[4] = x1r - x3i;
d_fft_fftsg.c:    a[7] = x1i - x3r;
d_fft_fftsg.c:    wk3i = -w[7];
d_fft_fftsg.c:    x1r = a[0] - a[17];
d_fft_fftsg.c:    x0r = a[8] - a[25];
d_fft_fftsg.c:    x2r = wn4r * (x0r - x0i);
d_fft_fftsg.c:    y4r = x1r - x2r;
d_fft_fftsg.c:    y4i = x1i - x2i;
d_fft_fftsg.c:    x1i = a[1] - a[16];
d_fft_fftsg.c:    x0i = a[9] - a[24];
d_fft_fftsg.c:    x2r = wn4r * (x0r - x0i);
d_fft_fftsg.c:    y8r = x1r - x2i;
d_fft_fftsg.c:    y12i = x1i - x2r;
d_fft_fftsg.c:    x0r = a[2] - a[19];
d_fft_fftsg.c:    x1r = wk1r * x0r - wk1i * x0i;
d_fft_fftsg.c:    x0r = a[10] - a[27];
d_fft_fftsg.c:    x2r = wk3i * x0r - wk3r * x0i;
d_fft_fftsg.c:    y5r = x1r - x2r;
d_fft_fftsg.c:    y5i = x1i - x2i;
d_fft_fftsg.c:    x0i = a[3] - a[18];
d_fft_fftsg.c:    x1r = wk3r * x0r - wk3i * x0i;
d_fft_fftsg.c:    x0i = a[11] - a[26];
d_fft_fftsg.c:    x2i = wk1r * x0i - wk1i * x0r;
d_fft_fftsg.c:    y9r = x1r - x2r;
d_fft_fftsg.c:    y9i = x1i - x2i;
d_fft_fftsg.c:    x0r = a[4] - a[21];
d_fft_fftsg.c:    x1r = wk2r * x0r - wk2i * x0i;
d_fft_fftsg.c:    x0r = a[12] - a[29];
d_fft_fftsg.c:    x2r = wk2i * x0r - wk2r * x0i;
d_fft_fftsg.c:    y6r = x1r - x2r;
d_fft_fftsg.c:    y6i = x1i - x2i;
d_fft_fftsg.c:    x0i = a[5] - a[20];
d_fft_fftsg.c:    x1r = wk2i * x0r - wk2r * x0i;
d_fft_fftsg.c:    x0i = a[13] - a[28];
d_fft_fftsg.c:    x2r = wk2r * x0r - wk2i * x0i;
d_fft_fftsg.c:    y10r = x1r - x2r;
d_fft_fftsg.c:    y10i = x1i - x2i;
d_fft_fftsg.c:    x0r = a[6] - a[23];
d_fft_fftsg.c:    x1r = wk3r * x0r - wk3i * x0i;
d_fft_fftsg.c:    x0r = a[14] - a[31];
d_fft_fftsg.c:    x2r = wk1i * x0r - wk1r * x0i;
d_fft_fftsg.c:    y7r = x1r - x2r;
d_fft_fftsg.c:    y7i = x1i - x2i;
d_fft_fftsg.c:    x0i = a[7] - a[22];
d_fft_fftsg.c:    x1i = wk1i * x0i - wk1r * x0r;
d_fft_fftsg.c:    x0i = a[15] - a[30];
d_fft_fftsg.c:    x2r = wk3i * x0r - wk3r * x0i;
d_fft_fftsg.c:    y15r = x1r - x2r;
d_fft_fftsg.c:    y15i = x1i - x2i;
d_fft_fftsg.c:    a[2] = x1r - x2r;
d_fft_fftsg.c:    a[3] = x1i - x2i;
d_fft_fftsg.c:    x1r = y0r - y2r;
d_fft_fftsg.c:    x1i = y0i - y2i;
d_fft_fftsg.c:    x2r = y1r - y3r;
d_fft_fftsg.c:    x2i = y1i - y3i;
d_fft_fftsg.c:    a[4] = x1r - x2i;
d_fft_fftsg.c:    a[7] = x1i - x2r;
d_fft_fftsg.c:    x1r = y4r - y6i;
d_fft_fftsg.c:    x0r = y5r - y7i;
d_fft_fftsg.c:    x2r = wn4r * (x0r - x0i);
d_fft_fftsg.c:    a[10] = x1r - x2r;
d_fft_fftsg.c:    a[11] = x1i - x2i;
d_fft_fftsg.c:    x1i = y4i - y6r;
d_fft_fftsg.c:    x0i = y5i - y7r;
d_fft_fftsg.c:    x2r = wn4r * (x0r - x0i);
d_fft_fftsg.c:    a[12] = x1r - x2i;
d_fft_fftsg.c:    a[15] = x1i - x2r;
d_fft_fftsg.c:    x2r = y9r - y11r;
d_fft_fftsg.c:    x2i = y9i - y11i;
d_fft_fftsg.c:    a[18] = x1r - x2r;
d_fft_fftsg.c:    a[19] = x1i - x2i;
d_fft_fftsg.c:    x1r = y8r - y10r;
d_fft_fftsg.c:    x1i = y8i - y10i;
d_fft_fftsg.c:    a[20] = x1r - x2i;
d_fft_fftsg.c:    a[23] = x1i - x2r;
d_fft_fftsg.c:    x1r = y12r - y14i;
d_fft_fftsg.c:    x0i = y13i - y15r;
d_fft_fftsg.c:    x2r = wn4r * (x0r - x0i);
d_fft_fftsg.c:    a[26] = x1r - x2r;
d_fft_fftsg.c:    a[27] = x1i - x2i;
d_fft_fftsg.c:    x1i = y12i - y14r;
d_fft_fftsg.c:    x0r = y13r - y15i;
d_fft_fftsg.c:    x2r = wn4r * (x0r - x0i);
d_fft_fftsg.c:    a[28] = x1r - x2i;
d_fft_fftsg.c:    a[31] = x1i - x2r;
d_fft_fftsg.c:    x1r = a[0] - a[8];
d_fft_fftsg.c:    x1i = a[1] - a[9];
d_fft_fftsg.c:    x3r = a[4] - a[12];
d_fft_fftsg.c:    x3i = a[5] - a[13];
d_fft_fftsg.c:    y2r = x0r - x2r;
d_fft_fftsg.c:    y2i = x0i - x2i;
d_fft_fftsg.c:    y1r = x1r - x3i;
d_fft_fftsg.c:    y3i = x1i - x3r;
d_fft_fftsg.c:    x1r = a[2] - a[10];
d_fft_fftsg.c:    x1i = a[3] - a[11];
d_fft_fftsg.c:    x3r = a[6] - a[14];
d_fft_fftsg.c:    x3i = a[7] - a[15];
d_fft_fftsg.c:    y6r = x0r - x2r;
d_fft_fftsg.c:    y6i = x0i - x2i;
d_fft_fftsg.c:    x0r = x1r - x3i;
d_fft_fftsg.c:    x2i = x1i - x3r;
d_fft_fftsg.c:    y5r = wn4r * (x0r - x0i);
d_fft_fftsg.c:    y7r = wn4r * (x2r - x2i);
d_fft_fftsg.c:    a[10] = y1r - y5r;
d_fft_fftsg.c:    a[11] = y1i - y5i;
d_fft_fftsg.c:    a[12] = y3r - y7i;
d_fft_fftsg.c:    a[15] = y3i - y7r;
d_fft_fftsg.c:    a[2] = y0r - y4r;
d_fft_fftsg.c:    a[3] = y0i - y4i;
d_fft_fftsg.c:    a[4] = y2r - y6i;
d_fft_fftsg.c:    a[7] = y2i - y6r;
d_fft_fftsg.c:    y0r = a[0] - a[9];
d_fft_fftsg.c:    y1i = a[1] - a[8];
d_fft_fftsg.c:    x0r = a[4] - a[13];
d_fft_fftsg.c:    y2r = wn4r * (x0r - x0i);
d_fft_fftsg.c:    x0i = a[5] - a[12];
d_fft_fftsg.c:    y3r = wn4r * (x0r - x0i);
d_fft_fftsg.c:    x0r = a[2] - a[11];
d_fft_fftsg.c:    y4r = wk1r * x0r - wk1i * x0i;
d_fft_fftsg.c:    x0i = a[3] - a[10];
d_fft_fftsg.c:    y5r = wk1i * x0r - wk1r * x0i;
d_fft_fftsg.c:    x0r = a[6] - a[15];
d_fft_fftsg.c:    y6r = wk1i * x0r - wk1r * x0i;
d_fft_fftsg.c:    x0i = a[7] - a[14];
d_fft_fftsg.c:    y7r = wk1r * x0r - wk1i * x0i;
d_fft_fftsg.c:    a[2] = x0r - x1r;
d_fft_fftsg.c:    a[3] = x0i - x1i;
d_fft_fftsg.c:    x0r = y0r - y2r;
d_fft_fftsg.c:    x0i = y0i - y2i;
d_fft_fftsg.c:    x1r = y4r - y6r;
d_fft_fftsg.c:    x1i = y4i - y6i;
d_fft_fftsg.c:    a[4] = x0r - x1i;
d_fft_fftsg.c:    a[7] = x0i - x1r;
d_fft_fftsg.c:    x0r = y1r - y3i;
d_fft_fftsg.c:    x1r = y5r - y7r;
d_fft_fftsg.c:    x1i = y5i - y7i;
d_fft_fftsg.c:    a[10] = x0r - x1r;
d_fft_fftsg.c:    a[11] = x0i - x1i;
d_fft_fftsg.c:    x0i = y1i - y3r;
d_fft_fftsg.c:    a[12] = x0r - x1i;
d_fft_fftsg.c:    a[15] = x0i - x1r;
d_fft_fftsg.c:    x1r = a[0] - a[4];
d_fft_fftsg.c:    x1i = a[1] - a[5];
d_fft_fftsg.c:    x3r = a[2] - a[6];
d_fft_fftsg.c:    x3i = a[3] - a[7];
d_fft_fftsg.c:    a[2] = x1r - x3i;
d_fft_fftsg.c:    a[4] = x0r - x2r;
d_fft_fftsg.c:    a[5] = x0i - x2i;
d_fft_fftsg.c:    a[7] = x1i - x3r;
d_fft_fftsg.c:    x1r = a[0] - a[4];
d_fft_fftsg.c:    x1i = a[1] - a[5];
d_fft_fftsg.c:    x3r = a[2] - a[6];
d_fft_fftsg.c:    x3i = a[3] - a[7];
d_fft_fftsg.c:    a[3] = x1i - x3r;
d_fft_fftsg.c:    a[4] = x0r - x2r;
d_fft_fftsg.c:    a[5] = x0i - x2i;
d_fft_fftsg.c:    a[6] = x1r - x3i;
d_fft_fftsg.c:    x0r = a[0] - a[2];
d_fft_fftsg.c:    x0i = a[1] - a[3];
d_fft_fftsg.c:        k = n - j;
d_fft_fftsg.c:        wkr = 0.5 - c[nc - kk];
d_fft_fftsg.c:        xr = a[j] - a[k];
d_fft_fftsg.c:        yr = wkr * xr - wki * xi;
d_fft_fftsg.c:        a[j] -= yr;
d_fft_fftsg.c:        a[j + 1] -= yi;
d_fft_fftsg.c:        a[k + 1] -= yi;
d_fft_fftsg.c:        k = n - j;
d_fft_fftsg.c:        wkr = 0.5 - c[nc - kk];
d_fft_fftsg.c:        xr = a[j] - a[k];
d_fft_fftsg.c:        yi = wkr * xi - wki * xr;
d_fft_fftsg.c:        a[j] -= yr;
d_fft_fftsg.c:        a[j + 1] -= yi;
d_fft_fftsg.c:        a[k + 1] -= yi;
d_fft_fftsg.c:        k = n - j;
d_fft_fftsg.c:        wkr = c[kk] - c[nc - kk];
d_fft_fftsg.c:        wki = c[kk] + c[nc - kk];
d_fft_fftsg.c:        xr = wki * a[j] - wkr * a[k];
d_fft_fftsg.c:        k = n - j;
d_fft_fftsg.c:        wkr = c[kk] - c[nc - kk];
d_fft_fftsg.c:        wki = c[kk] + c[nc - kk];
d_fft_fftsg.c:        xr = wki * a[k] - wkr * a[j];
d_fft_fftw.c:/* Copyright (c) 1997- Miller Puckette and others.
d_fft_fftw.c:/* --------- Pd interface to FFTW library; imitate Mayer API ---------- */
d_fft_fftw.c:transform, -1 or +1, which corresponds to FFTW_FORWARD or FFTW_BACKWARD
d_fft_fftw.c:static cfftw_info cfftw_fwd[MAXFFT+1 - MINFFT],cfftw_bwd[MAXFFT+1 - MINFFT];
d_fft_fftw.c:    info = (fwd?cfftw_fwd:cfftw_bwd)+(logn-MINFFT);
d_fft_fftw.c:    if (!info->plan) 
d_fft_fftw.c:        info->in = (fftwf_complex*) fftwf_malloc(sizeof(fftwf_complex) * n);
d_fft_fftw.c:        info->out = (fftwf_complex*) fftwf_malloc(sizeof(fftwf_complex) * n);
d_fft_fftw.c:        info->plan = fftwf_plan_dft_1d(n, info->in, info->out, fwd?FFTW_FORWARD:FFTW_BACKWARD, FFTW_MEASURE);        
d_fft_fftw.c:static rfftw_info rfftw_fwd[MAXFFT+1 - MINFFT],rfftw_bwd[MAXFFT+1 - MINFFT];
d_fft_fftw.c:    info = (fwd?rfftw_fwd:rfftw_bwd)+(logn-MINFFT);
d_fft_fftw.c:    if (!info->plan) 
d_fft_fftw.c:        info->in = (float*) fftwf_malloc(sizeof(float) * n);
d_fft_fftw.c:        info->out = (float*) fftwf_malloc(sizeof(float) * n);
d_fft_fftw.c:        info->plan = fftwf_plan_r2r_1d(n, info->in, info->out, fwd?FFTW_R2HC:FFTW_HC2R, FFTW_MEASURE);
d_fft_fftw.c:    for (i = 0, fz = (float *)p->in; i < n; i++)
d_fft_fftw.c:    fftwf_execute(p->plan);
d_fft_fftw.c:    for (i = 0, fz = (float *)p->out; i < n; i++)
d_fft_fftw.c:        p->in[i] = fz[i];
d_fft_fftw.c:    fftwf_execute(p->plan);
d_fft_fftw.c:        fz[i] = p->out[i];
d_fft_fftw.c:        fz[i] = -p->out[i];
d_fft_fftw.c:        p->in[i] = fz[i];
d_fft_fftw.c:        p->in[i] = -fz[i];    
d_fft_fftw.c:    fftwf_execute(p->plan);
d_fft_fftw.c:        fz[i] = p->out[i];
d_fft_mayer.c:**      Does a real-valued fourier transform of "n" points of the
d_fft_mayer.c:**           Euler     - probable inventor of the fourier transform.
d_fft_mayer.c:**           Gauss     - probable inventor of the FFT.
d_fft_mayer.c:**           Hartley   - probable inventor of the hartley transform.
d_fft_mayer.c:**           Buneman   - for a really cool trig generator
d_fft_mayer.c:**           Mayer(me) - for authoring this particular version and
d_fft_mayer.c:* of work.  -msp
d_fft_mayer.c:         i = k-i;                                                \
d_fft_mayer.c:             for (j=k-i+2 ; (1<<j)&t_lam ; j++);                 \
d_fft_mayer.c:             j         = k - j;                                  \
d_fft_mayer.c:             sinwrk[i] = halsec[i] * (sinwrk[i-1] + sinwrk[j]);  \
d_fft_mayer.c:             coswrk[i] = halsec[i] * (coswrk[i-1] + coswrk[j]);  \
d_fft_mayer.c:     c   = t*t_c - s*t_s;                                \
d_fft_mayer.c:             f1     = fi[0 ]-fi[1 ];
d_fft_mayer.c:             f3     = fi[2 ]-fi[3 ];
d_fft_mayer.c:             fi[2 ] = (f0-f2);  
d_fft_mayer.c:             fi[3 ] = (f1-f3);  
d_fft_mayer.c:             bc1     = fi[0 ] - gi[0 ];
d_fft_mayer.c:             bc2     = fi[2 ] - gi[2 ];
d_fft_mayer.c:             bc3     = fi[4 ] - gi[4 ];
d_fft_mayer.c:             bc4     = fi[6 ] - gi[6 ];
d_fft_mayer.c:             bf1     = (bs1 - bs2);     
d_fft_mayer.c:             bg1     = (bc1 - bc2);     
d_fft_mayer.c:             bf3     = (bs3 - bs4);     
d_fft_mayer.c:             fi[4 ] = bf0 - bf2;
d_fft_mayer.c:             fi[6 ] = bf1 - bf3;
d_fft_mayer.c:             gi[4 ] = bg0 - bg2;
d_fft_mayer.c:             gi[6 ] = bg1 - bg3;
d_fft_mayer.c:             f1      = fi[0 ] - fi[k1];
d_fft_mayer.c:             f3      = fi[k2] - fi[k3];
d_fft_mayer.c:             fi[k2]  = f0         - f2;
d_fft_mayer.c:             fi[k3]  = f1         - f3;
d_fft_mayer.c:             g1      = gi[0 ] - gi[k1];
d_fft_mayer.c:             gi[k2]  = g0         - g2;
d_fft_mayer.c:             gi[k3]  = g1         - g3;
d_fft_mayer.c:         c2 = c1*c1 - s1*s1;
d_fft_mayer.c:             gi = fz +k1-ii;
d_fft_mayer.c:                 b       = s2*fi[k1] - c2*gi[k1];
d_fft_mayer.c:                 f1      = fi[0 ]    - a;
d_fft_mayer.c:                 g1      = gi[0 ]    - b;
d_fft_mayer.c:                 b       = s2*fi[k3] - c2*gi[k3];
d_fft_mayer.c:                 f3      = fi[k2]    - a;
d_fft_mayer.c:                 g3      = gi[k2]    - b;
d_fft_mayer.c:                 b       = s1*f2     - c1*g3;
d_fft_mayer.c:                 fi[k2]  = f0        - a;
d_fft_mayer.c:                 gi[k3]  = g1        - b;
d_fft_mayer.c:                 b       = c1*g2     - s1*f3;
d_fft_mayer.c:                 gi[k2]  = g0        - a;
d_fft_mayer.c:                 fi[k3]  = f1        - b;
d_fft_mayer.c: for (i=1,j=n-1,k=n/2;i<k;i++,j--) {
d_fft_mayer.c:  a = real[i]; b = real[j];  q=a+b; r=a-b;
d_fft_mayer.c:  c = imag[i]; d = imag[j];  s=c+d; t=c-d;
d_fft_mayer.c:  real[i] = (q+t)*.5; real[j] = (q-t)*.5;
d_fft_mayer.c:  imag[i] = (s-r)*.5; imag[j] = (s+r)*.5;
d_fft_mayer.c: for (i=1,j=n-1,k=n/2;i<k;i++,j--) {
d_fft_mayer.c:  a = real[i]; b = real[j];  q=a+b; r=a-b;
d_fft_mayer.c:  c = imag[i]; d = imag[j];  s=c+d; t=c-d;
d_fft_mayer.c:  imag[i] = (s+r)*0.5;  imag[j] = (s-r)*0.5;
d_fft_mayer.c:  real[i] = (q-t)*0.5;  real[j] = (q+t)*0.5;
d_fft_mayer.c: for (i=1,j=n-1,k=n/2;i<k;i++,j--) {
d_fft_mayer.c:  real[j] = (a-b)*0.5;
d_fft_mayer.c: for (i=1,j=n-1,k=n/2;i<k;i++,j--) {
d_fft_mayer.c:  real[j] = (a-b);
d_fftroutine.c:/* UROP - Fall '86                                                           */
d_fftroutine.c:/* REV: 6/12/87(KHP) - To incorporate link list of different sized networks  */
d_fftroutine.c:/* UROP - Fall '86                                                           */
d_fftroutine.c:/* REV: 6/12/87(KHP) - Generalized to one procedure call with typed I/O      */
d_fftroutine.c:   -----------  
d_fftroutine.c:  o--|    |o-| |-o|    |o-| |-o|    |o-| |-o|    |o-| |-o|    |--o
d_fftroutine.c:  o--|____|o-| |-o|____|o-| |-o|____|o-| |-o|____|o-| |-o|____|--o
d_fftroutine.c:  o--|    |o-| |-o|    |o-| |-o|    |o-| |-o|    |o-| |-o|    |--o
d_fftroutine.c:  o--|____|o-| |-o|____|o-| |-o|____|o-| |-o|____|o-| |-o|____|--o
d_fftroutine.c:  o--|    |o-| |-o|    |o-| |-o|    |o-| |-o|    |o-| |-o|    |--o
d_fftroutine.c:  o--|____|o-|_|-o|____|o-|_|-o|____|o-|_|-o|____|o-|_|-o|____|--o
d_fftroutine.c:   The use of "in-place" computation permits one to use only one set of 
d_fftroutine.c:             if (!(thisnet->n == npnt) || !(thisnet->window_type == window)) { 
d_fftroutine.c:               thisnet=thisnet->next;
d_fftroutine.c:           thisnet->next = 0;
d_fftroutine.c:           lastnet->next = thisnet;     /* add to end of list             */
d_fftroutine.c:           thisnet->next = 0;
d_fftroutine.c:             nextnet = thisnet->next;
d_fftroutine.c:         fft_net->n   = n;
d_fftroutine.c:         fft_net->bps = bps = n/2;
d_fftroutine.c:         fft_net->stages = stages = i;
d_fftroutine.c:         fft_net->direction = FORWARD;
d_fftroutine.c:         fft_net->window_type = window_type;
d_fftroutine.c:         fft_net->next = (FFT_NET *)0;
d_fftroutine.c:                  create_hanning(fft_net->window, n, 1.);
d_fftroutine.c:                  create_hanning(fft_net->inv_window, n, 1./n);
d_fftroutine.c:                  create_rectangular(fft_net->window, n, 1.);
d_fftroutine.c:                  create_rectangular(fft_net->inv_window, n, 1./n);
d_fftroutine.c:                  SAMPLE *coeffpr     = fft_net->coeffr;
d_fftroutine.c:                  SAMPLE *coeffpi     = fft_net->coeffi;
d_fftroutine.c:                  SAMPLE *inv_coeffpr = fft_net->inv_coeffr;
d_fftroutine.c:                  SAMPLE *inv_coeffpi = fft_net->inv_coeffi;
d_fftroutine.c:                           num_diff_coeffs = n / (1 << (stages - s + 1)); 
d_fftroutine.c:                           power_inc       = 1 << (stages -s);
d_fftroutine.c:                           for (i = bps/num_diff_coeffs; i > 0; i--) {
d_fftroutine.c:                              for (j = num_diff_coeffs; j > 0; j--) {
d_fftroutine.c:/* AAA change these signs */     *coeffpi     = -sin(two_pi_div_n*power);
d_fftroutine.c:                  SAMPLE **indexpr = fft_net->indexpr;
d_fftroutine.c:                  SAMPLE **indexpi = fft_net->indexpi;
d_fftroutine.c:                  SAMPLE **indexqr = fft_net->indexqr;
d_fftroutine.c:                  SAMPLE **indexqi = fft_net->indexqi;
d_fftroutine.c:                  SAMPLE *regr     = fft_net->regr;
d_fftroutine.c:                  SAMPLE *regi     = fft_net->regi; 
d_fftroutine.c:                           cntr   = 1 << (stages-s-1);
d_fftroutine.c:                                    index = qp[i-1] + 1;
d_fftroutine.c:                           }        while (--cntr);
d_fftroutine.c:                  load_index = load_indexp = fft_net->load_index;
d_fftroutine.c:                  while (j--)
d_fftroutine.c:                  for (s = stages - 1; s > 0; s--) {
d_fftroutine.c:                           while (j--) 
d_fftroutine.c:         int      *load_index = fft_net->load_index;
d_fftroutine.c:         int index, i = 0, n = fft_net->n;
d_fftroutine.c:         if      (trnsfrm_dir==FORWARD)   window = fft_net->window;
d_fftroutine.c:         else if (trnsfrm_dir==INVERSE)   window = fft_net->inv_window;
d_fftroutine.c:         fft_net->direction = trnsfrm_dir;
d_fftroutine.c:             while (i < fft_net->n) {  
d_fftroutine.c:               fft_net->regr[i]=(SAMPLE)buf[index] * window[index];
d_fftroutine.c:               fft_net->regi[i]=0.;
d_fftroutine.c:             while (i < fft_net->n) {  
d_fftroutine.c:               fft_net->regr[i]=0;
d_fftroutine.c:               fft_net->regi[i]=(SAMPLE)buf[index] * window[index];
d_fftroutine.c:             while (i < fft_net->n) {
d_fftroutine.c:               fft_net->regr[i]=(SAMPLE)buf[index*2]   * window[index];
d_fftroutine.c:               fft_net->regi[i]=(SAMPLE)buf[index*2+1] * window[index];
d_fftroutine.c:             while (i < fft_net->n) {
d_fftroutine.c:               fft_net->regr[i]=(SAMPLE)(buf[index*2] * cos(buf[index*2+1])) 
d_fftroutine.c:               fft_net->regi[i]=(SAMPLE)(buf[index*2] * sin(buf[index*2+1])) 
d_fftroutine.c:             while (i < fft_net->n) {  
d_fftroutine.c:               fft_net->regr[i]=(SAMPLE)pow(10., (1./20.)*buf[index]) 
d_fftroutine.c:               fft_net->regi[i]=0.;
d_fftroutine.c:             while (i < fft_net->n) {  
d_fftroutine.c:               fft_net->regr[i]=0.;
d_fftroutine.c:               fft_net->regi[i]=(SAMPLE)pow(10., (1./20.)*buf[index])
d_fftroutine.c:             while (i < fft_net->n) {
d_fftroutine.c:               fft_net->regr[i]=(SAMPLE)pow(10., (1./20.)*buf[index*2])
d_fftroutine.c:               fft_net->regi[i]=(SAMPLE)pow(10., (1./20.)*buf[index*2+1]) 
d_fftroutine.c:             while (i < fft_net->n) {
d_fftroutine.c:               fft_net->regr[i]=(SAMPLE)(pow(10., (1./20.)*buf[index*2])
d_fftroutine.c:               fft_net->regi[i]=(SAMPLE)(pow(10., (1./20.)*buf[index*2])
d_fftroutine.c:         n = fft_net->n;
d_fftroutine.c:               *buf++ = (SAMPLE)fft_net->regr[i];
d_fftroutine.c:               *buf++ = (SAMPLE)fft_net->regi[i];
d_fftroutine.c:               *buf++ = (SAMPLE)fft_net->regr[i];
d_fftroutine.c:               *buf++ = (SAMPLE)fft_net->regi[i];
d_fftroutine.c:               real  = fft_net->regr[i];
d_fftroutine.c:               imag  = fft_net->regi[i];
d_fftroutine.c:               real  = fft_net->regr[i];
d_fftroutine.c:               imag  = fft_net->regi[i];
d_fftroutine.c:                 else if (imag < 0){ *buf++ = -PI / 2.;
d_fftroutine.c:               real    = fft_net->regr[i];
d_fftroutine.c:               imag    = fft_net->regi[i];
d_fftroutine.c:                 else if (imag < 0) *buf++ = -PI / 2.;
d_fftroutine.c:               *buf++ = (SAMPLE)20.*log10(fft_net->regr[i]);
d_fftroutine.c:               *buf++ = (SAMPLE)20.*log10(fft_net->regi[i]);
d_fftroutine.c:               *buf++ = (SAMPLE)20.*log10(fft_net->regr[i]);
d_fftroutine.c:               *buf++ = (SAMPLE)20.*log10(fft_net->regi[i]);
d_fftroutine.c:               real  = fft_net->regr[i];
d_fftroutine.c:               imag  = fft_net->regi[i];
d_fftroutine.c:               real  = fft_net->regr[i];
d_fftroutine.c:               imag  = fft_net->regi[i];
d_fftroutine.c:                 else if (imag < 0) *buf++ = -PI / 2.;
d_fftroutine.c:               real  = fft_net->regr[i];
d_fftroutine.c:               imag  = fft_net->regi[i];
d_fftroutine.c:                 else if (imag < 0) *buf++ = -PI / 2.;
d_fftroutine.c:         X(qn) = X(p) - C*X(q)
d_fftroutine.c:         are stored sequentially and are accessed as such. fft_net->indexp,
d_fftroutine.c:         indexq contain pointers to the relevant addresses, and fft_net->coeffs, 
d_fftroutine.c:         int        bps = fft_net->bps;
d_fftroutine.c:         int        cnt = bps * (fft_net->stages - 1);
d_fftroutine.c:         xpr = fft_net->indexpr;              
d_fftroutine.c:         xpi = fft_net->indexpi;              
d_fftroutine.c:         xqr = fft_net->indexqr;
d_fftroutine.c:         xqi = fft_net->indexqi;
d_fftroutine.c:         if (fft_net->direction==FORWARD) {     /* FORWARD FFT coefficients */
d_fftroutine.c:                  cr  = fft_net->coeffr;
d_fftroutine.c:                  ci  = fft_net->coeffi;
d_fftroutine.c:                  cr = fft_net->inv_coeffr;
d_fftroutine.c:                  ci = fft_net->inv_coeffi;
d_fftroutine.c:                  tqr = **xpr - **xqr;
d_fftroutine.c:                  tqi = **xpi - **xqi;
d_fftroutine.c:                  tqr = **xqr * *cr - **xqi * *ci;
d_fftroutine.c:                  tqr = **xpr - **xqr;
d_fftroutine.c:                  tqi = **xpi - **xqi;
d_fftroutine.c:         n      = fft_net->n;
d_fftroutine.c:         stages = fft_net->stages;
d_fftroutine.c:         bps    = fft_net->bps;
d_fftroutine.c:         fft_net->load_index  = (int *)malloc(n * INT_SIZE);
d_fftroutine.c:         fft_net->regr        = (SAMPLE *)malloc(n * SAMPLE_SIZE);
d_fftroutine.c:         fft_net->regi        = (SAMPLE *)malloc(n * SAMPLE_SIZE);
d_fftroutine.c:         fft_net->coeffr      = (SAMPLE *)malloc(stages*bps*SAMPLE_SIZE);
d_fftroutine.c:         fft_net->coeffi      = (SAMPLE *)malloc(stages*bps*SAMPLE_SIZE);
d_fftroutine.c:         fft_net->inv_coeffr  = (SAMPLE *)malloc(stages*bps*SAMPLE_SIZE);
d_fftroutine.c:         fft_net->inv_coeffi  = (SAMPLE *)malloc(stages*bps*SAMPLE_SIZE);
d_fftroutine.c:         fft_net->indexpr     = (SAMPLE **)malloc(stages * bps * PNTR_SIZE);
d_fftroutine.c:         fft_net->indexpi     = (SAMPLE **)malloc(stages * bps * PNTR_SIZE);
d_fftroutine.c:         fft_net->indexqr     = (SAMPLE **)malloc(stages * bps * PNTR_SIZE);
d_fftroutine.c:         fft_net->indexqi     = (SAMPLE **)malloc(stages * bps * PNTR_SIZE);
d_fftroutine.c:         fft_net->window      = (SAMPLE *)malloc(n * SAMPLE_SIZE);
d_fftroutine.c:         fft_net->inv_window  = (SAMPLE *)malloc(n * SAMPLE_SIZE);
d_fftroutine.c:         free((char *)fft_net->load_index);  
d_fftroutine.c:         free((char *)fft_net->regr);        
d_fftroutine.c:         free((char *)fft_net->regi);        
d_fftroutine.c:         free((char *)fft_net->coeffr);      
d_fftroutine.c:         free((char *)fft_net->coeffi);      
d_fftroutine.c:         free((char *)fft_net->inv_coeffr);  
d_fftroutine.c:         free((char *)fft_net->inv_coeffi);  
d_fftroutine.c:         free((char *)fft_net->indexpr);     
d_fftroutine.c:         free((char *)fft_net->indexpi);     
d_fftroutine.c:         free((char *)fft_net->indexqr);   
d_fftroutine.c:         free((char *)fft_net->indexqi);   
d_fftroutine.c:         free((char *)fft_net->window);
d_fftroutine.c:         free((char *)fft_net->inv_window);
d_fftroutine.c:         while (n--)
d_fftroutine.c:         while (n--) {
d_fftroutine.c:  for (i = npoints << 1, fp = buf; i--; fp++) *fp *= renorm;
d_fftsg_h.c:    radix       :split-radix
d_fftsg_h.c:    dfst: Sine Transform of RDFT (Real Anti-symmetric DFT)
d_fftsg_h.c:-------- Complex DFT (Discrete Fourier Transform) --------
d_fftsg_h.c:            X[k] = sum_j=0^n-1 x[j]*exp(2*pi*i*j*k/n), 0<=k<n
d_fftsg_h.c:            X[k] = sum_j=0^n-1 x[j]*exp(-2*pi*i*j*k/n), 0<=k<n
d_fftsg_h.c:        (notes: sum_j=0^n-1 is a summation from j=0 to n-1)
d_fftsg_h.c:            cdft(2*n, -1, a);
d_fftsg_h.c:        a[0...2*n-1]   :input/output data (double *)
d_fftsg_h.c:            cdft(2*n, -1, a);
d_fftsg_h.c:            for (j = 0; j <= 2 * n - 1; j++) {
d_fftsg_h.c:-------- Real DFT / Inverse of Real DFT --------
d_fftsg_h.c:            R[k] = sum_j=0^n-1 a[j]*cos(2*pi*j*k/n), 0<=k<=n/2
d_fftsg_h.c:            I[k] = sum_j=0^n-1 a[j]*sin(2*pi*j*k/n), 0<k<n/2
d_fftsg_h.c:                   sum_j=1^n/2-1 R[j]*cos(2*pi*j*k/n) + 
d_fftsg_h.c:                   sum_j=1^n/2-1 I[j]*sin(2*pi*j*k/n), 0<=k<n
d_fftsg_h.c:            rdft(n, -1, a);
d_fftsg_h.c:        a[0...n-1]     :input/output data (double *)
d_fftsg_h.c:            rdft(n, -1, a);
d_fftsg_h.c:            for (j = 0; j <= n - 1; j++) {
d_fftsg_h.c:-------- DCT (Discrete Cosine Transform) / Inverse of DCT --------
d_fftsg_h.c:            C[k] = sum_j=0^n-1 a[j]*cos(pi*j*(k+1/2)/n), 0<=k<n
d_fftsg_h.c:            C[k] = sum_j=0^n-1 a[j]*cos(pi*(j+1/2)*k/n), 0<=k<n
d_fftsg_h.c:            ddct(n, -1, a);
d_fftsg_h.c:        a[0...n-1]     :input/output data (double *)
d_fftsg_h.c:            ddct(n, -1, a);
d_fftsg_h.c:            for (j = 0; j <= n - 1; j++) {
d_fftsg_h.c:-------- DST (Discrete Sine Transform) / Inverse of DST --------
d_fftsg_h.c:            S[k] = sum_j=0^n-1 a[j]*sin(pi*(j+1/2)*k/n), 0<k<=n
d_fftsg_h.c:            ddst(n, -1, a);
d_fftsg_h.c:        a[0...n-1]     :input/output data (double *)
d_fftsg_h.c:            ddst(n, -1, a);
d_fftsg_h.c:            for (j = 0; j <= n - 1; j++) {
d_fftsg_h.c:-------- Cosine Transform of RDFT (Real Symmetric DFT) --------
d_fftsg_h.c:        n              :data length - 1 (int)
d_fftsg_h.c:-------- Sine Transform of RDFT (Real Anti-symmetric DFT) --------
d_fftsg_h.c:        S[k] = sum_j=1^n-1 a[j]*sin(pi*j*k/n), 0<k<n
d_fftsg_h.c:        a[0...n-1]     :input/output data (double *)
d_fftsg_h.c:            for (j = 1; j <= n - 1; j++) {
d_fftsg_h.c:        xi = a[0] - a[1];
d_fftsg_h.c:        a[1] = 0.5 * (a[0] - a[1]);
d_fftsg_h.c:        a[0] -= a[1];
d_fftsg_h.c:        xr = a[n - 1];
d_fftsg_h.c:        for (j = n - 2; j >= 2; j -= 2) {
d_fftsg_h.c:            a[j + 1] = a[j] - a[j - 1];
d_fftsg_h.c:            a[j] += a[j - 1];
d_fftsg_h.c:        a[1] = a[0] - xr;
d_fftsg_h.c:        xr = a[0] - a[1];
d_fftsg_h.c:            a[j - 1] = a[j] - a[j + 1];
d_fftsg_h.c:        a[n - 1] = xr;
d_fftsg_h.c:        xr = a[n - 1];
d_fftsg_h.c:        for (j = n - 2; j >= 2; j -= 2) {
d_fftsg_h.c:            a[j + 1] = -a[j] - a[j - 1];
d_fftsg_h.c:            a[j] -= a[j - 1];
d_fftsg_h.c:        a[0] -= xr;
d_fftsg_h.c:        xr = a[0] - a[1];
d_fftsg_h.c:            a[j - 1] = -a[j] - a[j + 1];
d_fftsg_h.c:            a[j] -= a[j + 1];
d_fftsg_h.c:        a[n - 1] = -xr;
d_fftsg_h.c:        k = n - j;
d_fftsg_h.c:        a[j] -= a[k];
d_fftsg_h.c:        a[0] = an - xi;
d_fftsg_h.c:            k = m - j;
d_fftsg_h.c:            a[j] = xr - xi;
d_fftsg_h.c:    a[n] = an - xi;
d_fftsg_h.c:        k = n - j;
d_fftsg_h.c:        xr = a[j] - a[k];
d_fftsg_h.c:            k = m - j;
d_fftsg_h.c:            a[k] = xr - xi;
d_fftsg_h.c:/* -------- child routines -------- */
d_fftsg_h.c:                k1 -= m;
d_fftsg_h.c:                j1 -= m;
d_fftsg_h.c:                k1 -= 2 * m;
d_fftsg_h.c:                j1 -= m;
d_fftsg_h.c:                j1 -= m;
d_fftsg_h.c:                k1 -= 2 * m;
d_fftsg_h.c:                k1 -= m;
d_fftsg_h.c:                j1 -= nh;
d_fftsg_h.c:                k1 -= 2;
d_fftsg_h.c:                j1 -= m;
d_fftsg_h.c:                k1 -= 2 * m;
d_fftsg_h.c:                j1 -= m;
d_fftsg_h.c:                j1 -= m;
d_fftsg_h.c:                k1 -= 2 * m;
d_fftsg_h.c:            k1 -= m;
d_fftsg_h.c:            j1 -= 2;
d_fftsg_h.c:            k1 -= nh;
d_fftsg_h.c:            j1 -= nh - m;
d_fftsg_h.c:            k1 += 2 * m - 2;
d_fftsg_h.c:                j1 -= m;
d_fftsg_h.c:                k1 -= m;
d_fftsg_h.c:                j1 -= nh;
d_fftsg_h.c:                k1 -= 2;
d_fftsg_h.c:                j1 -= m;
d_fftsg_h.c:                k1 -= m;
d_fftsg_h.c:                xi = -a[j + 1];
d_fftsg_h.c:                yi = -a[k + 1];
d_fftsg_h.c:                xi = -a[j1 + 1];
d_fftsg_h.c:                yi = -a[k1 + 1];
d_fftsg_h.c:                k1 -= m;
d_fftsg_h.c:                xi = -a[j1 + 1];
d_fftsg_h.c:                yi = -a[k1 + 1];
d_fftsg_h.c:                xi = -a[j1 + 1];
d_fftsg_h.c:                yi = -a[k1 + 1];
d_fftsg_h.c:                xi = -a[j1 + 1];
d_fftsg_h.c:                yi = -a[k1 + 1];
d_fftsg_h.c:                j1 -= m;
d_fftsg_h.c:                k1 -= 2 * m;
d_fftsg_h.c:                xi = -a[j1 + 1];
d_fftsg_h.c:                yi = -a[k1 + 1];
d_fftsg_h.c:                j1 -= m;
d_fftsg_h.c:                xi = -a[j1 + 1];
d_fftsg_h.c:                yi = -a[k1 + 1];
d_fftsg_h.c:                j1 -= m;
d_fftsg_h.c:                k1 -= 2 * m;
d_fftsg_h.c:                xi = -a[j1 + 1];
d_fftsg_h.c:                yi = -a[k1 + 1];
d_fftsg_h.c:                xi = -a[j1 + 1];
d_fftsg_h.c:                yi = -a[k1 + 1];
d_fftsg_h.c:                xi = -a[j1 + 1];
d_fftsg_h.c:                yi = -a[k1 + 1];
d_fftsg_h.c:                k1 -= m;
d_fftsg_h.c:                xi = -a[j1 + 1];
d_fftsg_h.c:                yi = -a[k1 + 1];
d_fftsg_h.c:                xi = -a[j1 + 1];
d_fftsg_h.c:                yi = -a[k1 + 1];
d_fftsg_h.c:                j1 -= nh;
d_fftsg_h.c:                k1 -= 2;
d_fftsg_h.c:                xi = -a[j1 + 1];
d_fftsg_h.c:                yi = -a[k1 + 1];
d_fftsg_h.c:                j1 -= m;
d_fftsg_h.c:                k1 -= 2 * m;
d_fftsg_h.c:                xi = -a[j1 + 1];
d_fftsg_h.c:                yi = -a[k1 + 1];
d_fftsg_h.c:                j1 -= m;
d_fftsg_h.c:                xi = -a[j1 + 1];
d_fftsg_h.c:                yi = -a[k1 + 1];
d_fftsg_h.c:                j1 -= m;
d_fftsg_h.c:                k1 -= 2 * m;
d_fftsg_h.c:                xi = -a[j1 + 1];
d_fftsg_h.c:                yi = -a[k1 + 1];
d_fftsg_h.c:            a[j1 - 1] = -a[j1 - 1];
d_fftsg_h.c:            xi = -a[j1 + 1];
d_fftsg_h.c:            yi = -a[k1 + 1];
d_fftsg_h.c:            a[k1 + 3] = -a[k1 + 3];
d_fftsg_h.c:            xi = -a[j1 + 1];
d_fftsg_h.c:            yi = -a[k1 + 1];
d_fftsg_h.c:            k1 -= m;
d_fftsg_h.c:            xi = -a[j1 + 1];
d_fftsg_h.c:            yi = -a[k1 + 1];
d_fftsg_h.c:            j1 -= 2;
d_fftsg_h.c:            k1 -= nh;
d_fftsg_h.c:            xi = -a[j1 + 1];
d_fftsg_h.c:            yi = -a[k1 + 1];
d_fftsg_h.c:            xi = -a[j1 + 1];
d_fftsg_h.c:            yi = -a[k1 + 1];
d_fftsg_h.c:            j1 -= nh - m;
d_fftsg_h.c:            k1 += 2 * m - 2;
d_fftsg_h.c:            a[j1 - 1] = -a[j1 - 1];
d_fftsg_h.c:            xi = -a[j1 + 1];
d_fftsg_h.c:            yi = -a[k1 + 1];
d_fftsg_h.c:            a[k1 + 3] = -a[k1 + 3];
d_fftsg_h.c:                xi = -a[j + 1];
d_fftsg_h.c:                yi = -a[k + 1];
d_fftsg_h.c:                xi = -a[j1 + 1];
d_fftsg_h.c:                yi = -a[k1 + 1];
d_fftsg_h.c:                xi = -a[j1 + 1];
d_fftsg_h.c:                yi = -a[k1 + 1];
d_fftsg_h.c:                j1 -= m;
d_fftsg_h.c:                k1 -= m;
d_fftsg_h.c:                xi = -a[j1 + 1];
d_fftsg_h.c:                yi = -a[k1 + 1];
d_fftsg_h.c:                xi = -a[j1 + 1];
d_fftsg_h.c:                yi = -a[k1 + 1];
d_fftsg_h.c:                xi = -a[j1 + 1];
d_fftsg_h.c:                yi = -a[k1 + 1];
d_fftsg_h.c:                j1 -= nh;
d_fftsg_h.c:                k1 -= 2;
d_fftsg_h.c:                xi = -a[j1 + 1];
d_fftsg_h.c:                yi = -a[k1 + 1];
d_fftsg_h.c:                j1 -= m;
d_fftsg_h.c:                k1 -= m;
d_fftsg_h.c:                xi = -a[j1 + 1];
d_fftsg_h.c:                yi = -a[k1 + 1];
d_fftsg_h.c:            a[j1 - 1] = -a[j1 - 1];
d_fftsg_h.c:            xi = -a[j1 + 1];
d_fftsg_h.c:            yi = -a[k1 + 1];
d_fftsg_h.c:            a[k1 + 3] = -a[k1 + 3];
d_fftsg_h.c:            a[j1 - 1] = -a[j1 - 1];
d_fftsg_h.c:            xi = -a[j1 + 1];
d_fftsg_h.c:            yi = -a[k1 + 1];
d_fftsg_h.c:            a[k1 + 3] = -a[k1 + 3];
d_fftsg_h.c:                j1 -= m;
d_fftsg_h.c:                k1 -= m;
d_fftsg_h.c:                j1 -= nh;
d_fftsg_h.c:                k1--;
d_fftsg_h.c:                j1 -= m;
d_fftsg_h.c:                k1 -= m;
d_fftsg_h.c:                j1 -= nh;
d_fftsg_h.c:                k1--;
d_fftsg_h.c:    x0i = -a[1] - a[j2 + 1];
d_fftsg_h.c:    x1r = a[0] - a[j2];
d_fftsg_h.c:    x1i = -a[1] + a[j2 + 1];
d_fftsg_h.c:    x3r = a[j1] - a[j3];
d_fftsg_h.c:    x3i = a[j1 + 1] - a[j3 + 1];
d_fftsg_h.c:    a[1] = x0i - x2i;
d_fftsg_h.c:    a[j1] = x0r - x2r;
d_fftsg_h.c:    a[j3] = x1r - x3i;
d_fftsg_h.c:    a[j3 + 1] = x1i - x3r;
d_fftsg_h.c:    wk3r = wk1r - wk3i * wk1i;
d_fftsg_h.c:    wk3i = wk1i - wk3i * wk1r;
d_fftsg_h.c:        if (i0 > mh - 4) {
d_fftsg_h.c:            i0 = mh - 4;
d_fftsg_h.c:            wd1r -= ss1 * wk1i;
d_fftsg_h.c:            wd3r -= ss3 * wk3i;
d_fftsg_h.c:            x0i = -a[j + 1] - a[j2 + 1];
d_fftsg_h.c:            x1r = a[j] - a[j2];
d_fftsg_h.c:            x1i = -a[j + 1] + a[j2 + 1];
d_fftsg_h.c:            x3r = a[j1] - a[j3];
d_fftsg_h.c:            x3i = a[j1 + 1] - a[j3 + 1];
d_fftsg_h.c:            a[j + 1] = x0i - x2i;
d_fftsg_h.c:            a[j1] = x0r - x2r;
d_fftsg_h.c:            a[j2] = wk1r * x0r - wk1i * x0i;
d_fftsg_h.c:            x0r = x1r - x3i;
d_fftsg_h.c:            x0i = x1i - x3r;
d_fftsg_h.c:            a[j3 + 1] = wk3r * x0i - wk3i * x0r;
d_fftsg_h.c:            x0i = -a[j + 3] - a[j2 + 3];
d_fftsg_h.c:            x1r = a[j + 2] - a[j2 + 2];
d_fftsg_h.c:            x1i = -a[j + 3] + a[j2 + 3];
d_fftsg_h.c:            x3r = a[j1 + 2] - a[j3 + 2];
d_fftsg_h.c:            x3i = a[j1 + 3] - a[j3 + 3];
d_fftsg_h.c:            a[j + 3] = x0i - x2i;
d_fftsg_h.c:            a[j1 + 2] = x0r - x2r;
d_fftsg_h.c:            a[j2 + 2] = wd1r * x0r - wd1i * x0i;
d_fftsg_h.c:            x0r = x1r - x3i;
d_fftsg_h.c:            x0i = x1i - x3r;
d_fftsg_h.c:            a[j3 + 3] = wd3r * x0i - wd3i * x0r;
d_fftsg_h.c:            j0 = m - j;
d_fftsg_h.c:            x0i = -a[j0 + 1] - a[j2 + 1];
d_fftsg_h.c:            x1r = a[j0] - a[j2];
d_fftsg_h.c:            x1i = -a[j0 + 1] + a[j2 + 1];
d_fftsg_h.c:            x3r = a[j1] - a[j3];
d_fftsg_h.c:            x3i = a[j1 + 1] - a[j3 + 1];
d_fftsg_h.c:            a[j0 + 1] = x0i - x2i;
d_fftsg_h.c:            a[j1] = x0r - x2r;
d_fftsg_h.c:            a[j2] = wk1i * x0r - wk1r * x0i;
d_fftsg_h.c:            x0r = x1r - x3i;
d_fftsg_h.c:            x0i = x1i - x3r;
d_fftsg_h.c:            a[j3 + 1] = wk3i * x0i - wk3r * x0r;
d_fftsg_h.c:            x0r = a[j0 - 2] + a[j2 - 2];
d_fftsg_h.c:            x0i = -a[j0 - 1] - a[j2 - 1];
d_fftsg_h.c:            x1r = a[j0 - 2] - a[j2 - 2];
d_fftsg_h.c:            x1i = -a[j0 - 1] + a[j2 - 1];
d_fftsg_h.c:            x2r = a[j1 - 2] + a[j3 - 2];
d_fftsg_h.c:            x2i = a[j1 - 1] + a[j3 - 1];
d_fftsg_h.c:            x3r = a[j1 - 2] - a[j3 - 2];
d_fftsg_h.c:            x3i = a[j1 - 1] - a[j3 - 1];
d_fftsg_h.c:            a[j0 - 2] = x0r + x2r;
d_fftsg_h.c:            a[j0 - 1] = x0i - x2i;
d_fftsg_h.c:            a[j1 - 2] = x0r - x2r;
d_fftsg_h.c:            a[j1 - 1] = x0i + x2i;
d_fftsg_h.c:            a[j2 - 2] = wd1i * x0r - wd1r * x0i;
d_fftsg_h.c:            a[j2 - 1] = wd1i * x0i + wd1r * x0r;
d_fftsg_h.c:            x0r = x1r - x3i;
d_fftsg_h.c:            x0i = x1i - x3r;
d_fftsg_h.c:            a[j3 - 2] = wd3i * x0r + wd3r * x0i;
d_fftsg_h.c:            a[j3 - 1] = wd3i * x0i - wd3r * x0r;
d_fftsg_h.c:            wk1r -= ss1 * wd1i;
d_fftsg_h.c:            wk3r -= ss3 * wd3i;
d_fftsg_h.c:        if (i0 == mh - 4) {
d_fftsg_h.c:        wd3r = wd1r - wd3i * wd1i;
d_fftsg_h.c:        wd3i = wd1i - wd3i * wd1r;
d_fftsg_h.c:        wk1r = w1r * wd1r - w1i * wd1i;
d_fftsg_h.c:        wk3r = wk1r - wk3i * wk1i;
d_fftsg_h.c:        wk3i = wk1i - wk3i * wk1r;
d_fftsg_h.c:    x0r = a[j0 - 2] + a[j2 - 2];
d_fftsg_h.c:    x0i = -a[j0 - 1] - a[j2 - 1];
d_fftsg_h.c:    x1r = a[j0 - 2] - a[j2 - 2];
d_fftsg_h.c:    x1i = -a[j0 - 1] + a[j2 - 1];
d_fftsg_h.c:    x2r = a[j1 - 2] + a[j3 - 2];
d_fftsg_h.c:    x2i = a[j1 - 1] + a[j3 - 1];
d_fftsg_h.c:    x3r = a[j1 - 2] - a[j3 - 2];
d_fftsg_h.c:    x3i = a[j1 - 1] - a[j3 - 1];
d_fftsg_h.c:    a[j0 - 2] = x0r + x2r;
d_fftsg_h.c:    a[j0 - 1] = x0i - x2i;
d_fftsg_h.c:    a[j1 - 2] = x0r - x2r;
d_fftsg_h.c:    a[j1 - 1] = x0i + x2i;
d_fftsg_h.c:    a[j2 - 2] = wk1r * x0r - wk1i * x0i;
d_fftsg_h.c:    a[j2 - 1] = wk1r * x0i + wk1i * x0r;
d_fftsg_h.c:    x0r = x1r - x3i;
d_fftsg_h.c:    x0i = x1i - x3r;
d_fftsg_h.c:    a[j3 - 2] = wk3r * x0r + wk3i * x0i;
d_fftsg_h.c:    a[j3 - 1] = wk3r * x0i - wk3i * x0r;
d_fftsg_h.c:    x0i = -a[j0 + 1] - a[j2 + 1];
d_fftsg_h.c:    x1r = a[j0] - a[j2];
d_fftsg_h.c:    x1i = -a[j0 + 1] + a[j2 + 1];
d_fftsg_h.c:    x3r = a[j1] - a[j3];
d_fftsg_h.c:    x3i = a[j1 + 1] - a[j3 + 1];
d_fftsg_h.c:    a[j0 + 1] = x0i - x2i;
d_fftsg_h.c:    a[j1] = x0r - x2r;
d_fftsg_h.c:    a[j2] = wd1r * (x0r - x0i);
d_fftsg_h.c:    x0r = x1r - x3i;
d_fftsg_h.c:    x0i = x1i - x3r;
d_fftsg_h.c:    a[j3] = -wd1r * (x0r + x0i);
d_fftsg_h.c:    a[j3 + 1] = -wd1r * (x0i - x0r);
d_fftsg_h.c:    x0i = -a[j0 + 3] - a[j2 + 3];
d_fftsg_h.c:    x1r = a[j0 + 2] - a[j2 + 2];
d_fftsg_h.c:    x1i = -a[j0 + 3] + a[j2 + 3];
d_fftsg_h.c:    x3r = a[j1 + 2] - a[j3 + 2];
d_fftsg_h.c:    x3i = a[j1 + 3] - a[j3 + 3];
d_fftsg_h.c:    a[j0 + 3] = x0i - x2i;
d_fftsg_h.c:    a[j1 + 2] = x0r - x2r;
d_fftsg_h.c:    a[j2 + 2] = wk1i * x0r - wk1r * x0i;
d_fftsg_h.c:    x0r = x1r - x3i;
d_fftsg_h.c:    x0i = x1i - x3r;
d_fftsg_h.c:    a[j3 + 3] = wk3i * x0i - wk3r * x0r;
d_fftsg_h.c:    n0 = ((cdft_arg_t *) p)->n0;
d_fftsg_h.c:    n = ((cdft_arg_t *) p)->n;
d_fftsg_h.c:    a = ((cdft_arg_t *) p)->a;
d_fftsg_h.c:        cftmdl1(m, &a[n - m]);
d_fftsg_h.c:    cftleaf(m, 1, &a[n - m]);
d_fftsg_h.c:    for (j = n - m; j > 0; j -= m) {
d_fftsg_h.c:        cftleaf(m, isplt, &a[j - m]);
d_fftsg_h.c:    n0 = ((cdft_arg_t *) p)->n0;
d_fftsg_h.c:    n = ((cdft_arg_t *) p)->n;
d_fftsg_h.c:    a = ((cdft_arg_t *) p)->a;
d_fftsg_h.c:        cftmdl2(m, &a[n - m]);
d_fftsg_h.c:    cftleaf(m, 0, &a[n - m]);
d_fftsg_h.c:    for (j = n - m; j > 0; j -= m) {
d_fftsg_h.c:        cftleaf(m, isplt, &a[j - m]);
d_fftsg_h.c:        cftmdl1(m, &a[n - m]);
d_fftsg_h.c:    cftleaf(m, 1, &a[n - m]);
d_fftsg_h.c:    for (j = n - m; j > 0; j -= m) {
d_fftsg_h.c:        cftleaf(m, isplt, &a[j - m]);
d_fftsg_h.c:            cftmdl1(n, &a[j - n]);
d_fftsg_h.c:            cftmdl2(n, &a[j - n]);
d_fftsg_h.c:                cftmdl1(m, &a[j - m]);
d_fftsg_h.c:                cftmdl2(m, &a[j - m]);
d_fftsg_h.c:    x1r = a[0] - a[j2];
d_fftsg_h.c:    x1i = a[1] - a[j2 + 1];
d_fftsg_h.c:    x3r = a[j1] - a[j3];
d_fftsg_h.c:    x3i = a[j1 + 1] - a[j3 + 1];
d_fftsg_h.c:    a[j1] = x0r - x2r;
d_fftsg_h.c:    a[j1 + 1] = x0i - x2i;
d_fftsg_h.c:    a[j2] = x1r - x3i;
d_fftsg_h.c:    a[j3 + 1] = x1i - x3r;
d_fftsg_h.c:    wk3r = wk1r - wk3i * wk1i;
d_fftsg_h.c:    wk3i = wk1i - wk3i * wk1r;
d_fftsg_h.c:        if (i0 > mh - 4) {
d_fftsg_h.c:            i0 = mh - 4;
d_fftsg_h.c:            wd1r -= ss1 * wk1i;
d_fftsg_h.c:            wd3r -= ss3 * wk3i;
d_fftsg_h.c:            x1r = a[j] - a[j2];
d_fftsg_h.c:            x1i = a[j + 1] - a[j2 + 1];
d_fftsg_h.c:            x3r = a[j1] - a[j3];
d_fftsg_h.c:            x3i = a[j1 + 1] - a[j3 + 1];
d_fftsg_h.c:            a[j1] = x0r - x2r;
d_fftsg_h.c:            a[j1 + 1] = x0i - x2i;
d_fftsg_h.c:            x0r = x1r - x3i;
d_fftsg_h.c:            a[j2] = wk1r * x0r - wk1i * x0i;
d_fftsg_h.c:            x0i = x1i - x3r;
d_fftsg_h.c:            a[j3 + 1] = wk3r * x0i - wk3i * x0r;
d_fftsg_h.c:            x1r = a[j + 2] - a[j2 + 2];
d_fftsg_h.c:            x1i = a[j + 3] - a[j2 + 3];
d_fftsg_h.c:            x3r = a[j1 + 2] - a[j3 + 2];
d_fftsg_h.c:            x3i = a[j1 + 3] - a[j3 + 3];
d_fftsg_h.c:            a[j1 + 2] = x0r - x2r;
d_fftsg_h.c:            a[j1 + 3] = x0i - x2i;
d_fftsg_h.c:            x0r = x1r - x3i;
d_fftsg_h.c:            a[j2 + 2] = wd1r * x0r - wd1i * x0i;
d_fftsg_h.c:            x0i = x1i - x3r;
d_fftsg_h.c:            a[j3 + 3] = wd3r * x0i - wd3i * x0r;
d_fftsg_h.c:            j0 = m - j;
d_fftsg_h.c:            x1r = a[j0] - a[j2];
d_fftsg_h.c:            x1i = a[j0 + 1] - a[j2 + 1];
d_fftsg_h.c:            x3r = a[j1] - a[j3];
d_fftsg_h.c:            x3i = a[j1 + 1] - a[j3 + 1];
d_fftsg_h.c:            a[j1] = x0r - x2r;
d_fftsg_h.c:            a[j1 + 1] = x0i - x2i;
d_fftsg_h.c:            x0r = x1r - x3i;
d_fftsg_h.c:            a[j2] = wk1i * x0r - wk1r * x0i;
d_fftsg_h.c:            x0i = x1i - x3r;
d_fftsg_h.c:            a[j3 + 1] = wk3i * x0i - wk3r * x0r;
d_fftsg_h.c:            x0r = a[j0 - 2] + a[j2 - 2];
d_fftsg_h.c:            x0i = a[j0 - 1] + a[j2 - 1];
d_fftsg_h.c:            x1r = a[j0 - 2] - a[j2 - 2];
d_fftsg_h.c:            x1i = a[j0 - 1] - a[j2 - 1];
d_fftsg_h.c:            x2r = a[j1 - 2] + a[j3 - 2];
d_fftsg_h.c:            x2i = a[j1 - 1] + a[j3 - 1];
d_fftsg_h.c:            x3r = a[j1 - 2] - a[j3 - 2];
d_fftsg_h.c:            x3i = a[j1 - 1] - a[j3 - 1];
d_fftsg_h.c:            a[j0 - 2] = x0r + x2r;
d_fftsg_h.c:            a[j0 - 1] = x0i + x2i;
d_fftsg_h.c:            a[j1 - 2] = x0r - x2r;
d_fftsg_h.c:            a[j1 - 1] = x0i - x2i;
d_fftsg_h.c:            x0r = x1r - x3i;
d_fftsg_h.c:            a[j2 - 2] = wd1i * x0r - wd1r * x0i;
d_fftsg_h.c:            a[j2 - 1] = wd1i * x0i + wd1r * x0r;
d_fftsg_h.c:            x0i = x1i - x3r;
d_fftsg_h.c:            a[j3 - 2] = wd3i * x0r + wd3r * x0i;
d_fftsg_h.c:            a[j3 - 1] = wd3i * x0i - wd3r * x0r;
d_fftsg_h.c:            wk1r -= ss1 * wd1i;
d_fftsg_h.c:            wk3r -= ss3 * wd3i;
d_fftsg_h.c:        if (i0 == mh - 4) {
d_fftsg_h.c:        wd3r = wd1r - wd3i * wd1i;
d_fftsg_h.c:        wd3i = wd1i - wd3i * wd1r;
d_fftsg_h.c:        wk1r = w1r * wd1r - w1i * wd1i;
d_fftsg_h.c:        wk3r = wk1r - wk3i * wk1i;
d_fftsg_h.c:        wk3i = wk1i - wk3i * wk1r;
d_fftsg_h.c:    x0r = a[j0 - 2] + a[j2 - 2];
d_fftsg_h.c:    x0i = a[j0 - 1] + a[j2 - 1];
d_fftsg_h.c:    x1r = a[j0 - 2] - a[j2 - 2];
d_fftsg_h.c:    x1i = a[j0 - 1] - a[j2 - 1];
d_fftsg_h.c:    x2r = a[j1 - 2] + a[j3 - 2];
d_fftsg_h.c:    x2i = a[j1 - 1] + a[j3 - 1];
d_fftsg_h.c:    x3r = a[j1 - 2] - a[j3 - 2];
d_fftsg_h.c:    x3i = a[j1 - 1] - a[j3 - 1];
d_fftsg_h.c:    a[j0 - 2] = x0r + x2r;
d_fftsg_h.c:    a[j0 - 1] = x0i + x2i;
d_fftsg_h.c:    a[j1 - 2] = x0r - x2r;
d_fftsg_h.c:    a[j1 - 1] = x0i - x2i;
d_fftsg_h.c:    x0r = x1r - x3i;
d_fftsg_h.c:    a[j2 - 2] = wk1r * x0r - wk1i * x0i;
d_fftsg_h.c:    a[j2 - 1] = wk1r * x0i + wk1i * x0r;
d_fftsg_h.c:    x0i = x1i - x3r;
d_fftsg_h.c:    a[j3 - 2] = wk3r * x0r + wk3i * x0i;
d_fftsg_h.c:    a[j3 - 1] = wk3r * x0i - wk3i * x0r;
d_fftsg_h.c:    x1r = a[j0] - a[j2];
d_fftsg_h.c:    x1i = a[j0 + 1] - a[j2 + 1];
d_fftsg_h.c:    x3r = a[j1] - a[j3];
d_fftsg_h.c:    x3i = a[j1 + 1] - a[j3 + 1];
d_fftsg_h.c:    a[j1] = x0r - x2r;
d_fftsg_h.c:    a[j1 + 1] = x0i - x2i;
d_fftsg_h.c:    x0r = x1r - x3i;
d_fftsg_h.c:    a[j2] = wd1r * (x0r - x0i);
d_fftsg_h.c:    x0i = x1i - x3r;
d_fftsg_h.c:    a[j3] = -wd1r * (x0r + x0i);
d_fftsg_h.c:    a[j3 + 1] = -wd1r * (x0i - x0r);
d_fftsg_h.c:    x1r = a[j0 + 2] - a[j2 + 2];
d_fftsg_h.c:    x1i = a[j0 + 3] - a[j2 + 3];
d_fftsg_h.c:    x3r = a[j1 + 2] - a[j3 + 2];
d_fftsg_h.c:    x3i = a[j1 + 3] - a[j3 + 3];
d_fftsg_h.c:    a[j1 + 2] = x0r - x2r;
d_fftsg_h.c:    a[j1 + 3] = x0i - x2i;
d_fftsg_h.c:    x0r = x1r - x3i;
d_fftsg_h.c:    a[j2 + 2] = wk1i * x0r - wk1r * x0i;
d_fftsg_h.c:    x0i = x1i - x3r;
d_fftsg_h.c:    a[j3 + 3] = wk3i * x0i - wk3r * x0r;
d_fftsg_h.c:    x0r = a[0] - a[j2 + 1];
d_fftsg_h.c:    x1i = a[1] - a[j2];
d_fftsg_h.c:    x2r = a[j1] - a[j3 + 1];
d_fftsg_h.c:    x3i = a[j1 + 1] - a[j3];
d_fftsg_h.c:    y0r = wn4r * (x2r - x2i);
d_fftsg_h.c:    a[j1] = x0r - y0r;
d_fftsg_h.c:    a[j1 + 1] = x0i - y0i;
d_fftsg_h.c:    y0r = wn4r * (x3r - x3i);
d_fftsg_h.c:    a[j2] = x1r - y0i;
d_fftsg_h.c:    a[j3 + 1] = x1i - y0r;
d_fftsg_h.c:    we3r = -wn4r;
d_fftsg_h.c:    we3i = -wn4r;
d_fftsg_h.c:    wd1r = wn4r * (w1r - w1i);
d_fftsg_h.c:    wk3r = wk1r - wk3i * wk1i;
d_fftsg_h.c:    wk3i = wk1i - wk3i * wk1r;
d_fftsg_h.c:    wd3r = -wn4r * (wk3r - wk3i);
d_fftsg_h.c:    wd3i = -wn4r * (wk3i + wk3r);
d_fftsg_h.c:        if (i0 > mh - 4) {
d_fftsg_h.c:            i0 = mh - 4;
d_fftsg_h.c:            wl1r -= ss1 * wk1i;
d_fftsg_h.c:            wl3r -= ss3 * wk3i;
d_fftsg_h.c:            we1r -= ss1 * wd1i;
d_fftsg_h.c:            we3r -= ss3 * wd3i;
d_fftsg_h.c:            x0r = a[j] - a[j2 + 1];
d_fftsg_h.c:            x1i = a[j + 1] - a[j2];
d_fftsg_h.c:            x2r = a[j1] - a[j3 + 1];
d_fftsg_h.c:            x3i = a[j1 + 1] - a[j3];
d_fftsg_h.c:            y0r = wk1r * x0r - wk1i * x0i;
d_fftsg_h.c:            y2r = wd1r * x2r - wd1i * x2i;
d_fftsg_h.c:            a[j1] = y0r - y2r;
d_fftsg_h.c:            a[j1 + 1] = y0i - y2i;
d_fftsg_h.c:            y0i = wk3r * x1i - wk3i * x1r;
d_fftsg_h.c:            y2i = wd3r * x3i - wd3i * x3r;
d_fftsg_h.c:            a[j3] = y0r - y2r;
d_fftsg_h.c:            a[j3 + 1] = y0i - y2i;
d_fftsg_h.c:            x0r = a[j + 2] - a[j2 + 3];
d_fftsg_h.c:            x1i = a[j + 3] - a[j2 + 2];
d_fftsg_h.c:            x2r = a[j1 + 2] - a[j3 + 3];
d_fftsg_h.c:            x3i = a[j1 + 3] - a[j3 + 2];
d_fftsg_h.c:            y0r = wl1r * x0r - wl1i * x0i;
d_fftsg_h.c:            y2r = we1r * x2r - we1i * x2i;
d_fftsg_h.c:            a[j1 + 2] = y0r - y2r;
d_fftsg_h.c:            a[j1 + 3] = y0i - y2i;
d_fftsg_h.c:            y0i = wl3r * x1i - wl3i * x1r;
d_fftsg_h.c:            y2i = we3r * x3i - we3i * x3r;
d_fftsg_h.c:            a[j3 + 2] = y0r - y2r;
d_fftsg_h.c:            a[j3 + 3] = y0i - y2i;
d_fftsg_h.c:            j0 = m - j;
d_fftsg_h.c:            x0r = a[j0] - a[j2 + 1];
d_fftsg_h.c:            x1i = a[j0 + 1] - a[j2];
d_fftsg_h.c:            x2r = a[j1] - a[j3 + 1];
d_fftsg_h.c:            x3i = a[j1 + 1] - a[j3];
d_fftsg_h.c:            y0r = wd1i * x0r - wd1r * x0i;
d_fftsg_h.c:            y2r = wk1i * x2r - wk1r * x2i;
d_fftsg_h.c:            a[j1] = y0r - y2r;
d_fftsg_h.c:            a[j1 + 1] = y0i - y2i;
d_fftsg_h.c:            y0i = wd3i * x1i - wd3r * x1r;
d_fftsg_h.c:            y2i = wk3i * x3i - wk3r * x3r;
d_fftsg_h.c:            a[j3] = y0r - y2r;
d_fftsg_h.c:            a[j3 + 1] = y0i - y2i;
d_fftsg_h.c:            x0r = a[j0 - 2] - a[j2 - 1];
d_fftsg_h.c:            x0i = a[j0 - 1] + a[j2 - 2];
d_fftsg_h.c:            x1r = a[j0 - 2] + a[j2 - 1];
d_fftsg_h.c:            x1i = a[j0 - 1] - a[j2 - 2];
d_fftsg_h.c:            x2r = a[j1 - 2] - a[j3 - 1];
d_fftsg_h.c:            x2i = a[j1 - 1] + a[j3 - 2];
d_fftsg_h.c:            x3r = a[j1 - 2] + a[j3 - 1];
d_fftsg_h.c:            x3i = a[j1 - 1] - a[j3 - 2];
d_fftsg_h.c:            y0r = we1i * x0r - we1r * x0i;
d_fftsg_h.c:            y2r = wl1i * x2r - wl1r * x2i;
d_fftsg_h.c:            a[j0 - 2] = y0r + y2r;
d_fftsg_h.c:            a[j0 - 1] = y0i + y2i;
d_fftsg_h.c:            a[j1 - 2] = y0r - y2r;
d_fftsg_h.c:            a[j1 - 1] = y0i - y2i;
d_fftsg_h.c:            y0i = we3i * x1i - we3r * x1r;
d_fftsg_h.c:            y2i = wl3i * x3i - wl3r * x3r;
d_fftsg_h.c:            a[j2 - 2] = y0r + y2r;
d_fftsg_h.c:            a[j2 - 1] = y0i + y2i;
d_fftsg_h.c:            a[j3 - 2] = y0r - y2r;
d_fftsg_h.c:            a[j3 - 1] = y0i - y2i;
d_fftsg_h.c:            wk1r -= ss1 * wl1i;
d_fftsg_h.c:            wk3r -= ss3 * wl3i;
d_fftsg_h.c:            wd1r -= ss1 * we1i;
d_fftsg_h.c:            wd3r -= ss3 * we3i;
d_fftsg_h.c:        if (i0 == mh - 4) {
d_fftsg_h.c:        wl3r = wl1r - wl3i * wl1i;
d_fftsg_h.c:        wl3i = wl1i - wl3i * wl1r;
d_fftsg_h.c:        we1r = wn4r * (wl1r - wl1i);
d_fftsg_h.c:        we3r = -wn4r * (wl3r - wl3i);
d_fftsg_h.c:        we3i = -wn4r * (wl3i + wl3r);
d_fftsg_h.c:        wk1r = w1r * wl1r - w1i * wl1i;
d_fftsg_h.c:        wk3r = wk1r - wk3i * wk1i;
d_fftsg_h.c:        wk3i = wk1i - wk3i * wk1r;
d_fftsg_h.c:        wd1r = wn4r * (wk1r - wk1i);
d_fftsg_h.c:        wd3r = -wn4r * (wk3r - wk3i);
d_fftsg_h.c:        wd3i = -wn4r * (wk3i + wk3r);
d_fftsg_h.c:    x0r = a[j0 - 2] - a[j2 - 1];
d_fftsg_h.c:    x0i = a[j0 - 1] + a[j2 - 2];
d_fftsg_h.c:    x1r = a[j0 - 2] + a[j2 - 1];
d_fftsg_h.c:    x1i = a[j0 - 1] - a[j2 - 2];
d_fftsg_h.c:    x2r = a[j1 - 2] - a[j3 - 1];
d_fftsg_h.c:    x2i = a[j1 - 1] + a[j3 - 2];
d_fftsg_h.c:    x3r = a[j1 - 2] + a[j3 - 1];
d_fftsg_h.c:    x3i = a[j1 - 1] - a[j3 - 2];
d_fftsg_h.c:    y0r = wk1r * x0r - wk1i * x0i;
d_fftsg_h.c:    y2r = wd1r * x2r - wd1i * x2i;
d_fftsg_h.c:    a[j0 - 2] = y0r + y2r;
d_fftsg_h.c:    a[j0 - 1] = y0i + y2i;
d_fftsg_h.c:    a[j1 - 2] = y0r - y2r;
d_fftsg_h.c:    a[j1 - 1] = y0i - y2i;
d_fftsg_h.c:    y0i = wk3r * x1i - wk3i * x1r;
d_fftsg_h.c:    y2i = wd3r * x3i - wd3i * x3r;
d_fftsg_h.c:    a[j2 - 2] = y0r + y2r;
d_fftsg_h.c:    a[j2 - 1] = y0i + y2i;
d_fftsg_h.c:    a[j3 - 2] = y0r - y2r;
d_fftsg_h.c:    a[j3 - 1] = y0i - y2i;
d_fftsg_h.c:    x0r = a[j0] - a[j2 + 1];
d_fftsg_h.c:    x1i = a[j0 + 1] - a[j2];
d_fftsg_h.c:    x2r = a[j1] - a[j3 + 1];
d_fftsg_h.c:    x3i = a[j1 + 1] - a[j3];
d_fftsg_h.c:    y0r = wl1r * x0r - wl1i * x0i;
d_fftsg_h.c:    y2r = wl1i * x2r - wl1r * x2i;
d_fftsg_h.c:    a[j1] = y0r - y2r;
d_fftsg_h.c:    a[j1 + 1] = y0i - y2i;
d_fftsg_h.c:    y0r = wl1i * x1r - wl1r * x1i;
d_fftsg_h.c:    y2r = wl1r * x3r - wl1i * x3i;
d_fftsg_h.c:    a[j2] = y0r - y2r;
d_fftsg_h.c:    a[j2 + 1] = y0i - y2i;
d_fftsg_h.c:    x0r = a[j0 + 2] - a[j2 + 3];
d_fftsg_h.c:    x1i = a[j0 + 3] - a[j2 + 2];
d_fftsg_h.c:    x2r = a[j1 + 2] - a[j3 + 3];
d_fftsg_h.c:    x3i = a[j1 + 3] - a[j3 + 2];
d_fftsg_h.c:    y0r = wd1i * x0r - wd1r * x0i;
d_fftsg_h.c:    y2r = wk1i * x2r - wk1r * x2i;
d_fftsg_h.c:    a[j1 + 2] = y0r - y2r;
d_fftsg_h.c:    a[j1 + 3] = y0i - y2i;
d_fftsg_h.c:    y0i = wd3i * x1i - wd3r * x1r;
d_fftsg_h.c:    y2i = wk3i * x3i - wk3r * x3r;
d_fftsg_h.c:    a[j3 + 2] = y0r - y2r;
d_fftsg_h.c:    a[j3 + 3] = y0i - y2i;
d_fftsg_h.c:    x1r = a[0] - a[16];
d_fftsg_h.c:    x1i = a[1] - a[17];
d_fftsg_h.c:    x3r = a[8] - a[24];
d_fftsg_h.c:    x3i = a[9] - a[25];
d_fftsg_h.c:    y4r = x0r - x2r;
d_fftsg_h.c:    y4i = x0i - x2i;
d_fftsg_h.c:    y8r = x1r - x3i;
d_fftsg_h.c:    y12i = x1i - x3r;
d_fftsg_h.c:    x1r = a[2] - a[18];
d_fftsg_h.c:    x1i = a[3] - a[19];
d_fftsg_h.c:    x3r = a[10] - a[26];
d_fftsg_h.c:    x3i = a[11] - a[27];
d_fftsg_h.c:    y5r = x0r - x2r;
d_fftsg_h.c:    y5i = x0i - x2i;
d_fftsg_h.c:    x0r = x1r - x3i;
d_fftsg_h.c:    y9r = wk1r * x0r - wk1i * x0i;
d_fftsg_h.c:    x0i = x1i - x3r;
d_fftsg_h.c:    y13r = wk1i * x0r - wk1r * x0i;
d_fftsg_h.c:    x1r = a[4] - a[20];
d_fftsg_h.c:    x1i = a[5] - a[21];
d_fftsg_h.c:    x3r = a[12] - a[28];
d_fftsg_h.c:    x3i = a[13] - a[29];
d_fftsg_h.c:    y6r = x0r - x2r;
d_fftsg_h.c:    y6i = x0i - x2i;
d_fftsg_h.c:    x0r = x1r - x3i;
d_fftsg_h.c:    y10r = wn4r * (x0r - x0i);
d_fftsg_h.c:    x0i = x1i - x3r;
d_fftsg_h.c:    y14i = wn4r * (x0i - x0r);
d_fftsg_h.c:    x1r = a[6] - a[22];
d_fftsg_h.c:    x1i = a[7] - a[23];
d_fftsg_h.c:    x3r = a[14] - a[30];
d_fftsg_h.c:    x3i = a[15] - a[31];
d_fftsg_h.c:    y7r = x0r - x2r;
d_fftsg_h.c:    y7i = x0i - x2i;
d_fftsg_h.c:    x0r = x1r - x3i;
d_fftsg_h.c:    y11r = wk1i * x0r - wk1r * x0i;
d_fftsg_h.c:    x0i = x1i - x3r;
d_fftsg_h.c:    y15r = wk1r * x0r - wk1i * x0i;
d_fftsg_h.c:    x0r = y12r - y14r;
d_fftsg_h.c:    x0i = y12i - y14i;
d_fftsg_h.c:    x2r = y13r - y15r;
d_fftsg_h.c:    x2i = y13i - y15i;
d_fftsg_h.c:    a[26] = x0r - x2r;
d_fftsg_h.c:    a[27] = x0i - x2i;
d_fftsg_h.c:    a[28] = x1r - x3i;
d_fftsg_h.c:    a[31] = x1i - x3r;
d_fftsg_h.c:    x1r = y8r - y10r;
d_fftsg_h.c:    x1i = y8i - y10i;
d_fftsg_h.c:    x3r = y9r - y11r;
d_fftsg_h.c:    x3i = y9i - y11i;
d_fftsg_h.c:    a[18] = x0r - x2r;
d_fftsg_h.c:    a[19] = x0i - x2i;
d_fftsg_h.c:    a[20] = x1r - x3i;
d_fftsg_h.c:    a[23] = x1i - x3r;
d_fftsg_h.c:    x0r = y5r - y7i;
d_fftsg_h.c:    x2r = wn4r * (x0r - x0i);
d_fftsg_h.c:    x0i = y5i - y7r;
d_fftsg_h.c:    x3r = wn4r * (x0r - x0i);
d_fftsg_h.c:    x0r = y4r - y6i;
d_fftsg_h.c:    x1i = y4i - y6r;
d_fftsg_h.c:    a[10] = x0r - x2r;
d_fftsg_h.c:    a[11] = x0i - x2i;
d_fftsg_h.c:    a[12] = x1r - x3i;
d_fftsg_h.c:    a[15] = x1i - x3r;
d_fftsg_h.c:    x1r = y0r - y2r;
d_fftsg_h.c:    x1i = y0i - y2i;
d_fftsg_h.c:    x3r = y1r - y3r;
d_fftsg_h.c:    x3i = y1i - y3i;
d_fftsg_h.c:    a[2] = x0r - x2r;
d_fftsg_h.c:    a[3] = x0i - x2i;
d_fftsg_h.c:    a[4] = x1r - x3i;
d_fftsg_h.c:    a[7] = x1i - x3r;
d_fftsg_h.c:    x1r = a[0] - a[17];
d_fftsg_h.c:    x0r = a[8] - a[25];
d_fftsg_h.c:    x2r = wn4r * (x0r - x0i);
d_fftsg_h.c:    y4r = x1r - x2r;
d_fftsg_h.c:    y4i = x1i - x2i;
d_fftsg_h.c:    x1i = a[1] - a[16];
d_fftsg_h.c:    x0i = a[9] - a[24];
d_fftsg_h.c:    x2r = wn4r * (x0r - x0i);
d_fftsg_h.c:    y8r = x1r - x2i;
d_fftsg_h.c:    y12i = x1i - x2r;
d_fftsg_h.c:    x0r = a[2] - a[19];
d_fftsg_h.c:    x1r = wk1r * x0r - wk1i * x0i;
d_fftsg_h.c:    x0r = a[10] - a[27];
d_fftsg_h.c:    x2r = wk3i * x0r - wk3r * x0i;
d_fftsg_h.c:    y5r = x1r - x2r;
d_fftsg_h.c:    y5i = x1i - x2i;
d_fftsg_h.c:    x0i = a[3] - a[18];
d_fftsg_h.c:    x1r = wk3r * x0r - wk3i * x0i;
d_fftsg_h.c:    x0i = a[11] - a[26];
d_fftsg_h.c:    x2i = wk1r * x0i - wk1i * x0r;
d_fftsg_h.c:    y9r = x1r - x2r;
d_fftsg_h.c:    y9i = x1i - x2i;
d_fftsg_h.c:    x0r = a[4] - a[21];
d_fftsg_h.c:    x1r = wk2r * x0r - wk2i * x0i;
d_fftsg_h.c:    x0r = a[12] - a[29];
d_fftsg_h.c:    x2r = wk2i * x0r - wk2r * x0i;
d_fftsg_h.c:    y6r = x1r - x2r;
d_fftsg_h.c:    y6i = x1i - x2i;
d_fftsg_h.c:    x0i = a[5] - a[20];
d_fftsg_h.c:    x1r = wk2i * x0r - wk2r * x0i;
d_fftsg_h.c:    x0i = a[13] - a[28];
d_fftsg_h.c:    x2r = wk2r * x0r - wk2i * x0i;
d_fftsg_h.c:    y10r = x1r - x2r;
d_fftsg_h.c:    y10i = x1i - x2i;
d_fftsg_h.c:    x0r = a[6] - a[23];
d_fftsg_h.c:    x1r = wk3r * x0r - wk3i * x0i;
d_fftsg_h.c:    x0r = a[14] - a[31];
d_fftsg_h.c:    x2r = wk1i * x0r - wk1r * x0i;
d_fftsg_h.c:    y7r = x1r - x2r;
d_fftsg_h.c:    y7i = x1i - x2i;
d_fftsg_h.c:    x0i = a[7] - a[22];
d_fftsg_h.c:    x1i = wk1i * x0i - wk1r * x0r;
d_fftsg_h.c:    x0i = a[15] - a[30];
d_fftsg_h.c:    x2r = wk3i * x0r - wk3r * x0i;
d_fftsg_h.c:    y15r = x1r - x2r;
d_fftsg_h.c:    y15i = x1i - x2i;
d_fftsg_h.c:    a[2] = x1r - x2r;
d_fftsg_h.c:    a[3] = x1i - x2i;
d_fftsg_h.c:    x1r = y0r - y2r;
d_fftsg_h.c:    x1i = y0i - y2i;
d_fftsg_h.c:    x2r = y1r - y3r;
d_fftsg_h.c:    x2i = y1i - y3i;
d_fftsg_h.c:    a[4] = x1r - x2i;
d_fftsg_h.c:    a[7] = x1i - x2r;
d_fftsg_h.c:    x1r = y4r - y6i;
d_fftsg_h.c:    x0r = y5r - y7i;
d_fftsg_h.c:    x2r = wn4r * (x0r - x0i);
d_fftsg_h.c:    a[10] = x1r - x2r;
d_fftsg_h.c:    a[11] = x1i - x2i;
d_fftsg_h.c:    x1i = y4i - y6r;
d_fftsg_h.c:    x0i = y5i - y7r;
d_fftsg_h.c:    x2r = wn4r * (x0r - x0i);
d_fftsg_h.c:    a[12] = x1r - x2i;
d_fftsg_h.c:    a[15] = x1i - x2r;
d_fftsg_h.c:    x2r = y9r - y11r;
d_fftsg_h.c:    x2i = y9i - y11i;
d_fftsg_h.c:    a[18] = x1r - x2r;
d_fftsg_h.c:    a[19] = x1i - x2i;
d_fftsg_h.c:    x1r = y8r - y10r;
d_fftsg_h.c:    x1i = y8i - y10i;
d_fftsg_h.c:    a[20] = x1r - x2i;
d_fftsg_h.c:    a[23] = x1i - x2r;
d_fftsg_h.c:    x1r = y12r - y14i;
d_fftsg_h.c:    x0i = y13i - y15r;
d_fftsg_h.c:    x2r = wn4r * (x0r - x0i);
d_fftsg_h.c:    a[26] = x1r - x2r;
d_fftsg_h.c:    a[27] = x1i - x2i;
d_fftsg_h.c:    x1i = y12i - y14r;
d_fftsg_h.c:    x0r = y13r - y15i;
d_fftsg_h.c:    x2r = wn4r * (x0r - x0i);
d_fftsg_h.c:    a[28] = x1r - x2i;
d_fftsg_h.c:    a[31] = x1i - x2r;
d_fftsg_h.c:    x1r = a[0] - a[8];
d_fftsg_h.c:    x1i = a[1] - a[9];
d_fftsg_h.c:    x3r = a[4] - a[12];
d_fftsg_h.c:    x3i = a[5] - a[13];
d_fftsg_h.c:    y2r = x0r - x2r;
d_fftsg_h.c:    y2i = x0i - x2i;
d_fftsg_h.c:    y1r = x1r - x3i;
d_fftsg_h.c:    y3i = x1i - x3r;
d_fftsg_h.c:    x1r = a[2] - a[10];
d_fftsg_h.c:    x1i = a[3] - a[11];
d_fftsg_h.c:    x3r = a[6] - a[14];
d_fftsg_h.c:    x3i = a[7] - a[15];
d_fftsg_h.c:    y6r = x0r - x2r;
d_fftsg_h.c:    y6i = x0i - x2i;
d_fftsg_h.c:    x0r = x1r - x3i;
d_fftsg_h.c:    x2i = x1i - x3r;
d_fftsg_h.c:    y5r = wn4r * (x0r - x0i);
d_fftsg_h.c:    y7r = wn4r * (x2r - x2i);
d_fftsg_h.c:    a[10] = y1r - y5r;
d_fftsg_h.c:    a[11] = y1i - y5i;
d_fftsg_h.c:    a[12] = y3r - y7i;
d_fftsg_h.c:    a[15] = y3i - y7r;
d_fftsg_h.c:    a[2] = y0r - y4r;
d_fftsg_h.c:    a[3] = y0i - y4i;
d_fftsg_h.c:    a[4] = y2r - y6i;
d_fftsg_h.c:    a[7] = y2i - y6r;
d_fftsg_h.c:    y0r = a[0] - a[9];
d_fftsg_h.c:    y1i = a[1] - a[8];
d_fftsg_h.c:    x0r = a[4] - a[13];
d_fftsg_h.c:    y2r = wn4r * (x0r - x0i);
d_fftsg_h.c:    x0i = a[5] - a[12];
d_fftsg_h.c:    y3r = wn4r * (x0r - x0i);
d_fftsg_h.c:    x0r = a[2] - a[11];
d_fftsg_h.c:    y4r = wk1r * x0r - wk1i * x0i;
d_fftsg_h.c:    x0i = a[3] - a[10];
d_fftsg_h.c:    y5r = wk1i * x0r - wk1r * x0i;
d_fftsg_h.c:    x0r = a[6] - a[15];
d_fftsg_h.c:    y6r = wk1i * x0r - wk1r * x0i;
d_fftsg_h.c:    x0i = a[7] - a[14];
d_fftsg_h.c:    y7r = wk1r * x0r - wk1i * x0i;
d_fftsg_h.c:    a[2] = x0r - x1r;
d_fftsg_h.c:    a[3] = x0i - x1i;
d_fftsg_h.c:    x0r = y0r - y2r;
d_fftsg_h.c:    x0i = y0i - y2i;
d_fftsg_h.c:    x1r = y4r - y6r;
d_fftsg_h.c:    x1i = y4i - y6i;
d_fftsg_h.c:    a[4] = x0r - x1i;
d_fftsg_h.c:    a[7] = x0i - x1r;
d_fftsg_h.c:    x0r = y1r - y3i;
d_fftsg_h.c:    x1r = y5r - y7r;
d_fftsg_h.c:    x1i = y5i - y7i;
d_fftsg_h.c:    a[10] = x0r - x1r;
d_fftsg_h.c:    a[11] = x0i - x1i;
d_fftsg_h.c:    x0i = y1i - y3r;
d_fftsg_h.c:    a[12] = x0r - x1i;
d_fftsg_h.c:    a[15] = x0i - x1r;
d_fftsg_h.c:    x1r = a[0] - a[4];
d_fftsg_h.c:    x1i = a[1] - a[5];
d_fftsg_h.c:    x3r = a[2] - a[6];
d_fftsg_h.c:    x3i = a[3] - a[7];
d_fftsg_h.c:    a[2] = x1r - x3i;
d_fftsg_h.c:    a[4] = x0r - x2r;
d_fftsg_h.c:    a[5] = x0i - x2i;
d_fftsg_h.c:    a[7] = x1i - x3r;
d_fftsg_h.c:    x1r = a[0] - a[4];
d_fftsg_h.c:    x1i = a[1] - a[5];
d_fftsg_h.c:    x3r = a[2] - a[6];
d_fftsg_h.c:    x3i = a[3] - a[7];
d_fftsg_h.c:    a[3] = x1i - x3r;
d_fftsg_h.c:    a[4] = x0r - x2r;
d_fftsg_h.c:    a[5] = x0i - x2i;
d_fftsg_h.c:    a[6] = x1r - x3i;
d_fftsg_h.c:    x0r = a[0] - a[2];
d_fftsg_h.c:    x0i = a[1] - a[3];
d_fftsg_h.c:    w1r = 1 - 2 * wdr;
d_fftsg_h.c:        i0 = i - 4 * RDFT_LOOP_DIV;
d_fftsg_h.c:        for (j = i - 4; j >= i0; j -= 4) {
d_fftsg_h.c:            k = n - j;
d_fftsg_h.c:            xr = a[j + 2] - a[k - 2];
d_fftsg_h.c:            xi = a[j + 3] + a[k - 1];
d_fftsg_h.c:            yr = wdr * xr - wdi * xi;
d_fftsg_h.c:            a[j + 2] -= yr;
d_fftsg_h.c:            a[j + 3] -= yi;
d_fftsg_h.c:            a[k - 2] += yr;
d_fftsg_h.c:            a[k - 1] -= yi;
d_fftsg_h.c:            wki += ss * (0.5 - wdr);
d_fftsg_h.c:            xr = a[j] - a[k];
d_fftsg_h.c:            yr = wkr * xr - wki * xi;
d_fftsg_h.c:            a[j] -= yr;
d_fftsg_h.c:            a[j + 1] -= yi;
d_fftsg_h.c:            a[k + 1] -= yi;
d_fftsg_h.c:            wdi += ss * (0.5 - wkr);
d_fftsg_h.c:        wdr = 0.5 - (wkr * w1r - wki * w1i);
d_fftsg_h.c:        wkr = 0.5 - wkr;
d_fftsg_h.c:    xr = a[2] - a[n - 2];
d_fftsg_h.c:    xi = a[3] + a[n - 1];
d_fftsg_h.c:    yr = wdr * xr - wdi * xi;
d_fftsg_h.c:    a[2] -= yr;
d_fftsg_h.c:    a[3] -= yi;
d_fftsg_h.c:    a[n - 2] += yr;
d_fftsg_h.c:    a[n - 1] -= yi;
d_fftsg_h.c:    w1r = 1 - 2 * wdr;
d_fftsg_h.c:        i0 = i - 4 * RDFT_LOOP_DIV;
d_fftsg_h.c:        for (j = i - 4; j >= i0; j -= 4) {
d_fftsg_h.c:            k = n - j;
d_fftsg_h.c:            xr = a[j + 2] - a[k - 2];
d_fftsg_h.c:            xi = a[j + 3] + a[k - 1];
d_fftsg_h.c:            yi = wdr * xi - wdi * xr;
d_fftsg_h.c:            a[j + 2] -= yr;
d_fftsg_h.c:            a[j + 3] -= yi;
d_fftsg_h.c:            a[k - 2] += yr;
d_fftsg_h.c:            a[k - 1] -= yi;
d_fftsg_h.c:            wki += ss * (0.5 - wdr);
d_fftsg_h.c:            xr = a[j] - a[k];
d_fftsg_h.c:            yi = wkr * xi - wki * xr;
d_fftsg_h.c:            a[j] -= yr;
d_fftsg_h.c:            a[j + 1] -= yi;
d_fftsg_h.c:            a[k + 1] -= yi;
d_fftsg_h.c:            wdi += ss * (0.5 - wkr);
d_fftsg_h.c:        wdr = 0.5 - (wkr * w1r - wki * w1i);
d_fftsg_h.c:        wkr = 0.5 - wkr;
d_fftsg_h.c:    xr = a[2] - a[n - 2];
d_fftsg_h.c:    xi = a[3] + a[n - 1];
d_fftsg_h.c:    yi = wdr * xi - wdi * xr;
d_fftsg_h.c:    a[2] -= yr;
d_fftsg_h.c:    a[3] -= yi;
d_fftsg_h.c:    a[n - 2] += yr;
d_fftsg_h.c:    a[n - 1] -= yi;
d_fftsg_h.c:    wdr = 0.5 * (w1r - w1i);
d_fftsg_h.c:        if (i0 > m - 2) {
d_fftsg_h.c:            i0 = m - 2;
d_fftsg_h.c:            k = n - j;
d_fftsg_h.c:            xr = wdi * a[j - 1] - wdr * a[k + 1];
d_fftsg_h.c:            xi = wdr * a[j - 1] + wdi * a[k + 1];
d_fftsg_h.c:            wkr -= ss * wdi;
d_fftsg_h.c:            yr = wki * a[j] - wkr * a[k];
d_fftsg_h.c:            wdr -= ss * wki;
d_fftsg_h.c:            a[j - 1] = xi;
d_fftsg_h.c:        if (i0 == m - 2) {
d_fftsg_h.c:        wkr = 0.5 * (wdr - wdi);
d_fftsg_h.c:        wdr = wkr * w1r - wki * w1i;
d_fftsg_h.c:    xr = wdi * a[m - 1] - wdr * a[m + 1];
d_fftsg_h.c:    a[m - 1] = wdr * a[m - 1] + wdi * a[m + 1];
d_fftsg_h.c:    wdr = 0.5 * (w1r - w1i);
d_fftsg_h.c:        if (i0 > m - 2) {
d_fftsg_h.c:            i0 = m - 2;
d_fftsg_h.c:            k = n - j;
d_fftsg_h.c:            xr = wdi * a[k + 1] - wdr * a[j - 1];
d_fftsg_h.c:            xi = wdr * a[k + 1] + wdi * a[j - 1];
d_fftsg_h.c:            wkr -= ss * wdi;
d_fftsg_h.c:            yr = wki * a[k] - wkr * a[j];
d_fftsg_h.c:            wdr -= ss * wki;
d_fftsg_h.c:            a[j - 1] = xr;
d_fftsg_h.c:        if (i0 == m - 2) {
d_fftsg_h.c:        wkr = 0.5 * (wdr - wdi);
d_fftsg_h.c:        wdr = wkr * w1r - wki * w1i;
d_fftsg_h.c:    xr = wdi * a[m + 1] - wdr * a[m - 1];
d_fftsg_h.c:    a[m + 1] = wdr * a[m + 1] + wdi * a[m - 1];
d_fftsg_h.c:    a[m - 1] = xr;
d_fftsg_h.c:        xr = wdi * a[1] - wdr * a[3];
d_fftsg_h.c:        xr = wdi * a[3] - wdr * a[1];
d_filter.c:/* Copyright (c) 1997-1999 Miller Puckette.
d_filter.c:/* ---------------- hip~ - 1-pole 1-zero hipass filter. ----------------- */
d_filter.c:    inlet_new(&x->x_obj, &x->x_obj.ob_pd, gensym("float"), gensym("ft1"));
d_filter.c:    outlet_new(&x->x_obj, &s_signal);
d_filter.c:    x->x_sr = 44100;
d_filter.c:    x->x_ctl = &x->x_cspace;
d_filter.c:    x->x_cspace.c_x = 0;
d_filter.c:    x->x_f = 0;
d_filter.c:    x->x_hz = f;
d_filter.c:    x->x_ctl->c_coef = 1 - f * (2 * 3.14159) / x->x_sr;
d_filter.c:    if (x->x_ctl->c_coef < 0)
d_filter.c:        x->x_ctl->c_coef = 0;
d_filter.c:    else if (x->x_ctl->c_coef > 1)
d_filter.c:        x->x_ctl->c_coef = 1;
d_filter.c:    t_sample last = c->c_x;
d_filter.c:    t_sample coef = c->c_coef;
d_filter.c:            *out++ = normal * (new - last);
d_filter.c:        c->c_x = last;
d_filter.c:        c->c_x = 0;
d_filter.c:    t_sample last = c->c_x;
d_filter.c:    t_sample coef = c->c_coef;
d_filter.c:            *out++ = new - last;
d_filter.c:        c->c_x = last;
d_filter.c:        c->c_x = 0;
d_filter.c:    x->x_sr = sp[0]->s_sr;
d_filter.c:    sighip_ft1(x,  x->x_hz);
d_filter.c:            4, sp[0]->s_vec, sp[1]->s_vec, x->x_ctl, sp[0]->s_n);
d_filter.c:    x->x_cspace.c_x = 0;
d_filter.c:/* ---------------- lop~ - 1-pole lopass filter. ----------------- */
d_filter.c:    inlet_new(&x->x_obj, &x->x_obj.ob_pd, gensym("float"), gensym("ft1"));
d_filter.c:    outlet_new(&x->x_obj, &s_signal);
d_filter.c:    x->x_sr = 44100;
d_filter.c:    x->x_ctl = &x->x_cspace;
d_filter.c:    x->x_cspace.c_x = 0;
d_filter.c:    x->x_f = 0;
d_filter.c:    x->x_hz = f;
d_filter.c:    x->x_ctl->c_coef = f * (2 * 3.14159) / x->x_sr;
d_filter.c:    if (x->x_ctl->c_coef > 1)
d_filter.c:        x->x_ctl->c_coef = 1;
d_filter.c:    else if (x->x_ctl->c_coef < 0)
d_filter.c:        x->x_ctl->c_coef = 0;
d_filter.c:    x->x_cspace.c_x = 0;
d_filter.c:    t_sample last = c->c_x;
d_filter.c:    t_sample coef = c->c_coef;
d_filter.c:    t_sample feedback = 1 - coef;
d_filter.c:    c->c_x = last;
d_filter.c:    x->x_sr = sp[0]->s_sr;
d_filter.c:    siglop_ft1(x,  x->x_hz);
d_filter.c:        sp[0]->s_vec, sp[1]->s_vec, 
d_filter.c:            x->x_ctl, sp[0]->s_n);
d_filter.c:/* ---------------- bp~ - 2-pole bandpass filter. ----------------- */
d_filter.c:    inlet_new(&x->x_obj, &x->x_obj.ob_pd, gensym("float"), gensym("ft1"));
d_filter.c:    inlet_new(&x->x_obj, &x->x_obj.ob_pd, gensym("float"), gensym("ft2"));
d_filter.c:    outlet_new(&x->x_obj, &s_signal);
d_filter.c:    x->x_sr = 44100;
d_filter.c:    x->x_ctl = &x->x_cspace;
d_filter.c:    x->x_cspace.c_x1 = 0;
d_filter.c:    x->x_cspace.c_x2 = 0;
d_filter.c:    x->x_f = 0;
d_filter.c:    if (f >= -(0.5f*3.14159f) && f <= 0.5f*3.14159f)
d_filter.c:        return (((g*g*g * (-1.0f/720.0f) + g*g*(1.0f/24.0f)) - g*0.5) + 1);
d_filter.c:    x->x_freq = f;
d_filter.c:    x->x_q = q;
d_filter.c:    omega = f * (2.0f * 3.14159f) / x->x_sr;
d_filter.c:    r = 1.0f - oneminusr;
d_filter.c:    x->x_ctl->c_coef1 = 2.0f * sigbp_qcos(omega) * r;
d_filter.c:    x->x_ctl->c_coef2 = - r * r;
d_filter.c:    x->x_ctl->c_gain = 2 * oneminusr * (oneminusr + r * omega);
d_filter.c:        r, omega, x->x_ctl->c_coef1, x->x_ctl->c_coef2); */
d_filter.c:    sigbp_docoef(x, f, x->x_q);
d_filter.c:    sigbp_docoef(x, x->x_freq, q);
d_filter.c:    x->x_ctl->c_x1 = x->x_ctl->c_x2 = 0;
d_filter.c:    t_sample last = c->c_x1;
d_filter.c:    t_sample prev = c->c_x2;
d_filter.c:    t_sample coef1 = c->c_coef1;
d_filter.c:    t_sample coef2 = c->c_coef2;
d_filter.c:    t_sample gain = c->c_gain;
d_filter.c:    c->c_x1 = last;
d_filter.c:    c->c_x2 = prev;
d_filter.c:    x->x_sr = sp[0]->s_sr;
d_filter.c:    sigbp_docoef(x, x->x_freq, x->x_q);
d_filter.c:        sp[0]->s_vec, sp[1]->s_vec, 
d_filter.c:            x->x_ctl, sp[0]->s_n);
d_filter.c:/* ---------------- biquad~ - raw biquad filter ----------------- */
d_filter.c:    outlet_new(&x->x_obj, &s_signal);
d_filter.c:    x->x_ctl = &x->x_cspace;
d_filter.c:    x->x_cspace.c_x1 = x->x_cspace.c_x2 = 0;
d_filter.c:    x->x_f = 0;
d_filter.c:    t_sample last = c->c_x1;
d_filter.c:    t_sample prev = c->c_x2;
d_filter.c:    t_sample fb1 = c->c_fb1;
d_filter.c:    t_sample fb2 = c->c_fb2;
d_filter.c:    t_sample ff1 = c->c_ff1;
d_filter.c:    t_sample ff2 = c->c_ff2;
d_filter.c:    t_sample ff3 = c->c_ff3;
d_filter.c:    c->c_x1 = last;
d_filter.c:    c->c_x2 = prev;
d_filter.c:    t_biquadctl *c = x->x_ctl;
d_filter.c:    if (discriminant < 0) /* imaginary roots -- resonant filter */
d_filter.c:        if (fb2 >= -1.0f) goto stable;
d_filter.c:            /* check that the parabola 1 - fb1 x - fb2 x^2 has a
d_filter.c:                vertex between -1 and 1, and that it's nonnegative
d_filter.c:                at both ends, which implies both roots are in [1-,1]. */
d_filter.c:        if (fb1 <= 2.0f && fb1 >= -2.0f &&
d_filter.c:            1.0f - fb1 -fb2 >= 0 && 1.0f + fb1 - fb2 >= 0)
d_filter.c:    c->c_fb1 = fb1;
d_filter.c:    c->c_fb2 = fb2;
d_filter.c:    c->c_ff1 = ff1;
d_filter.c:    c->c_ff2 = ff2;
d_filter.c:    c->c_ff3 = ff3;
d_filter.c:    t_biquadctl *c = x->x_ctl;
d_filter.c:    c->c_x1 = atom_getfloatarg(0, argc, argv);
d_filter.c:    c->c_x2 = atom_getfloatarg(1, argc, argv);
d_filter.c:        sp[0]->s_vec, sp[1]->s_vec, 
d_filter.c:            x->x_ctl, sp[0]->s_n);
d_filter.c:/* ---------------- samphold~ - sample and hold  ----------------- */
d_filter.c:    inlet_new(&x->x_obj, &x->x_obj.ob_pd, &s_signal, &s_signal);
d_filter.c:    outlet_new(&x->x_obj, &s_signal);
d_filter.c:    x->x_lastin = 0;
d_filter.c:    x->x_lastout = 0;
d_filter.c:    x->x_f = 0;
d_filter.c:    t_sample lastin = x->x_lastin;
d_filter.c:    t_sample lastout = x->x_lastout;
d_filter.c:    x->x_lastin = lastin;
d_filter.c:    x->x_lastout = lastout;
d_filter.c:        sp[0]->s_vec, sp[1]->s_vec, sp[2]->s_vec, 
d_filter.c:            x, sp[0]->s_n);
d_filter.c:    x->x_lastin = ((argc > 0 && (argv[0].a_type == A_FLOAT)) ?
d_filter.c:    x->x_lastout = f;
d_filter.c:/* ---------------- rpole~ - real one-pole filter (raw) ----------------- */
d_filter.c:        (t_pd *)inlet_new(&x->x_obj, &x->x_obj.ob_pd, &s_signal, &s_signal),
d_filter.c:    outlet_new(&x->x_obj, &s_signal);
d_filter.c:    x->x_last = 0;
d_filter.c:    t_sample last = x->x_last;
d_filter.c:    x->x_last = last;
d_filter.c:        sp[0]->s_vec, sp[1]->s_vec, sp[2]->s_vec, 
d_filter.c:            x, sp[0]->s_n);
d_filter.c:    x->x_last = 0;
d_filter.c:    x->x_last = f;
d_filter.c:/* ---------------- rzero~ - real one-zero filter (raw) ----------------- */
d_filter.c:        (t_pd *)inlet_new(&x->x_obj, &x->x_obj.ob_pd, &s_signal, &s_signal),
d_filter.c:    outlet_new(&x->x_obj, &s_signal);
d_filter.c:    x->x_last = 0;
d_filter.c:    t_sample last = x->x_last;
d_filter.c:        *out++ = next - coef * last;
d_filter.c:    x->x_last = last;
d_filter.c:        sp[0]->s_vec, sp[1]->s_vec, sp[2]->s_vec, 
d_filter.c:            x, sp[0]->s_n);
d_filter.c:    x->x_last = 0;
d_filter.c:    x->x_last = f;
d_filter.c:/* ---------- rzero_rev~ - real, reverse one-zero filter (raw) ------------ */
d_filter.c:        (t_pd *)inlet_new(&x->x_obj, &x->x_obj.ob_pd, &s_signal, &s_signal),
d_filter.c:    outlet_new(&x->x_obj, &s_signal);
d_filter.c:    x->x_last = 0;
d_filter.c:    t_sample last = x->x_last;
d_filter.c:        *out++ = last - coef * next;
d_filter.c:    x->x_last = last;
d_filter.c:        sp[0]->s_vec, sp[1]->s_vec, sp[2]->s_vec, 
d_filter.c:            x, sp[0]->s_n);
d_filter.c:    x->x_last = 0;
d_filter.c:    x->x_last = f;
d_filter.c:/* -------------- cpole~ - complex one-pole filter (raw) --------------- */
d_filter.c:    inlet_new(&x->x_obj, &x->x_obj.ob_pd, &s_signal, &s_signal);
d_filter.c:        (t_pd *)inlet_new(&x->x_obj, &x->x_obj.ob_pd, &s_signal, &s_signal),
d_filter.c:        (t_pd *)inlet_new(&x->x_obj, &x->x_obj.ob_pd, &s_signal, &s_signal),
d_filter.c:    outlet_new(&x->x_obj, &s_signal);
d_filter.c:    outlet_new(&x->x_obj, &s_signal);
d_filter.c:    x->x_lastre = x->x_lastim = 0;
d_filter.c:    x->x_f = 0;
d_filter.c:    t_sample lastre = x->x_lastre;
d_filter.c:    t_sample lastim = x->x_lastim;
d_filter.c:        t_sample tempre = *outre++ = nextre + lastre * coefre - lastim * coefim;
d_filter.c:    x->x_lastre = lastre;
d_filter.c:    x->x_lastim = lastim;
d_filter.c:        sp[0]->s_vec, sp[1]->s_vec, sp[2]->s_vec, sp[3]->s_vec, 
d_filter.c:        sp[4]->s_vec, sp[5]->s_vec, x, sp[0]->s_n);
d_filter.c:    x->x_lastre = x->x_lastim = 0;
d_filter.c:    x->x_lastre = re;
d_filter.c:    x->x_lastim = im;
d_filter.c:/* -------------- czero~ - complex one-pole filter (raw) --------------- */
d_filter.c:    inlet_new(&x->x_obj, &x->x_obj.ob_pd, &s_signal, &s_signal);
d_filter.c:        (t_pd *)inlet_new(&x->x_obj, &x->x_obj.ob_pd, &s_signal, &s_signal),
d_filter.c:        (t_pd *)inlet_new(&x->x_obj, &x->x_obj.ob_pd, &s_signal, &s_signal),
d_filter.c:    outlet_new(&x->x_obj, &s_signal);
d_filter.c:    outlet_new(&x->x_obj, &s_signal);
d_filter.c:    x->x_lastre = x->x_lastim = 0;
d_filter.c:    x->x_f = 0;
d_filter.c:    t_sample lastre = x->x_lastre;
d_filter.c:    t_sample lastim = x->x_lastim;
d_filter.c:        *outre++ = nextre - lastre * coefre + lastim * coefim;
d_filter.c:        *outim++ = nextim - lastre * coefim - lastim * coefre;
d_filter.c:    x->x_lastre = lastre;
d_filter.c:    x->x_lastim = lastim;
d_filter.c:        sp[0]->s_vec, sp[1]->s_vec, sp[2]->s_vec, sp[3]->s_vec, 
d_filter.c:        sp[4]->s_vec, sp[5]->s_vec, x, sp[0]->s_n);
d_filter.c:    x->x_lastre = x->x_lastim = 0;
d_filter.c:    x->x_lastre = re;
d_filter.c:    x->x_lastim = im;
d_filter.c:/* -------------- czero_rev~ - complex one-pole filter (raw) --------------- */
d_filter.c:    inlet_new(&x->x_obj, &x->x_obj.ob_pd, &s_signal, &s_signal);
d_filter.c:        (t_pd *)inlet_new(&x->x_obj, &x->x_obj.ob_pd, &s_signal, &s_signal),
d_filter.c:        (t_pd *)inlet_new(&x->x_obj, &x->x_obj.ob_pd, &s_signal, &s_signal),
d_filter.c:    outlet_new(&x->x_obj, &s_signal);
d_filter.c:    outlet_new(&x->x_obj, &s_signal);
d_filter.c:    x->x_lastre = x->x_lastim = 0;
d_filter.c:    x->x_f = 0;
d_filter.c:    t_sample lastre = x->x_lastre;
d_filter.c:    t_sample lastim = x->x_lastim;
d_filter.c:            /* transfer function is (A bar) - Z^-1, for the same
d_filter.c:            frequency response as 1 - AZ^-1 from czero_tilde. */
d_filter.c:        *outre++ = lastre - nextre * coefre - nextim * coefim;
d_filter.c:        *outim++ = lastim - nextre * coefim + nextim * coefre;
d_filter.c:    x->x_lastre = lastre;
d_filter.c:    x->x_lastim = lastim;
d_filter.c:        sp[0]->s_vec, sp[1]->s_vec, sp[2]->s_vec, sp[3]->s_vec, 
d_filter.c:        sp[4]->s_vec, sp[5]->s_vec, x, sp[0]->s_n);
d_filter.c:    x->x_lastre = x->x_lastim = 0;
d_filter.c:    x->x_lastre = re;
d_filter.c:    x->x_lastim = im;
d_filter.c:/* ------------------------ setup routine ------------------------- */
d_global.c:/* Copyright (c) 1997-1999 Miller Puckette.
d_global.c:/* ----------------------------- send~ ----------------------------- */
d_global.c:    pd_bind(&x->x_obj.ob_pd, s);
d_global.c:    x->x_sym = s;
d_global.c:    x->x_n = DEFSENDVS;
d_global.c:    x->x_vec = (t_sample *)getbytes(DEFSENDVS * sizeof(t_sample));
d_global.c:    memset((char *)(x->x_vec), 0, DEFSENDVS * sizeof(t_sample));
d_global.c:    x->x_f = 0;
d_global.c:    while (n--)
d_global.c:    if (x->x_n == sp[0]->s_n)
d_global.c:        dsp_add(sigsend_perform, 3, sp[0]->s_vec, x->x_vec, sp[0]->s_n);
d_global.c:    else error("sigsend %s: unexpected vector size", x->x_sym->s_name);
d_global.c:    pd_unbind(&x->x_obj.ob_pd, x->x_sym);
d_global.c:    freebytes(x->x_vec, x->x_n * sizeof(t_sample));
d_global.c:/* ----------------------------- receive~ ----------------------------- */
d_global.c:    x->x_n = DEFSENDVS;             /* LATER find our vector size correctly */
d_global.c:    x->x_sym = s;
d_global.c:    x->x_wherefrom = 0;
d_global.c:    outlet_new(&x->x_obj, &s_signal);
d_global.c:    t_sample *in = x->x_wherefrom;
d_global.c:        while (n--)
d_global.c:        while (n--)
d_global.c:    t_sample *in = x->x_wherefrom;
d_global.c:        for (; n; n -= 8, in += 8, out += 8)
d_global.c:        for (; n; n -= 8, in += 8, out += 8)
d_global.c:    t_sigsend *sender = (t_sigsend *)pd_findbyclass((x->x_sym = s),
d_global.c:        if (sender->x_n == x->x_n)
d_global.c:            x->x_wherefrom = sender->x_vec;
d_global.c:            pd_error(x, "receive~ %s: vector size mismatch", x->x_sym->s_name);
d_global.c:            x->x_wherefrom = 0;
d_global.c:        pd_error(x, "receive~ %s: no matching send", x->x_sym->s_name);
d_global.c:        x->x_wherefrom = 0;
d_global.c:    if (sp[0]->s_n != x->x_n)
d_global.c:        pd_error(x, "receive~ %s: vector size mismatch", x->x_sym->s_name);
d_global.c:        sigreceive_set(x, x->x_sym);
d_global.c:        if (sp[0]->s_n&7)
d_global.c:                x, sp[0]->s_vec, sp[0]->s_n);
d_global.c:            x, sp[0]->s_vec, sp[0]->s_n);
d_global.c:/* ----------------------------- catch~ ----------------------------- */
d_global.c:    pd_bind(&x->x_obj.ob_pd, s);
d_global.c:    x->x_sym = s;
d_global.c:    x->x_n = DEFSENDVS;
d_global.c:    x->x_vec = (t_sample *)getbytes(DEFSENDVS * sizeof(t_sample));
d_global.c:    memset((char *)(x->x_vec), 0, DEFSENDVS * sizeof(t_sample));
d_global.c:    outlet_new(&x->x_obj, &s_signal);
d_global.c:    while (n--) *out++ = *in, *in++ = 0; 
d_global.c:    for (; n; n -= 8, in += 8, out += 8)
d_global.c:    if (x->x_n == sp[0]->s_n)
d_global.c:        if(sp[0]->s_n&7)
d_global.c:        dsp_add(sigcatch_perform, 3, x->x_vec, sp[0]->s_vec, sp[0]->s_n);
d_global.c:        dsp_add(sigcatch_perf8, 3, x->x_vec, sp[0]->s_vec, sp[0]->s_n);
d_global.c:    else error("sigcatch %s: unexpected vector size", x->x_sym->s_name);
d_global.c:    pd_unbind(&x->x_obj.ob_pd, x->x_sym);
d_global.c:    freebytes(x->x_vec, x->x_n * sizeof(t_sample));
d_global.c:/* ----------------------------- throw~ ----------------------------- */
d_global.c:    x->x_sym = s;
d_global.c:    x->x_whereto  = 0;
d_global.c:    x->x_n = DEFSENDVS;
d_global.c:    x->x_f = 0;
d_global.c:    t_sample *out = x->x_whereto;
d_global.c:        while (n--)
d_global.c:    t_sigcatch *catcher = (t_sigcatch *)pd_findbyclass((x->x_sym = s),
d_global.c:        if (catcher->x_n == x->x_n)
d_global.c:            x->x_whereto = catcher->x_vec;
d_global.c:            pd_error(x, "throw~ %s: vector size mismatch", x->x_sym->s_name);
d_global.c:            x->x_whereto = 0;
d_global.c:        pd_error(x, "throw~ %s: no matching catch", x->x_sym->s_name);
d_global.c:        x->x_whereto = 0;
d_global.c:    if (sp[0]->s_n != x->x_n)
d_global.c:        pd_error(x, "throw~ %s: vector size mismatch", x->x_sym->s_name);
d_global.c:        sigthrow_set(x, x->x_sym);
d_global.c:            x, sp[0]->s_vec, sp[0]->s_n);
d_global.c:/* ----------------------- global setup routine ---------------- */
d_math.c:/* Copyright (c) 1997-2001 Miller Puckette and others.
d_math.c:/* ------------------------- clip~ -------------------------- */
d_math.c:    x->x_lo = lo;
d_math.c:    x->x_hi = hi;
d_math.c:    outlet_new(&x->x_obj, gensym("signal"));
d_math.c:    floatinlet_new(&x->x_obj, &x->x_lo);
d_math.c:    floatinlet_new(&x->x_obj, &x->x_hi);
d_math.c:    x->x_f = 0;
d_math.c:    while (n--)
d_math.c:        if (f < x->x_lo) f = x->x_lo;
d_math.c:        if (f > x->x_hi) f = x->x_hi;
d_math.c:    dsp_add(clip_perform, 4, x, sp[0]->s_vec, sp[1]->s_vec, sp[0]->s_n);
d_math.c:/* sigrsqrt - reciprocal square root good to 8 mantissa bits  */
d_math.c:        int32_t l = (i ? (i == DUMTAB1SIZE-1 ? DUMTAB1SIZE-2 : i) : 1)<< 23;
d_math.c:    outlet_new(&x->x_obj, gensym("signal"));
d_math.c:    x->x_f = 0;
d_math.c:    while (n--)
d_math.c:            *out++ = 1.5 * g - 0.5 * g * g * g * f;
d_math.c:    dsp_add(sigrsqrt_perform, 3, sp[0]->s_vec, sp[1]->s_vec, sp[0]->s_n);
d_math.c:/* sigsqrt -  square root good to 8 mantissa bits  */
d_math.c:    outlet_new(&x->x_obj, gensym("signal"));
d_math.c:    x->x_f = 0;
d_math.c:    while (n--)
d_math.c:            *out++ = f * (1.5 * g - 0.5 * g * g * g * f);
d_math.c:    dsp_add(sigsqrt_perform, 3, sp[0]->s_vec, sp[1]->s_vec, sp[0]->s_n);
d_math.c:/* ------------------------------ wrap~ -------------------------- */
d_math.c:    outlet_new(&x->x_obj, gensym("signal"));
d_math.c:    x->x_f = 0;
d_math.c:    while (n--)
d_math.c:        if (f > 0) *out++ = f-k;
d_math.c:        else *out++ = f - (k-1);
d_math.c:    dsp_add(sigwrap_perform, 3, sp[0]->s_vec, sp[1]->s_vec, sp[0]->s_n);
d_math.c:/* ------------------------------ mtof_tilde~ -------------------------- */
d_math.c:    outlet_new(&x->x_obj, gensym("signal"));
d_math.c:    x->x_f = 0;
d_math.c:    for (; n--; in++, out++)
d_math.c:        if (f <= -1500) *out = 0;
d_math.c:    dsp_add(mtof_tilde_perform, 3, sp[0]->s_vec, sp[1]->s_vec, sp[0]->s_n);
d_math.c:/* ------------------------------ ftom_tilde~ -------------------------- */
d_math.c:    outlet_new(&x->x_obj, gensym("signal"));
d_math.c:    x->x_f = 0;
d_math.c:    for (; n--; in++, out++)
d_math.c:        *out = (f > 0 ? 17.3123405046 * log(.12231220585 * f) : -1500);
d_math.c:    dsp_add(ftom_tilde_perform, 3, sp[0]->s_vec, sp[1]->s_vec, sp[0]->s_n);
d_math.c:/* ------------------------------ dbtorms~ -------------------------- */
d_math.c:    outlet_new(&x->x_obj, gensym("signal"));
d_math.c:    x->x_f = 0;
d_math.c:    for (; n--; in++, out++)
d_math.c:            *out = exp((LOGTEN * 0.05) * (f-100.));
d_math.c:    dsp_add(dbtorms_tilde_perform, 3, sp[0]->s_vec, sp[1]->s_vec, sp[0]->s_n);
d_math.c:/* ------------------------------ rmstodb~ -------------------------- */
d_math.c:    outlet_new(&x->x_obj, gensym("signal"));
d_math.c:    x->x_f = 0;
d_math.c:    for (; n--; in++, out++)
d_math.c:    dsp_add(rmstodb_tilde_perform, 3, sp[0]->s_vec, sp[1]->s_vec, sp[0]->s_n);
d_math.c:/* ------------------------------ dbtopow~ -------------------------- */
d_math.c:    outlet_new(&x->x_obj, gensym("signal"));
d_math.c:    x->x_f = 0;
d_math.c:    for (; n--; in++, out++)
d_math.c:            *out = exp((LOGTEN * 0.1) * (f-100.));
d_math.c:    dsp_add(dbtopow_tilde_perform, 3, sp[0]->s_vec, sp[1]->s_vec, sp[0]->s_n);
d_math.c:/* ------------------------------ powtodb~ -------------------------- */
d_math.c:    outlet_new(&x->x_obj, gensym("signal"));
d_math.c:    x->x_f = 0;
d_math.c:    for (; n--; in++, out++)
d_math.c:    dsp_add(powtodb_tilde_perform, 3, sp[0]->s_vec, sp[1]->s_vec, sp[0]->s_n);
d_math.c:/* ----------------------------- pow ----------------------------- */
d_math.c:    inlet_new(&x->x_obj, &x->x_obj.ob_pd, &s_signal, &s_signal);
d_math.c:    outlet_new(&x->x_obj, &s_signal);
d_math.c:    x->x_f = 0;
d_math.c:    while (n--)
d_math.c:        sp[0]->s_vec, sp[1]->s_vec, sp[2]->s_vec, sp[0]->s_n);
d_math.c:/* ----------------------------- exp ----------------------------- */
d_math.c:    outlet_new(&x->x_obj, &s_signal);
d_math.c:    while (n--)
d_math.c:        sp[0]->s_vec, sp[1]->s_vec, sp[0]->s_n);
d_math.c:/* ----------------------------- log ----------------------------- */
d_math.c:    inlet_new(&x->x_obj, &x->x_obj.ob_pd, &s_signal, &s_signal);
d_math.c:    outlet_new(&x->x_obj, &s_signal);
d_math.c:    x->x_f = 0;
d_math.c:    while (n--)
d_math.c:            *out = -1000;   /* rather than blow up, output a number << 0 */
d_math.c:        sp[0]->s_vec, sp[1]->s_vec, sp[2]->s_vec, sp[0]->s_n);
d_math.c:/* ----------------------------- abs ----------------------------- */
d_math.c:    outlet_new(&x->x_obj, &s_signal);
d_math.c:    while (n--)
d_math.c:        *out++ = (f >= 0 ? f : -f);
d_math.c:        sp[0]->s_vec, sp[1]->s_vec, sp[0]->s_n);
d_math.c:/* ------------------------ global setup routine ------------------------- */
d_misc.c:/* Copyright (c) 1997-1999 Miller Puckette.
d_misc.c:/* ------------------------- print~ -------------------------- */
d_misc.c:    if (x->x_count)
d_misc.c:        startpost("%s:", x->x_sym->s_name);
d_misc.c:        x->x_count--;
d_misc.c:    dsp_add(print_perform, 3, x, sp[0]->s_vec, sp[0]->s_n);
d_misc.c:    x->x_count = f;
d_misc.c:    x->x_count = 1;
d_misc.c:    x->x_sym = (s->s_name[0]? s : gensym("print~"));
d_misc.c:    x->x_count = 0;
d_misc.c:    x->x_f = 0;
d_misc.c:/* ------------------------ bang~ -------------------------- */
d_misc.c:    clock_delay(x->x_clock, 0);
d_misc.c:    outlet_bang(x->x_obj.ob_outlet);
d_misc.c:    clock_free(x->x_clock);
d_misc.c:    x->x_clock = clock_new(x, (t_method)bang_tilde_tick);
d_misc.c:    outlet_new(&x->x_obj, &s_bang);
d_misc.c:/* ------------------------ global setup routine ------------------------- */
d_osc.c:/* Copyright (c) 1997-1999 Miller Puckette.
d_osc.c:/* -------------------------- phasor~ ------------------------------ */
d_osc.c:    x->x_f = f;
d_osc.c:    inlet_new(&x->x_obj, &x->x_obj.ob_pd, &s_float, gensym("ft1"));
d_osc.c:    x->x_phase = 0;
d_osc.c:    x->x_conv = 0;
d_osc.c:    outlet_new(&x->x_obj, gensym("signal"));
d_osc.c:    double dphase = x->x_phase + (double)UNITBIT32;
d_osc.c:    float conv = x->x_conv;
d_osc.c:    while (n--)
d_osc.c:        *out++ = tf.tf_d - UNITBIT32;
d_osc.c:    x->x_phase = tf.tf_d - UNITBIT32;
d_osc.c:    x->x_conv = 1./sp[0]->s_sr;
d_osc.c:    dsp_add(phasor_perform, 4, x, sp[0]->s_vec, sp[1]->s_vec, sp[0]->s_n);
d_osc.c:    x->x_phase = f;
d_osc.c:/* ------------------------ cos~ ----------------------------- */
d_osc.c:    outlet_new(&x->x_obj, gensym("signal"));
d_osc.c:    x->x_f = 0;
d_osc.c:    while (n--)
d_osc.c:        addr = tab + (tf.tf_i[HIOFFSET] & (COSTABSIZE-1));
d_osc.c:        frac = tf.tf_d - UNITBIT32;
d_osc.c:        *out++ = f1 + frac * (f2 - f1);
d_osc.c:        addr = tab + (tf.tf_i[HIOFFSET] & (COSTABSIZE-1));
d_osc.c:    while (--n)
d_osc.c:            frac = tf.tf_d - UNITBIT32;
d_osc.c:        addr = tab + (tf.tf_i[HIOFFSET] & (COSTABSIZE-1));
d_osc.c:            *out++ = f1 + frac * (f2 - f1);
d_osc.c:            frac = tf.tf_d - UNITBIT32;
d_osc.c:            *out++ = f1 + frac * (f2 - f1);
d_osc.c:    dsp_add(cos_perform, 3, sp[0]->s_vec, sp[1]->s_vec, sp[0]->s_n);
d_osc.c:    for (i = COSTABSIZE + 1, fp = cos_table, phase = 0; i--;
d_osc.c:/* ------------------------ osc~ ----------------------------- */
d_osc.c:    x->x_f = f;
d_osc.c:    outlet_new(&x->x_obj, gensym("signal"));
d_osc.c:    inlet_new(&x->x_obj, &x->x_obj.ob_pd, &s_float, gensym("ft1"));
d_osc.c:    x->x_phase = 0;
d_osc.c:    x->x_conv = 0;
d_osc.c:    double dphase = x->x_phase + UNITBIT32;
d_osc.c:    float conv = x->x_conv;
d_osc.c:    while (n--)
d_osc.c:        addr = tab + (tf.tf_i[HIOFFSET] & (COSTABSIZE-1));
d_osc.c:        frac = tf.tf_d - UNITBIT32;
d_osc.c:        *out++ = f1 + frac * (f2 - f1);
d_osc.c:        addr = tab + (tf.tf_i[HIOFFSET] & (COSTABSIZE-1));
d_osc.c:        frac = tf.tf_d - UNITBIT32;
d_osc.c:    while (--n)
d_osc.c:        addr = tab + (tf.tf_i[HIOFFSET] & (COSTABSIZE-1));
d_osc.c:            *out++ = f1 + frac * (f2 - f1);
d_osc.c:        frac = tf.tf_d - UNITBIT32;
d_osc.c:            *out++ = f1 + frac * (f2 - f1);
d_osc.c:    tf.tf_d = dphase + (UNITBIT32 * COSTABSIZE - UNITBIT32);
d_osc.c:    x->x_phase = tf.tf_d - UNITBIT32 * COSTABSIZE;
d_osc.c:    x->x_conv = COSTABSIZE/sp[0]->s_sr;
d_osc.c:    dsp_add(osc_perform, 4, x, sp[0]->s_vec, sp[1]->s_vec, sp[0]->s_n);
d_osc.c:    x->x_phase = COSTABSIZE * f;
d_osc.c:/* ---------------- vcf~ - 2-pole bandpass filter. ----------------- */
d_osc.c:    inlet_new(&x->x_obj, &x->x_obj.ob_pd, &s_signal, &s_signal);
d_osc.c:    inlet_new(&x->x_obj, &x->x_obj.ob_pd, gensym("float"), gensym("ft1"));
d_osc.c:    outlet_new(&x->x_obj, gensym("signal"));
d_osc.c:    outlet_new(&x->x_obj, gensym("signal"));
d_osc.c:    x->x_ctl = &x->x_cspace;
d_osc.c:    x->x_cspace.c_re = 0;
d_osc.c:    x->x_cspace.c_im = 0;
d_osc.c:    x->x_cspace.c_q = q;
d_osc.c:    x->x_cspace.c_isr = 0;
d_osc.c:    x->x_f = 0;
d_osc.c:    x->x_ctl->c_q = (f > 0 ? f : 0.f);
d_osc.c:    float re = c->c_re, re2;
d_osc.c:    float im = c->c_im;
d_osc.c:    float q = c->c_q;
d_osc.c:    float ampcorrect = 2.0f - 2.0f / (q + 2.0f);
d_osc.c:    float isr = c->c_isr;
d_osc.c:        r = (qinv > 0 ? 1 - cf * qinv : 0);
d_osc.c:        oneminusr = 1.0f - r;
d_osc.c:        tabindex = tf.tf_i[HIOFFSET] & (COSTABSIZE-1);
d_osc.c:        frac = tf.tf_d - UNITBIT32;
d_osc.c:        coefr = r * (f1 + frac * (f2 - f1));
d_osc.c:        addr = tab + ((tabindex - (COSTABSIZE/4)) & (COSTABSIZE-1));
d_osc.c:        coefi = r * (f1 + frac * (f2 - f1));
d_osc.c:            + coefr * re2 - coefi * im;
d_osc.c:    c->c_re = re;
d_osc.c:    c->c_im = im;
d_osc.c:    x->x_ctl->c_isr = 6.28318f/sp[0]->s_sr;
d_osc.c:        sp[0]->s_vec, sp[1]->s_vec, sp[2]->s_vec, sp[3]->s_vec, 
d_osc.c:            x->x_ctl, sp[0]->s_n);
d_osc.c:/* -------------------------- noise~ ------------------------------ */
d_osc.c:    x->x_val = (init *= 1319); 
d_osc.c:    outlet_new(&x->x_obj, gensym("signal"));
d_osc.c:    while (n--)
d_osc.c:        *out++ = ((float)((val & 0x7fffffff) - 0x40000000)) *
d_osc.c:    dsp_add(noise_perform, 3, sp[0]->s_vec, &x->x_val, sp[0]->s_n);
d_osc.c:/* ----------------------- global setup routine ---------------- */
d_resample.c:/* Copyright (c) 1997-1999 Miller Puckette.
d_resample.c:/* --------------------- up/down-sampling --------------------- */
d_resample.c:  while(n--){
d_resample.c:  while(n--)*out++=0;
d_resample.c:  while(n--){
d_resample.c:  while (i--) {
d_resample.c:    while(n--){
d_resample.c:  t_sample a=*x->buffer, b=*in;
d_resample.c:    t_sample frac=findex - index;
d_resample.c:    *out++ = frac * b + (1.-frac) * a;
d_resample.c:    a=(index)?*(fp-1):a;
d_resample.c:  *x->buffer = a;
d_resample.c:/* ----------------------- public -------------------------------- */
d_resample.c:  x->method=0;
d_resample.c:  x->downsample=x->upsample=1;
d_resample.c:  x->s_n = x->coefsize = x->bufsize = 0;
d_resample.c:  x->s_vec = x->coeffs = x->buffer  = 0;
d_resample.c:  if (x->s_n) t_freebytes(x->s_vec, x->s_n*sizeof(*x->s_vec));
d_resample.c:  if (x->coefsize) t_freebytes(x->coeffs, x->coefsize*sizeof(*x->coeffs));
d_resample.c:  if (x->bufsize) t_freebytes(x->buffer, x->bufsize*sizeof(*x->buffer));
d_resample.c:  x->s_n = x->coefsize = x->bufsize = 0;
d_resample.c:  x->s_vec = x->coeffs = x->buffer  = 0;
d_resample.c:/* dsp-adding */
d_resample.c:      if (x->bufsize != 1) {
d_resample.c:        t_freebytes(x->buffer, x->bufsize*sizeof(*x->buffer));
d_resample.c:        x->bufsize = 1;
d_resample.c:        x->buffer = t_getbytes(x->bufsize*sizeof(*x->buffer));
d_resample.c:   t_freebytes(x->s_vec, x->s_n * sizeof(*x->s_vec));
d_resample.c:    x->s_n = 0;
d_resample.c:    x->s_vec = in;
d_resample.c:  if (x->s_n != outsize) {
d_resample.c:    t_sample *buf=x->s_vec;
d_resample.c:    t_freebytes(buf, x->s_n * sizeof(*buf));
d_resample.c:    x->s_vec = buf;
d_resample.c:    x->s_n   = outsize;
d_resample.c:  resample_dsp(x, in, insize, x->s_vec, x->s_n, method);
d_resample.c:    if (x->s_n)t_freebytes(x->s_vec, x->s_n * sizeof(*x->s_vec));
d_resample.c:    x->s_n = 0;
d_resample.c:    x->s_vec = out;
d_resample.c:  if (x->s_n != insize) {
d_resample.c:    t_sample *buf=x->s_vec;
d_resample.c:    t_freebytes(buf, x->s_n * sizeof(*buf));
d_resample.c:    x->s_vec = buf;
d_resample.c:    x->s_n   = insize;
d_resample.c:  resample_dsp(x, x->s_vec, x->s_n, out, outsize, method);
d_soundfile.c:/* Copyright (c) 1997-1999 Miller Puckette.
d_soundfile.c:objects use Posix-like threads.  */
d_soundfile.c:    char ns_fileid[4];      /* magic number '.snd' if file is big-endian */
d_soundfile.c:    unsigned char c_samprate[10];   /* sample rate, 80-bit float! */
d_soundfile.c:    unsigned char a_samprate[10];   /* sample rate, 80-bit float! */
d_soundfile.c:address on our architecture (big-endianness.).  It's 1 for Motorola,
d_soundfile.c:* Only 2- and 3-byte fixed-point samples and 4-byte floating point samples
d_soundfile.c:            nchannels = swap4(((t_nextstep *)buf)->ns_nchans, swap);
d_soundfile.c:            format = swap4(((t_nextstep *)buf)->ns_format, swap);
d_soundfile.c:            headersize = swap4(((t_nextstep *)buf)->ns_onset, swap);
d_soundfile.c:                    ((t_wavechunk *)buf)->wc_id[0],
d_soundfile.c:                    ((t_wavechunk *)buf)->wc_id[1],
d_soundfile.c:                    ((t_wavechunk *)buf)->wc_id[2],
d_soundfile.c:                    ((t_wavechunk *)buf)->wc_id[3]); */
d_soundfile.c:            while (strncmp(((t_wavechunk *)buf)->wc_id, "data", 4))
d_soundfile.c:                long chunksize = swap4(((t_wavechunk *)buf)->wc_size,
d_soundfile.c:                if (!strncmp(((t_wavechunk *)buf)->wc_id, "fmt ", 4))
d_soundfile.c:                    nchannels = swap2(((t_fmt *)buf)->f_nchannels, swap);
d_soundfile.c:                    format = swap2(((t_fmt *)buf)->f_nbitspersample, swap);
d_soundfile.c:                    ((t_wavechunk *)buf)->wc_id[0],
d_soundfile.c:                    ((t_wavechunk *)buf)->wc_id[1],
d_soundfile.c:                    ((t_wavechunk *)buf)->wc_id[2],
d_soundfile.c:                    ((t_wavechunk *)buf)->wc_id[3], seekto); */
d_soundfile.c:            bytelimit = swap4(((t_wavechunk *)buf)->wc_size, swap);
d_soundfile.c:            while (strncmp(((t_datachunk *)buf)->dc_id, "SSND", 4))
d_soundfile.c:                long chunksize = swap4(((t_datachunk *)buf)->dc_size,
d_soundfile.c:                    ((t_datachunk *)buf)->dc_id[0],
d_soundfile.c:                    ((t_datachunk *)buf)->dc_id[1],
d_soundfile.c:                    ((t_datachunk *)buf)->dc_id[2],
d_soundfile.c:                    ((t_datachunk *)buf)->dc_id[3], seekto); */
d_soundfile.c:                if (!strncmp(((t_datachunk *)buf)->dc_id, "COMM", 4))
d_soundfile.c:                    nchannels = swap2(((t_comm *)buf)->c_nchannels, swap);
d_soundfile.c:                    format = swap2(((t_comm *)buf)->c_bitspersamp, swap);
d_soundfile.c:            bytelimit = swap4(((t_datachunk *)buf)->dc_size, swap) - 8;
d_soundfile.c:        return (-1);
d_soundfile.c:     bytelimit -= nchannels * bytespersamp * skipframes;
d_soundfile.c:    return (-1);
d_soundfile.c:    a not-perfectly-threadsafe way.  LATER replace with a thread-hardened
d_soundfile.c:        return (-1);
d_soundfile.c:    a not-perfectly-threadsafe way.  LATER replace with a thread-hardened
d_soundfile.c:        return (-1);
d_soundfile.c:        for (j = nitems, fp = vecs[i]; j--; )
d_soundfile.c:        for (j = nitems, fp = vecs[i]; j--; )
d_soundfile.c:        -nframes <frames>
d_soundfile.c:        -skip <frames>
d_soundfile.c:        -bytes <bytes per sample>
d_soundfile.c:        -normalize
d_soundfile.c:        -nextstep
d_soundfile.c:        -wave
d_soundfile.c:        -big
d_soundfile.c:        -little
d_soundfile.c:        endianness = -1, swap, filetype = -1, normalize = 0;
d_soundfile.c:    t_float rate = -1;
d_soundfile.c:    while (argc > 0 && argv->a_type == A_SYMBOL &&
d_soundfile.c:        *argv->a_w.w_symbol->s_name == '-')
d_soundfile.c:        char *flag = argv->a_w.w_symbol->s_name + 1;
d_soundfile.c:            argc -= 2; argv += 2;
d_soundfile.c:            argc -= 2; argv += 2;
d_soundfile.c:            argc -= 2; argv += 2;
d_soundfile.c:            argc -= 1; argv += 1;
d_soundfile.c:            argc -= 1; argv += 1;
d_soundfile.c:            argc -= 1; argv += 1;
d_soundfile.c:            argc -= 1; argv += 1;
d_soundfile.c:            argc -= 1; argv += 1;
d_soundfile.c:            argc -= 1; argv += 1;
d_soundfile.c:            argc -= 2; argv += 2;
d_soundfile.c:    if (!argc || argv->a_type != A_SYMBOL)
d_soundfile.c:    filesym = argv->a_w.w_symbol;
d_soundfile.c:        if (strlen(filesym->s_name) >= 5 &&
d_soundfile.c:                        (!strcmp(filesym->s_name + strlen(filesym->s_name) - 4, ".aif") ||
d_soundfile.c:                        !strcmp(filesym->s_name + strlen(filesym->s_name) - 4, ".AIF")))
d_soundfile.c:        if (strlen(filesym->s_name) >= 6 &&
d_soundfile.c:                        (!strcmp(filesym->s_name + strlen(filesym->s_name) - 5, ".aiff") ||
d_soundfile.c:                        !strcmp(filesym->s_name + strlen(filesym->s_name) - 5, ".AIFF")))
d_soundfile.c:        if (strlen(filesym->s_name) >= 5 &&
d_soundfile.c:                        (!strcmp(filesym->s_name + strlen(filesym->s_name) - 4, ".snd") ||
d_soundfile.c:                        !strcmp(filesym->s_name + strlen(filesym->s_name) - 4, ".SND")))
d_soundfile.c:        if (strlen(filesym->s_name) >= 4 &&
d_soundfile.c:                        (!strcmp(filesym->s_name + strlen(filesym->s_name) - 3, ".au") ||
d_soundfile.c:                        !strcmp(filesym->s_name + strlen(filesym->s_name) - 3, ".AU")))
d_soundfile.c:            pd_error(obj, "AIFF floating-point file format unavailable");
d_soundfile.c:    else if (endianness == -1)
d_soundfile.c:    argc--; argv++;
d_soundfile.c:    return (-1);
d_soundfile.c:    strncpy(filenamebuf, filename, MAXPDSTRING-10);
d_soundfile.c:    filenamebuf[MAXPDSTRING-10] = 0;
d_soundfile.c:        if (strcmp(filenamebuf + strlen(filenamebuf)-4, ".snd"))
d_soundfile.c:            strncpy(nexthdr->ns_fileid, ".snd", 4);
d_soundfile.c:        else strncpy(nexthdr->ns_fileid, "dns.", 4);
d_soundfile.c:        nexthdr->ns_onset = swap4(sizeof(*nexthdr), swap);
d_soundfile.c:        nexthdr->ns_length = 0;
d_soundfile.c:        nexthdr->ns_format = swap4((bytespersamp == 3 ? NS_FORMAT_LINEAR_24 :
d_soundfile.c:        nexthdr->ns_sr = swap4(samplerate, swap);
d_soundfile.c:        nexthdr->ns_nchans = swap4(nchannels, swap);
d_soundfile.c:        strcpy(nexthdr->ns_info, "Pd ");
d_soundfile.c:        swapstring(nexthdr->ns_info, swap);
d_soundfile.c:        if (strcmp(filenamebuf + strlen(filenamebuf)-4, ".aif") &&
d_soundfile.c:            strcmp(filenamebuf + strlen(filenamebuf)-5, ".aiff"))
d_soundfile.c:        strncpy(aiffhdr->a_fileid, "FORM", 4);
d_soundfile.c:        aiffhdr->a_chunksize = swap4(datasize + sizeof(*aiffhdr) + 4, swap);
d_soundfile.c:        strncpy(aiffhdr->a_aiffid, "AIFF", 4);
d_soundfile.c:        strncpy(aiffhdr->a_fmtid, "COMM", 4);
d_soundfile.c:        aiffhdr->a_fmtchunksize = swap4(18, swap);
d_soundfile.c:        aiffhdr->a_nchannels = swap2(nchannels, swap);
d_soundfile.c:        memcpy(&aiffhdr->a_nframeshi, &longtmp, 4);
d_soundfile.c:        aiffhdr->a_bitspersamp = swap2(8 * bytespersamp, swap);
d_soundfile.c:        memcpy(aiffhdr->a_samprate, dogdoo, sizeof(dogdoo));
d_soundfile.c:            ((aiffhdr->a_samprate + sizeof(dogdoo))-(unsigned char *)aiffhdr),
d_soundfile.c:            ((aiffhdr->a_samprate + sizeof(dogdoo))-(unsigned char *)aiffhdr)
d_soundfile.c:        if (strcmp(filenamebuf + strlen(filenamebuf)-4, ".wav"))
d_soundfile.c:        strncpy(wavehdr->w_fileid, "RIFF", 4);
d_soundfile.c:        wavehdr->w_chunksize = swap4(datasize + sizeof(*wavehdr) - 8, swap);
d_soundfile.c:        strncpy(wavehdr->w_waveid, "WAVE", 4);
d_soundfile.c:        strncpy(wavehdr->w_fmtid, "fmt ", 4);
d_soundfile.c:        wavehdr->w_fmtchunksize = swap4(16, swap);
d_soundfile.c:        wavehdr->w_fmttag =
d_soundfile.c:        wavehdr->w_nchannels = swap2(nchannels, swap);
d_soundfile.c:        wavehdr->w_samplespersec = swap4(samplerate, swap);
d_soundfile.c:        wavehdr->w_navgbytespersec =
d_soundfile.c:        wavehdr->w_nblockalign = swap2(nchannels * bytespersamp, swap);
d_soundfile.c:        wavehdr->w_nbitspersample = swap2(8 * bytespersamp, swap);
d_soundfile.c:        strncpy(wavehdr->w_datachunkid, "data", 4);
d_soundfile.c:        wavehdr->w_datachunksize = swap4(datasize, swap);
d_soundfile.c:        return (-1);
d_soundfile.c:        return (-1);
d_soundfile.c:                ((char *)(&((t_wave *)0)->w_chunksize)) - (char *)0,
d_soundfile.c:            mofo = swap4(datasize + sizeof(t_wave) - 8, swap);
d_soundfile.c:                ((char *)(&((t_wave *)0)->w_datachunksize)) - (char *)0,
d_soundfile.c:                ((char *)(&((t_aiff *)0)->a_nframeshi)) - (char *)0,
d_soundfile.c:                ((char *)(&((t_aiff *)0)->a_chunksize)) - (char *)0,
d_soundfile.c:                    xx -= 32768;
d_soundfile.c:                    if (xx < -32767)
d_soundfile.c:                        xx = -32767;
d_soundfile.c:                    xx -= 32768;
d_soundfile.c:                    if (xx < -32767)
d_soundfile.c:                        xx = -32767;
d_soundfile.c:                    xx -= 8388608;
d_soundfile.c:                    if (xx < -8388607)
d_soundfile.c:                        xx = -8388607;
d_soundfile.c:                    xx -= 8388608;
d_soundfile.c:                    if (xx < -8388607)
d_soundfile.c:                        xx = -8388607;
d_soundfile.c:                    xx -= 32768;
d_soundfile.c:                    if (xx < -32767)
d_soundfile.c:                        xx = -32767;
d_soundfile.c:                    xx -= 32768;
d_soundfile.c:                    if (xx < -32767)
d_soundfile.c:                        xx = -32767;
d_soundfile.c:                    xx -= 8388608;
d_soundfile.c:                    if (xx < -8388607)
d_soundfile.c:                        xx = -8388607;
d_soundfile.c:                    xx -= 8388608;
d_soundfile.c:                    if (xx < -8388607)
d_soundfile.c:                        xx = -8388607;
d_soundfile.c:/* ------- soundfiler - reads and writes soundfiles to/from "garrays" ---- */
d_soundfile.c:    x->x_canvas = canvas_getcurrent();
d_soundfile.c:    outlet_new(&x->x_obj, &s_float);
d_soundfile.c:        -skip <frames> ... frames to skip in file
d_soundfile.c:        -onset <frames> ... onset in table to read into (NOT DONE YET)
d_soundfile.c:        -raw <headersize channels bytes endian>
d_soundfile.c:        -resize
d_soundfile.c:        -maxsize <max-size>
d_soundfile.c:    int headersize = -1, channels = 0, bytespersamp = 0, bigendian = 0,
d_soundfile.c:    int fd = -1;
d_soundfile.c:    while (argc > 0 && argv->a_type == A_SYMBOL &&
d_soundfile.c:        *argv->a_w.w_symbol->s_name == '-')
d_soundfile.c:        char *flag = argv->a_w.w_symbol->s_name + 1;
d_soundfile.c:            argc -= 2; argv += 2;
d_soundfile.c:                    ((endianness = argv[4].a_w.w_symbol->s_name[0]) != 'b'
d_soundfile.c:            argc -= 5; argv += 5;
d_soundfile.c:            argc -= 1; argv += 1;
d_soundfile.c:            argc -= 2; argv += 2;
d_soundfile.c:    filename = argv[0].a_w.w_symbol->s_name;
d_soundfile.c:    argc--; argv++;
d_soundfile.c:            pd_error(x, "%s: no such table", argv[i].a_w.w_symbol->s_name);
d_soundfile.c:                argv[i].a_w.w_symbol->s_name);
d_soundfile.c:    fd = open_soundfile_via_canvas(x->x_canvas, filename,
d_soundfile.c:        framesinfile = (eofis - poswas) / (channels * bytespersamp);
d_soundfile.c:                /* for sanity's sake let's clear the save-in-patch flag here */
d_soundfile.c:        int thisread = finalsize - itemsread;
d_soundfile.c:    fd = -1;
d_soundfile.c:    post("flags: -skip <n> -resize -maxsize <n> ...");
d_soundfile.c:    post("-raw <headerbytes> <channels> <bytespersamp> <endian (b, l, or n)>.");
d_soundfile.c:    outlet_float(x->x_obj.ob_outlet, (t_float)itemsread); 
d_soundfile.c:    int fd = -1;
d_soundfile.c:            pd_error(obj, "%s: no such table", argv[i].a_w.w_symbol->s_name);
d_soundfile.c:                argv[i].a_w.w_symbol->s_name);
d_soundfile.c:        if (nframes > vecsize - onset)
d_soundfile.c:            nframes = vecsize - onset;
d_soundfile.c:            else if (-vecs[i][j].w_float > biggest)
d_soundfile.c:                biggest = -vecs[i][j].w_float;
d_soundfile.c:    if ((fd = create_soundfile(canvas, filesym->s_name, filetype,
d_soundfile.c:        post("%s: %s\n", filesym->s_name, strerror(errno));
d_soundfile.c:            post("%s: normalizing max amplitude %f to 1", filesym->s_name, biggest);
d_soundfile.c:        else post("%s: biggest amplitude = %f", filesym->s_name, biggest);
d_soundfile.c:        int thiswrite = nframes - itemswritten, nitems, nbytes;
d_soundfile.c:            post("%s: %s", filesym->s_name, strerror(errno));
d_soundfile.c:        soundfile_finishwrite(obj, filesym->s_name, fd,
d_soundfile.c:    post("flags: -skip <n> -nframes <n> -bytes <n> -wave -aiff -nextstep ...");
d_soundfile.c:    post("-big -little -normalize");
d_soundfile.c:    post("(defaults to a 16-bit wave file).");
d_soundfile.c:    long bozo = soundfiler_dowrite(x, x->x_canvas,
d_soundfile.c:    outlet_float(x->x_obj.ob_outlet, (t_float)bozo); 
d_soundfile.c:is done by setting "conditions" and putting data in mutex-controlled common
d_soundfile.c:    t_outlet *x_bangout;                    /* bang-on-done outlet */
d_soundfile.c:    int x_bigendian;        /* true if file is big-endian */
d_soundfile.c:    pthread_mutex_lock(&x->x_mutex);
d_soundfile.c:        if (x->x_requestcode == REQUEST_NOTHING)
d_soundfile.c:            sfread_cond_signal(&x->x_answercondition);
d_soundfile.c:            sfread_cond_wait(&x->x_requestcondition, &x->x_mutex);
d_soundfile.c:        else if (x->x_requestcode == REQUEST_OPEN)
d_soundfile.c:            long onsetframes = x->x_onsetframes;
d_soundfile.c:            int skipheaderbytes = x->x_skipheaderbytes;
d_soundfile.c:            int bytespersample = x->x_bytespersample;
d_soundfile.c:            int sfchannels = x->x_sfchannels;
d_soundfile.c:            int bigendian = x->x_bigendian;
d_soundfile.c:            char *filename = x->x_filename;
d_soundfile.c:            char *dirname = canvas_getdir(x->x_canvas)->s_name;
d_soundfile.c:            x->x_requestcode = REQUEST_BUSY;
d_soundfile.c:            x->x_fileerror = 0;
d_soundfile.c:            if (x->x_fd >= 0)
d_soundfile.c:                fd = x->x_fd;
d_soundfile.c:                pthread_mutex_unlock(&x->x_mutex);
d_soundfile.c:                pthread_mutex_lock(&x->x_mutex);
d_soundfile.c:                x->x_fd = -1;
d_soundfile.c:                if (x->x_requestcode != REQUEST_BUSY)
d_soundfile.c:            pthread_mutex_unlock(&x->x_mutex);
d_soundfile.c:            pthread_mutex_lock(&x->x_mutex);
d_soundfile.c:            x->x_bytespersample = bytespersample;
d_soundfile.c:            x->x_sfchannels = sfchannels;
d_soundfile.c:            x->x_bigendian = bigendian;
d_soundfile.c:            x->x_fd = fd;
d_soundfile.c:            x->x_bytelimit = bytelimit;
d_soundfile.c:                x->x_fileerror = errno;
d_soundfile.c:                x->x_eof = 1;
d_soundfile.c:            if (x->x_requestcode != REQUEST_BUSY)
d_soundfile.c:            x->x_fifohead = 0;
d_soundfile.c:            x->x_fifosize = x->x_bufsize - (x->x_bufsize %
d_soundfile.c:                (x->x_bytespersample * x->x_sfchannels * MAXVECSIZE));
d_soundfile.c:                x->x_fifosize);
d_soundfile.c:            x->x_sigcountdown = x->x_sigperiod =
d_soundfile.c:                (x->x_fifosize /
d_soundfile.c:                    (16 * x->x_bytespersample * x->x_sfchannels *
d_soundfile.c:                        x->x_vecsize));
d_soundfile.c:            while (x->x_requestcode == REQUEST_BUSY)
d_soundfile.c:                int fifosize = x->x_fifosize;
d_soundfile.c:                if (x->x_eof)
d_soundfile.c:                if (x->x_fifohead >= x->x_fifotail)
d_soundfile.c:                    if (x->x_fifotail || (fifosize - x->x_fifohead > READSIZE))
d_soundfile.c:                        wantbytes = fifosize - x->x_fifohead;
d_soundfile.c:                        if (wantbytes > x->x_bytelimit)
d_soundfile.c:                            wantbytes = x->x_bytelimit;
d_soundfile.c:                            x->x_fifohead, x->x_fifotail, wantbytes);
d_soundfile.c:                        sfread_cond_signal(&x->x_answercondition);
d_soundfile.c:                        sfread_cond_wait(&x->x_requestcondition,
d_soundfile.c:                            &x->x_mutex);
d_soundfile.c:                    wantbytes =  x->x_fifotail - x->x_fifohead - 1;
d_soundfile.c:                        sfread_cond_signal(&x->x_answercondition);
d_soundfile.c:                        sfread_cond_wait(&x->x_requestcondition,
d_soundfile.c:                            &x->x_mutex);
d_soundfile.c:                    if (wantbytes > x->x_bytelimit)
d_soundfile.c:                        wantbytes = x->x_bytelimit;
d_soundfile.c:                fd = x->x_fd;
d_soundfile.c:                buf = x->x_buf;
d_soundfile.c:                fifohead = x->x_fifohead;
d_soundfile.c:                pthread_mutex_unlock(&x->x_mutex);
d_soundfile.c:                pthread_mutex_lock(&x->x_mutex);
d_soundfile.c:                if (x->x_requestcode != REQUEST_BUSY)
d_soundfile.c:                    x->x_fileerror = errno;
d_soundfile.c:                    x->x_eof = 1;
d_soundfile.c:                    x->x_fifohead += sysrtn;
d_soundfile.c:                    x->x_bytelimit -= sysrtn;
d_soundfile.c:                    if (x->x_fifohead == fifosize)
d_soundfile.c:                        x->x_fifohead = 0;
d_soundfile.c:                    if (x->x_bytelimit <= 0)
d_soundfile.c:                        x->x_eof = 1;
d_soundfile.c:                    x->x_fifohead, x->x_fifotail);
d_soundfile.c:                sfread_cond_signal(&x->x_answercondition);
d_soundfile.c:            if (x->x_requestcode == REQUEST_BUSY)
d_soundfile.c:                x->x_requestcode = REQUEST_NOTHING;
d_soundfile.c:            if (x->x_fd >= 0)
d_soundfile.c:                fd = x->x_fd;
d_soundfile.c:                pthread_mutex_unlock(&x->x_mutex);
d_soundfile.c:                pthread_mutex_lock(&x->x_mutex);
d_soundfile.c:                x->x_fd = -1;
d_soundfile.c:            sfread_cond_signal(&x->x_answercondition);
d_soundfile.c:        else if (x->x_requestcode == REQUEST_CLOSE)
d_soundfile.c:            if (x->x_fd >= 0)
d_soundfile.c:                fd = x->x_fd;
d_soundfile.c:                pthread_mutex_unlock(&x->x_mutex);
d_soundfile.c:                pthread_mutex_lock(&x->x_mutex);
d_soundfile.c:                x->x_fd = -1;
d_soundfile.c:            if (x->x_requestcode == REQUEST_CLOSE)
d_soundfile.c:                x->x_requestcode = REQUEST_NOTHING;
d_soundfile.c:            sfread_cond_signal(&x->x_answercondition);
d_soundfile.c:        else if (x->x_requestcode == REQUEST_QUIT)
d_soundfile.c:            if (x->x_fd >= 0)
d_soundfile.c:                fd = x->x_fd;
d_soundfile.c:                pthread_mutex_unlock(&x->x_mutex);
d_soundfile.c:                pthread_mutex_lock(&x->x_mutex);
d_soundfile.c:                x->x_fd = -1;
d_soundfile.c:            x->x_requestcode = REQUEST_NOTHING;
d_soundfile.c:            sfread_cond_signal(&x->x_answercondition);
d_soundfile.c:    pthread_mutex_unlock(&x->x_mutex);
d_soundfile.c:        outlet_new(&x->x_obj, gensym("signal"));
d_soundfile.c:    x->x_noutlets = nchannels;
d_soundfile.c:    x->x_bangout = outlet_new(&x->x_obj, &s_bang);
d_soundfile.c:    pthread_mutex_init(&x->x_mutex, 0);
d_soundfile.c:    pthread_cond_init(&x->x_requestcondition, 0);
d_soundfile.c:    pthread_cond_init(&x->x_answercondition, 0);
d_soundfile.c:    x->x_vecsize = MAXVECSIZE;
d_soundfile.c:    x->x_state = STATE_IDLE;
d_soundfile.c:    x->x_clock = clock_new(x, (t_method)readsf_tick);
d_soundfile.c:    x->x_canvas = canvas_getcurrent();
d_soundfile.c:    x->x_bytespersample = 2;
d_soundfile.c:    x->x_sfchannels = 1;
d_soundfile.c:    x->x_fd = -1;
d_soundfile.c:    x->x_buf = buf;
d_soundfile.c:    x->x_bufsize = bufsize;
d_soundfile.c:    x->x_fifosize = x->x_fifohead = x->x_fifotail = x->x_requestcode = 0;
d_soundfile.c:    pthread_create(&x->x_childthread, 0, readsf_child_main, x);
d_soundfile.c:    outlet_bang(x->x_bangout);
d_soundfile.c:    int vecsize = x->x_vecsize, noutlets = x->x_noutlets, i, j,
d_soundfile.c:        bytespersample = x->x_bytespersample,
d_soundfile.c:        bigendian = x->x_bigendian;
d_soundfile.c:    if (x->x_state == STATE_STREAM)
d_soundfile.c:        int wantbytes, nchannels, sfchannels = x->x_sfchannels;
d_soundfile.c:        pthread_mutex_lock(&x->x_mutex);
d_soundfile.c:            !x->x_eof && x->x_fifohead >= x->x_fifotail &&
d_soundfile.c:                x->x_fifohead < x->x_fifotail + wantbytes-1)
d_soundfile.c:            sfread_cond_signal(&x->x_requestcondition);
d_soundfile.c:            sfread_cond_wait(&x->x_answercondition, &x->x_mutex);
d_soundfile.c:                /* resync local cariables -- bug fix thanks to Shahrokh */
d_soundfile.c:            vecsize = x->x_vecsize;
d_soundfile.c:            bytespersample = x->x_bytespersample;
d_soundfile.c:            sfchannels = x->x_sfchannels;
d_soundfile.c:            bigendian = x->x_bigendian;
d_soundfile.c:        if (x->x_eof && x->x_fifohead >= x->x_fifotail &&
d_soundfile.c:            x->x_fifohead < x->x_fifotail + wantbytes-1)
d_soundfile.c:            if (x->x_fileerror)
d_soundfile.c:                pd_error(x, "dsp: %s: %s", x->x_filename,
d_soundfile.c:                    (x->x_fileerror == EIO ?
d_soundfile.c:                            strerror(x->x_fileerror)));
d_soundfile.c:            clock_delay(x->x_clock, 0);
d_soundfile.c:            x->x_state = STATE_IDLE;
d_soundfile.c:            xfersize = (x->x_fifohead - x->x_fifotail + 1) /
d_soundfile.c:                soundfile_xferin_sample(sfchannels, noutlets, x->x_outvec, 0,
d_soundfile.c:                    (unsigned char *)(x->x_buf + x->x_fifotail), xfersize,
d_soundfile.c:                vecsize -= xfersize;
d_soundfile.c:                for (j = vecsize, fp = x->x_outvec[i] + xfersize; j--; )
d_soundfile.c:            sfread_cond_signal(&x->x_requestcondition);
d_soundfile.c:            pthread_mutex_unlock(&x->x_mutex);
d_soundfile.c:        soundfile_xferin_sample(sfchannels, noutlets, x->x_outvec, 0,
d_soundfile.c:            (unsigned char *)(x->x_buf + x->x_fifotail), vecsize,
d_soundfile.c:        x->x_fifotail += wantbytes;
d_soundfile.c:        if (x->x_fifotail >= x->x_fifosize)
d_soundfile.c:            x->x_fifotail = 0;
d_soundfile.c:        if ((--x->x_sigcountdown) <= 0)
d_soundfile.c:            sfread_cond_signal(&x->x_requestcondition);
d_soundfile.c:            x->x_sigcountdown = x->x_sigperiod;
d_soundfile.c:        pthread_mutex_unlock(&x->x_mutex);
d_soundfile.c:            for (j = vecsize, fp = x->x_outvec[i]; j--; )
d_soundfile.c:    if (x->x_state == STATE_STARTUP)
d_soundfile.c:        x->x_state = STATE_STREAM;
d_soundfile.c:    pthread_mutex_lock(&x->x_mutex);
d_soundfile.c:    x->x_state = STATE_IDLE;
d_soundfile.c:    x->x_requestcode = REQUEST_CLOSE;
d_soundfile.c:    sfread_cond_signal(&x->x_requestcondition);
d_soundfile.c:    pthread_mutex_unlock(&x->x_mutex);
d_soundfile.c:        detected; thus, use the special "-1" to mean a truly headerless file.)
d_soundfile.c:    if (!*filesym->s_name)
d_soundfile.c:    pthread_mutex_lock(&x->x_mutex);
d_soundfile.c:    x->x_requestcode = REQUEST_OPEN;
d_soundfile.c:    x->x_filename = filesym->s_name;
d_soundfile.c:    x->x_fifotail = 0;
d_soundfile.c:    x->x_fifohead = 0;
d_soundfile.c:    if (*endian->s_name == 'b')
d_soundfile.c:         x->x_bigendian = 1;
d_soundfile.c:    else if (*endian->s_name == 'l')
d_soundfile.c:         x->x_bigendian = 0;
d_soundfile.c:    else if (*endian->s_name)
d_soundfile.c:    else x->x_bigendian = garray_ambigendian();
d_soundfile.c:    x->x_onsetframes = (onsetframes > 0 ? onsetframes : 0);
d_soundfile.c:    x->x_skipheaderbytes = (headerbytes > 0 ? headerbytes : 
d_soundfile.c:        (headerbytes == 0 ? -1 : 0));
d_soundfile.c:    x->x_sfchannels = (channels >= 1 ? channels : 1);
d_soundfile.c:    x->x_bytespersample = (bytespersamp > 2 ? bytespersamp : 2);
d_soundfile.c:    x->x_eof = 0;
d_soundfile.c:    x->x_fileerror = 0;
d_soundfile.c:    x->x_state = STATE_STARTUP;
d_soundfile.c:    sfread_cond_signal(&x->x_requestcondition);
d_soundfile.c:    pthread_mutex_unlock(&x->x_mutex);
d_soundfile.c:    int i, noutlets = x->x_noutlets;
d_soundfile.c:    pthread_mutex_lock(&x->x_mutex);
d_soundfile.c:    x->x_vecsize = sp[0]->s_n;
d_soundfile.c:    x->x_sigperiod = (x->x_fifosize /
d_soundfile.c:        (x->x_bytespersample * x->x_sfchannels * x->x_vecsize));
d_soundfile.c:        x->x_outvec[i] = sp[i]->s_vec;
d_soundfile.c:    pthread_mutex_unlock(&x->x_mutex);
d_soundfile.c:    post("state %d", x->x_state);
d_soundfile.c:    post("fifo head %d", x->x_fifohead);
d_soundfile.c:    post("fifo tail %d", x->x_fifotail);
d_soundfile.c:    post("fifo size %d", x->x_fifosize);
d_soundfile.c:    post("fd %d", x->x_fd);
d_soundfile.c:    post("eof %d", x->x_eof);
d_soundfile.c:    pthread_mutex_lock(&x->x_mutex);
d_soundfile.c:    x->x_requestcode = REQUEST_QUIT;
d_soundfile.c:    sfread_cond_signal(&x->x_requestcondition);
d_soundfile.c:    while (x->x_requestcode != REQUEST_NOTHING)
d_soundfile.c:        sfread_cond_signal(&x->x_requestcondition);
d_soundfile.c:        sfread_cond_wait(&x->x_answercondition, &x->x_mutex);
d_soundfile.c:    pthread_mutex_unlock(&x->x_mutex);
d_soundfile.c:    if (pthread_join(x->x_childthread, &threadrtn))
d_soundfile.c:    pthread_cond_destroy(&x->x_requestcondition);
d_soundfile.c:    pthread_cond_destroy(&x->x_answercondition);
d_soundfile.c:    pthread_mutex_destroy(&x->x_mutex);
d_soundfile.c:    freebytes(x->x_buf, x->x_bufsize);
d_soundfile.c:    clock_free(x->x_clock);
d_soundfile.c:#define t_writesf t_readsf      /* just re-use the structure */
d_soundfile.c:    pthread_mutex_lock(&x->x_mutex);
d_soundfile.c:        if (x->x_requestcode == REQUEST_NOTHING)
d_soundfile.c:            sfread_cond_signal(&x->x_answercondition);
d_soundfile.c:            sfread_cond_wait(&x->x_requestcondition, &x->x_mutex);
d_soundfile.c:        else if (x->x_requestcode == REQUEST_OPEN)
d_soundfile.c:            long onsetframes = x->x_onsetframes;
d_soundfile.c:            int skipheaderbytes = x->x_skipheaderbytes;
d_soundfile.c:            int bytespersample = x->x_bytespersample;
d_soundfile.c:            int sfchannels = x->x_sfchannels;
d_soundfile.c:            int bigendian = x->x_bigendian;
d_soundfile.c:            int filetype = x->x_filetype;
d_soundfile.c:            char *filename = x->x_filename;
d_soundfile.c:            t_canvas *canvas = x->x_canvas;
d_soundfile.c:            t_float samplerate = x->x_samplerate;
d_soundfile.c:            x->x_requestcode = REQUEST_BUSY;
d_soundfile.c:            x->x_fileerror = 0;
d_soundfile.c:            if (x->x_fd >= 0)
d_soundfile.c:                int bytesperframe = x->x_bytespersample * x->x_sfchannels;
d_soundfile.c:                int bigendian = x->x_bigendian;
d_soundfile.c:                char *filename = x->x_filename;
d_soundfile.c:                int fd = x->x_fd;
d_soundfile.c:                int filetype = x->x_filetype;
d_soundfile.c:                int itemswritten = x->x_itemswritten;
d_soundfile.c:                int swap = x->x_swap;
d_soundfile.c:                pthread_mutex_unlock(&x->x_mutex);
d_soundfile.c:                pthread_mutex_lock(&x->x_mutex);
d_soundfile.c:                x->x_fd = -1;
d_soundfile.c:                if (x->x_requestcode != REQUEST_BUSY)
d_soundfile.c:            pthread_mutex_unlock(&x->x_mutex);
d_soundfile.c:            pthread_mutex_lock(&x->x_mutex);
d_soundfile.c:                x->x_fd = -1;
d_soundfile.c:                x->x_eof = 1;
d_soundfile.c:                x->x_fileerror = errno;
d_soundfile.c:                x->x_requestcode = REQUEST_NOTHING;
d_soundfile.c:            if (x->x_requestcode != REQUEST_BUSY)
d_soundfile.c:            x->x_fd = fd;
d_soundfile.c:            x->x_fifotail = 0;
d_soundfile.c:            x->x_itemswritten = 0;
d_soundfile.c:            x->x_swap = garray_ambigendian() != bigendian;      
d_soundfile.c:            while (x->x_requestcode == REQUEST_BUSY ||
d_soundfile.c:                (x->x_requestcode == REQUEST_CLOSE &&
d_soundfile.c:                    x->x_fifohead != x->x_fifotail))
d_soundfile.c:                int fifosize = x->x_fifosize, fifotail;
d_soundfile.c:                char *buf = x->x_buf;
d_soundfile.c:                if (x->x_fifohead < x->x_fifotail ||
d_soundfile.c:                    x->x_fifohead >= x->x_fifotail + WRITESIZE
d_soundfile.c:                    || (x->x_requestcode == REQUEST_CLOSE &&
d_soundfile.c:                        x->x_fifohead != x->x_fifotail))
d_soundfile.c:                    writebytes = (x->x_fifohead < x->x_fifotail ?
d_soundfile.c:                        fifosize : x->x_fifohead) - x->x_fifotail;
d_soundfile.c:                    sfread_cond_signal(&x->x_answercondition);
d_soundfile.c:                    sfread_cond_wait(&x->x_requestcondition,
d_soundfile.c:                        &x->x_mutex);
d_soundfile.c:                fifotail = x->x_fifotail;
d_soundfile.c:                fd = x->x_fd;
d_soundfile.c:                pthread_mutex_unlock(&x->x_mutex);
d_soundfile.c:                pthread_mutex_lock(&x->x_mutex);
d_soundfile.c:                if (x->x_requestcode != REQUEST_BUSY &&
d_soundfile.c:                    x->x_requestcode != REQUEST_CLOSE)
d_soundfile.c:                    x->x_fileerror = errno;
d_soundfile.c:                    x->x_fifotail += sysrtn;
d_soundfile.c:                    if (x->x_fifotail == fifosize)
d_soundfile.c:                        x->x_fifotail = 0;
d_soundfile.c:                x->x_itemswritten +=
d_soundfile.c:                    sysrtn / (x->x_bytespersample * x->x_sfchannels);
d_soundfile.c:                    x->x_fifohead, x->x_fifotail, x->x_itemswritten);
d_soundfile.c:                sfread_cond_signal(&x->x_answercondition);
d_soundfile.c:        else if (x->x_requestcode == REQUEST_CLOSE ||
d_soundfile.c:            x->x_requestcode == REQUEST_QUIT)
d_soundfile.c:            int quit = (x->x_requestcode == REQUEST_QUIT);
d_soundfile.c:            if (x->x_fd >= 0)
d_soundfile.c:                int bytesperframe = x->x_bytespersample * x->x_sfchannels;
d_soundfile.c:                int bigendian = x->x_bigendian;
d_soundfile.c:                char *filename = x->x_filename;
d_soundfile.c:                int fd = x->x_fd;
d_soundfile.c:                int filetype = x->x_filetype;
d_soundfile.c:                int itemswritten = x->x_itemswritten;
d_soundfile.c:                int swap = x->x_swap;
d_soundfile.c:                pthread_mutex_unlock(&x->x_mutex);
d_soundfile.c:                pthread_mutex_lock(&x->x_mutex);
d_soundfile.c:                x->x_fd = -1;
d_soundfile.c:            x->x_requestcode = REQUEST_NOTHING;
d_soundfile.c:            sfread_cond_signal(&x->x_answercondition);
d_soundfile.c:    pthread_mutex_unlock(&x->x_mutex);
d_soundfile.c:        inlet_new(&x->x_obj,  &x->x_obj.ob_pd, &s_signal, &s_signal);
d_soundfile.c:    x->x_f = 0;
d_soundfile.c:    x->x_sfchannels = nchannels;
d_soundfile.c:    pthread_mutex_init(&x->x_mutex, 0);
d_soundfile.c:    pthread_cond_init(&x->x_requestcondition, 0);
d_soundfile.c:    pthread_cond_init(&x->x_answercondition, 0);
d_soundfile.c:    x->x_vecsize = MAXVECSIZE;
d_soundfile.c:    x->x_insamplerate = x->x_samplerate = 0;
d_soundfile.c:    x->x_state = STATE_IDLE;
d_soundfile.c:    x->x_clock = 0;     /* no callback needed here */
d_soundfile.c:    x->x_canvas = canvas_getcurrent();
d_soundfile.c:    x->x_bytespersample = 2;
d_soundfile.c:    x->x_fd = -1;
d_soundfile.c:    x->x_buf = buf;
d_soundfile.c:    x->x_bufsize = bufsize;
d_soundfile.c:    x->x_fifosize = x->x_fifohead = x->x_fifotail = x->x_requestcode = 0;
d_soundfile.c:    pthread_create(&x->x_childthread, 0, writesf_child_main, x);
d_soundfile.c:    int vecsize = x->x_vecsize, sfchannels = x->x_sfchannels, i, j,
d_soundfile.c:        bytespersample = x->x_bytespersample,
d_soundfile.c:        bigendian = x->x_bigendian;
d_soundfile.c:    if (x->x_state == STATE_STREAM)
d_soundfile.c:        pthread_mutex_lock(&x->x_mutex);
d_soundfile.c:        while (x->x_fifotail > x->x_fifohead &&
d_soundfile.c:            x->x_fifotail < x->x_fifohead + wantbytes + 1)
d_soundfile.c:            sfread_cond_signal(&x->x_requestcondition);
d_soundfile.c:            sfread_cond_wait(&x->x_answercondition, &x->x_mutex);
d_soundfile.c:        soundfile_xferout_sample(sfchannels, x->x_outvec,
d_soundfile.c:            (unsigned char *)(x->x_buf + x->x_fifohead), vecsize, 0,
d_soundfile.c:        x->x_fifohead += wantbytes;
d_soundfile.c:        if (x->x_fifohead >= x->x_fifosize)
d_soundfile.c:            x->x_fifohead = 0;
d_soundfile.c:        if ((--x->x_sigcountdown) <= 0)
d_soundfile.c:            sfread_cond_signal(&x->x_requestcondition);
d_soundfile.c:            x->x_sigcountdown = x->x_sigperiod;
d_soundfile.c:        pthread_mutex_unlock(&x->x_mutex);
d_soundfile.c:    if (x->x_state == STATE_STARTUP)
d_soundfile.c:        x->x_state = STATE_STREAM;
d_soundfile.c:    pthread_mutex_lock(&x->x_mutex);
d_soundfile.c:    x->x_state = STATE_IDLE;
d_soundfile.c:    x->x_requestcode = REQUEST_CLOSE;
d_soundfile.c:    sfread_cond_signal(&x->x_requestcondition);
d_soundfile.c:    pthread_mutex_unlock(&x->x_mutex);
d_soundfile.c:    if (x->x_state != STATE_IDLE)
d_soundfile.c:            "writesf~: usage: open [-bytes [234]] [-wave,-nextstep,-aiff] ...");
d_soundfile.c:        post("... [-big,-little] [-rate ####] filename");
d_soundfile.c:    pthread_mutex_lock(&x->x_mutex);
d_soundfile.c:    while (x->x_requestcode != REQUEST_NOTHING)
d_soundfile.c:        sfread_cond_signal(&x->x_requestcondition);
d_soundfile.c:        sfread_cond_wait(&x->x_answercondition, &x->x_mutex);
d_soundfile.c:    x->x_bytespersample = bytespersamp;
d_soundfile.c:    x->x_swap = swap;
d_soundfile.c:    x->x_bigendian = bigendian;
d_soundfile.c:    x->x_filename = filesym->s_name;
d_soundfile.c:    x->x_filetype = filetype;
d_soundfile.c:    x->x_itemswritten = 0;
d_soundfile.c:    x->x_requestcode = REQUEST_OPEN;
d_soundfile.c:    x->x_fifotail = 0;
d_soundfile.c:    x->x_fifohead = 0;
d_soundfile.c:    x->x_eof = 0;
d_soundfile.c:    x->x_fileerror = 0;
d_soundfile.c:    x->x_state = STATE_STARTUP;
d_soundfile.c:    x->x_bytespersample = (bytespersamp > 2 ? bytespersamp : 2);
d_soundfile.c:        x->x_samplerate = samplerate;
d_soundfile.c:    else if (x->x_insamplerate > 0)
d_soundfile.c:        x->x_samplerate = x->x_insamplerate;
d_soundfile.c:    else x->x_samplerate = sys_getsr();
d_soundfile.c:    x->x_fifosize = x->x_bufsize - (x->x_bufsize %
d_soundfile.c:        (x->x_bytespersample * x->x_sfchannels * MAXVECSIZE));
d_soundfile.c:    x->x_sigcountdown = x->x_sigperiod =
d_soundfile.c:        (x->x_fifosize /
d_soundfile.c:            (16 * x->x_bytespersample * x->x_sfchannels *
d_soundfile.c:                x->x_vecsize));
d_soundfile.c:    sfread_cond_signal(&x->x_requestcondition);
d_soundfile.c:    pthread_mutex_unlock(&x->x_mutex);
d_soundfile.c:    int i, ninlets = x->x_sfchannels;
d_soundfile.c:    pthread_mutex_lock(&x->x_mutex);
d_soundfile.c:    x->x_vecsize = sp[0]->s_n;
d_soundfile.c:    x->x_sigperiod = (x->x_fifosize /
d_soundfile.c:        (x->x_bytespersample * ninlets * x->x_vecsize));
d_soundfile.c:        x->x_outvec[i] = sp[i]->s_vec;
d_soundfile.c:    x->x_insamplerate = sp[0]->s_sr;
d_soundfile.c:    pthread_mutex_unlock(&x->x_mutex);
d_soundfile.c:    post("state %d", x->x_state);
d_soundfile.c:    post("fifo head %d", x->x_fifohead);
d_soundfile.c:    post("fifo tail %d", x->x_fifotail);
d_soundfile.c:    post("fifo size %d", x->x_fifosize);
d_soundfile.c:    post("fd %d", x->x_fd);
d_soundfile.c:    post("eof %d", x->x_eof);
d_soundfile.c:    pthread_mutex_lock(&x->x_mutex);
d_soundfile.c:    x->x_requestcode = REQUEST_QUIT;
d_soundfile.c:    sfread_cond_signal(&x->x_requestcondition);
d_soundfile.c:    while (x->x_requestcode != REQUEST_NOTHING)
d_soundfile.c:        sfread_cond_signal(&x->x_requestcondition);
d_soundfile.c:        sfread_cond_wait(&x->x_answercondition, &x->x_mutex);
d_soundfile.c:    pthread_mutex_unlock(&x->x_mutex);
d_soundfile.c:    if (pthread_join(x->x_childthread, &threadrtn))
d_soundfile.c:    pthread_cond_destroy(&x->x_requestcondition);
d_soundfile.c:    pthread_cond_destroy(&x->x_answercondition);
d_soundfile.c:    pthread_mutex_destroy(&x->x_mutex);
d_soundfile.c:    freebytes(x->x_buf, x->x_bufsize);
d_soundfile.c:/* ------------------------ global setup routine ------------------------- */
d_ugen.c:/* Copyright (c) 1997-1999 Miller Puckette.
d_ugen.c:    while (n--) *out++ = 0; 
d_ugen.c:    for (; n; n -= 8, out += 8)
d_ugen.c:/* ---------------------------- block~ ----------------------------- */
d_ugen.c:calling it at a super- or sub-multiple of the containing canvas's
d_ugen.c:    int x_phase;        /* from 0 to period-1; when zero we run the block */
d_ugen.c:    int x_upsample;     /* upsampling-factor */
d_ugen.c:    int x_downsample;   /* downsampling-factor */
d_ugen.c:    int x_return;       /* stop right after this block (for one-shots) */
d_ugen.c:    x->x_phase = 0;
d_ugen.c:    x->x_period = 1;
d_ugen.c:    x->x_frequency = 1;
d_ugen.c:    x->x_switched = 0;
d_ugen.c:    x->x_switchon = 1;
d_ugen.c:    x->x_calcsize = calcsize;
d_ugen.c:    x->x_vecsize = vecsize;
d_ugen.c:    x->x_overlap = overlap;
d_ugen.c:    x->x_upsample = upsample;
d_ugen.c:    x->x_downsample = downsample;
d_ugen.c:    x->x_switched = 1;
d_ugen.c:    x->x_switchon = 0;
d_ugen.c:    if (x->x_switched)
d_ugen.c:        x->x_switchon = (f != 0);
d_ugen.c:    if (x->x_switched && !x->x_switchon && dsp_chain)
d_ugen.c:        x->x_return = 1;
d_ugen.c:        for (ip = dsp_chain + x->x_chainonset; ip; )
d_ugen.c:        x->x_return = 0;
d_ugen.c:    else pd_error(x, "bang to block~ or on-state switch~ has no effect");
d_ugen.c:    int phase = x->x_phase;
d_ugen.c:    if (!x->x_switchon)
d_ugen.c:        return (w + x->x_blocklength);
d_ugen.c:        if (phase == x->x_period) phase = 0;
d_ugen.c:        x->x_phase = phase;
d_ugen.c:        return (w + x->x_blocklength);  /* skip block; jump past epilog */
d_ugen.c:        x->x_count = x->x_frequency;
d_ugen.c:        x->x_phase = (x->x_period > 1 ? 1 : 0);
d_ugen.c:    int count = x->x_count - 1;
d_ugen.c:    if (x->x_return)
d_ugen.c:    if (!x->x_reblock)
d_ugen.c:        return (w + x->x_epiloglength + EPILOGCALL);
d_ugen.c:        x->x_count = count;
d_ugen.c:        return (w - (x->x_blocklength -
d_ugen.c:/* ------------------ DSP call list ----------------------- */
d_ugen.c:    dsp_chain[dsp_chainsize-1] = (t_int)f;
d_ugen.c:    dsp_chain[newsize-1] = (t_int)dsp_done;
d_ugen.c:    dsp_chain[dsp_chainsize-1] = (t_int)f;
d_ugen.c:    dsp_chain[newsize-1] = (t_int)dsp_done;
d_ugen.c:/* ---------------- signals ---------------------------- */
d_ugen.c:    int r = -1;
d_ugen.c:        signal_usedlist = sig->s_nextused;
d_ugen.c:        if (!sig->s_isborrowed)
d_ugen.c:            t_freebytes(sig->s_vec, sig->s_vecsize * sizeof (*sig->s_vec));
d_ugen.c:    int logn = ilog2(sig->s_vecsize);
d_ugen.c:    for (s5 = signal_freeborrowed; s5; s5 = s5->s_nextfree)
d_ugen.c:    for (s5 = signal_freelist[logn]; s5; s5 = s5->s_nextfree)
d_ugen.c:    if (ugen_loud) post("free %lx: %d", sig, sig->s_isborrowed);
d_ugen.c:    if (sig->s_isborrowed)
d_ugen.c:            /* if the signal is borrowed, decrement the borrowed-from signal's
d_ugen.c:        t_signal *s2 = sig->s_borrowedfrom;
d_ugen.c:        s2->s_refcount--;
d_ugen.c:        if (!s2->s_refcount)
d_ugen.c:        sig->s_nextfree = signal_freeborrowed;
d_ugen.c:        sig->s_nextfree = signal_freelist[logn];
d_ugen.c:        *whichlist = ret->s_nextfree;
d_ugen.c:            /* LATER figure out what to do for out-of-space here! */
d_ugen.c:            ret->s_vec = (t_sample *)getbytes(vecsize * sizeof (*ret->s_vec));
d_ugen.c:            ret->s_isborrowed = 0;
d_ugen.c:            ret->s_vec = 0;
d_ugen.c:            ret->s_isborrowed = 1;
d_ugen.c:        ret->s_nextused = signal_usedlist;
d_ugen.c:    ret->s_n = n;
d_ugen.c:    ret->s_vecsize = vecsize;
d_ugen.c:    ret->s_sr = sr;
d_ugen.c:    ret->s_refcount = 0;
d_ugen.c:    ret->s_borrowedfrom = 0;
d_ugen.c:    if (ugen_loud) post("new %lx: %d", ret, ret->s_isborrowed);
d_ugen.c:    return (signal_new(sig->s_n, sig->s_sr));
d_ugen.c:    if (!sig->s_isborrowed || sig->s_borrowedfrom)
d_ugen.c:    sig->s_borrowedfrom = sig2;
d_ugen.c:    sig->s_vec = sig2->s_vec;
d_ugen.c:    sig->s_n = sig2->s_n;
d_ugen.c:    sig->s_vecsize = sig2->s_vecsize;
d_ugen.c:    return (s1->s_n == s2->s_n && s1->s_sr == s2->s_sr);
d_ugen.c:/* ------------------ ugen ("unit generator") sorting ----------------- */
d_ugen.c:        count++, sig = sig->s_nextused)
d_ugen.c:            count++, sig = sig->s_nextfree)
d_ugen.c:        count++, sig = sig->s_nextfree)
d_ugen.c:    dc->dc_ugenlist = 0;
d_ugen.c:    dc->dc_toplevel = toplevel;
d_ugen.c:    dc->dc_iosigs = sp;
d_ugen.c:    dc->dc_ninlets = ninlets;
d_ugen.c:    dc->dc_noutlets = noutlets;
d_ugen.c:    dc->dc_parentcontext = ugen_currentcontext;
d_ugen.c:    x->u_next = dc->dc_ugenlist;
d_ugen.c:    dc->dc_ugenlist = x;
d_ugen.c:    x->u_obj = obj;
d_ugen.c:    x->u_nin = obj_nsiginlets(obj);
d_ugen.c:    x->u_in = getbytes(x->u_nin * sizeof (*x->u_in));
d_ugen.c:    for (uin = x->u_in, i = x->u_nin; i--; uin++)
d_ugen.c:        uin->i_nconnect = 0;
d_ugen.c:    x->u_nout = obj_nsigoutlets(obj);
d_ugen.c:    x->u_out = getbytes(x->u_nout * sizeof (*x->u_out));
d_ugen.c:    for (uout = x->u_out, i = x->u_nout; i--; uout++)
d_ugen.c:        uout->o_connections = 0, uout->o_nconnect = 0;
d_ugen.c:        post("%s -> %s: %d->%d",
d_ugen.c:            class_getname(x1->ob_pd),
d_ugen.c:                class_getname(x2->ob_pd), outno, inno);
d_ugen.c:    for (u1 = dc->dc_ugenlist; u1 && u1->u_obj != x1; u1 = u1->u_next);
d_ugen.c:    for (u2 = dc->dc_ugenlist; u2 && u2->u_obj != x2; u2 = u2->u_next);
d_ugen.c:        pd_error(u1->u_obj,
d_ugen.c:    if (sigoutno < 0 || sigoutno >= u1->u_nout || siginno >= u2->u_nin)
d_ugen.c:            class_getname(x1->ob_pd),
d_ugen.c:            class_getname(x2->ob_pd), sigoutno, siginno, u1->u_nout,
d_ugen.c:                u2->u_nin);
d_ugen.c:    uout = u1->u_out + sigoutno;
d_ugen.c:    uin = u2->u_in + siginno;
d_ugen.c:    oc->oc_next = uout->o_connections;
d_ugen.c:    uout->o_connections = oc;
d_ugen.c:    oc->oc_who = u2;
d_ugen.c:    oc->oc_inno = siginno;
d_ugen.c:    uout->o_nconnect++;
d_ugen.c:    uin->i_nconnect++;
d_ugen.c:    /* get the index of a ugenbox or -1 if it's not on the list */
d_ugen.c:    for (u = dc->dc_ugenlist, ret = 0; u; u = u->u_next, ret++)
d_ugen.c:    return (-1);
d_ugen.c:    t_class *class = pd_class(&u->u_obj->ob_pd);
d_ugen.c:        (class == vinlet_class) && !(dc->dc_reblock));
d_ugen.c:        (class == voutlet_class) &&  !(dc->dc_reblock || dc->dc_switched));
d_ugen.c:    for (i = 0, uin = u->u_in; i < u->u_nin; i++, uin++)
d_ugen.c:        if (!uin->i_nconnect)
d_ugen.c:            s3 = signal_new(dc->dc_vecsize, dc->dc_srate);
d_ugen.c:                class_getname(u->u_obj->ob_pd)); */
d_ugen.c:            if (scalar = obj_findsignalscalar(u->u_obj, i))
d_ugen.c:                dsp_add_scalarcopy(scalar, s3->s_vec, s3->s_n);
d_ugen.c:                dsp_add_zero(s3->s_vec, s3->s_n);
d_ugen.c:            uin->i_signal = s3;
d_ugen.c:            s3->s_refcount = 1;
d_ugen.c:    insig = (t_signal **)getbytes((u->u_nin + u->u_nout) * sizeof(t_signal *));
d_ugen.c:    outsig = insig + u->u_nin;
d_ugen.c:    for (sig = insig, uin = u->u_in, i = u->u_nin; i--; sig++, uin++)
d_ugen.c:        *sig = uin->i_signal;
d_ugen.c:        newrefcount = --(*sig)->s_refcount;
d_ugen.c:            (*sig)->s_refcount++;
d_ugen.c:    for (sig = outsig, uout = u->u_out, i = u->u_nout; i--; sig++, uout++)
d_ugen.c:            *sig = uout->o_signal =
d_ugen.c:                signal_new(0, dc->dc_srate);
d_ugen.c:            *sig = uout->o_signal = signal_new(dc->dc_vecsize, dc->dc_srate);
d_ugen.c:        (*sig)->s_refcount = uout->o_nconnect;
d_ugen.c:    mess1(&u->u_obj->ob_pd, gensym("dsp"), insig);
d_ugen.c:    for (sig = outsig, uout = u->u_out, i = u->u_nout; i--; sig++, uout++)
d_ugen.c:        if (!(*sig)->s_refcount)
d_ugen.c:        if (u->u_nin + u->u_nout == 0) post("put %s %d", 
d_ugen.c:            class_getname(u->u_obj->ob_pd), ugen_index(dc, u));
d_ugen.c:        else if (u->u_nin + u->u_nout == 1) post("put %s %d (%lx)", 
d_ugen.c:            class_getname(u->u_obj->ob_pd), ugen_index(dc, u), sig[0]);
d_ugen.c:        else if (u->u_nin + u->u_nout == 2) post("put %s %d (%lx %lx)", 
d_ugen.c:            class_getname(u->u_obj->ob_pd), ugen_index(dc, u),
d_ugen.c:            class_getname(u->u_obj->ob_pd), ugen_index(dc, u),
d_ugen.c:    for (uout = u->u_out, i = u->u_nout; i--; uout++)
d_ugen.c:        s1 = uout->o_signal;
d_ugen.c:        for (oc = uout->o_connections; oc; oc = oc->oc_next)
d_ugen.c:            u2 = oc->oc_who;
d_ugen.c:            uin = &u2->u_in[oc->oc_inno];
d_ugen.c:            if (s2 = uin->i_signal)
d_ugen.c:                s1->s_refcount--;
d_ugen.c:                s2->s_refcount--;
d_ugen.c:                    pd_error(u->u_obj, "%s: incompatible signal inputs",
d_ugen.c:                        class_getname(u->u_obj->ob_pd));
d_ugen.c:                dsp_add_plus(s1->s_vec, s2->s_vec, s3->s_vec, s1->s_n);
d_ugen.c:                uin->i_signal = s3;
d_ugen.c:                s3->s_refcount = 1;
d_ugen.c:                if (!s1->s_refcount) signal_makereusable(s1);
d_ugen.c:                if (!s2->s_refcount) signal_makereusable(s2);
d_ugen.c:            else uin->i_signal = s1;
d_ugen.c:            uin->i_ngot++;
d_ugen.c:            if (uin->i_ngot < uin->i_nconnect)
d_ugen.c:            if (u2->u_nin > 1)
d_ugen.c:                for (uin = u2->u_in, n = u2->u_nin; n--; uin++)
d_ugen.c:                    if (uin->i_ngot < uin->i_nconnect) goto notyet;
d_ugen.c:    t_freebytes(insig,(u->u_nin + u->u_nout) * sizeof(t_signal *));
d_ugen.c:    u->u_done = 1;
d_ugen.c:    t_dspcontext *parent_context = dc->dc_parentcontext;
d_ugen.c:        for (u = dc->dc_ugenlist; u; u = u->u_next)
d_ugen.c:            post("ugen: %s", class_getname(u->u_obj->ob_pd));
d_ugen.c:            for (uout = u->u_out, i = 0; i < u->u_nout; uout++, i++)
d_ugen.c:                for (oc = uout->o_connections; oc; oc = oc->oc_next)
d_ugen.c:                    class_getname(oc->oc_who->u_obj->ob_pd),
d_ugen.c:                        ugen_index(dc, oc->oc_who), oc->oc_inno);
d_ugen.c:    for (u = dc->dc_ugenlist, blk = 0; u; u = u->u_next)
d_ugen.c:        t_pd *zz = &u->u_obj->ob_pd;
d_ugen.c:        parent_srate = parent_context->dc_srate;
d_ugen.c:        parent_vecsize = parent_context->dc_vecsize;
d_ugen.c:        vecsize = blk->x_vecsize;
d_ugen.c:        calcsize = blk->x_calcsize;
d_ugen.c:        realoverlap = blk->x_overlap;
d_ugen.c:        downsample = blk->x_downsample;
d_ugen.c:        upsample   = blk->x_upsample;
d_ugen.c:        phase = blk->x_phase;
d_ugen.c:        blk->x_frequency = frequency;
d_ugen.c:        blk->x_period = period;
d_ugen.c:        blk->x_phase = dsp_phase & (period - 1);
d_ugen.c:        switched = blk->x_switched;
d_ugen.c:        calcsize = (parent_context ? parent_context->dc_calcsize : vecsize);
d_ugen.c:    dc->dc_reblock = reblock;
d_ugen.c:    dc->dc_switched = switched;
d_ugen.c:    dc->dc_srate = srate;
d_ugen.c:    dc->dc_vecsize = vecsize;
d_ugen.c:    dc->dc_calcsize = calcsize;
d_ugen.c:    if (dc->dc_iosigs && (switched || reblock))
d_ugen.c:        for (i = 0, sigp = dc->dc_iosigs + dc->dc_ninlets; i < dc->dc_noutlets;
d_ugen.c:            if ((*sigp)->s_isborrowed && !(*sigp)->s_borrowedfrom)
d_ugen.c:                (*sigp)->s_refcount++;
d_ugen.c:                if (ugen_loud) post("set %lx->%lx", *sigp,
d_ugen.c:                    (*sigp)->s_borrowedfrom);
d_ugen.c:    for (u = dc->dc_ugenlist; u; u = u->u_next)
d_ugen.c:        t_pd *zz = &u->u_obj->ob_pd;
d_ugen.c:        t_signal **insigs = dc->dc_iosigs, **outsigs = dc->dc_iosigs;
d_ugen.c:        if (outsigs) outsigs += dc->dc_ninlets;
d_ugen.c:                dc->dc_iosigs, vecsize, calcsize, dsp_phase, period, frequency,
d_ugen.c:        blk->x_chainonset = dsp_chainsize - 1;
d_ugen.c:    for (u = dc->dc_ugenlist; u; u = u->u_next)
d_ugen.c:        u->u_done = 0;
d_ugen.c:        for (uout = u->u_out, i = u->u_nout; i--; uout++)
d_ugen.c:            uout->o_nsent = 0;
d_ugen.c:        for (uin = u->u_in, i = u->u_nin; i--; uin++)
d_ugen.c:            uin->i_ngot = 0, uin->i_signal = 0;
d_ugen.c:    for (u = dc->dc_ugenlist; u; u = u->u_next)
d_ugen.c:        if (u->u_done) continue;
d_ugen.c:        for (uin = u->u_in, i = u->u_nin; i--; uin++)
d_ugen.c:            if (uin->i_nconnect) goto next;
d_ugen.c:    for (u = dc->dc_ugenlist; u; u = u->u_next)
d_ugen.c:        if (!u->u_done) 
d_ugen.c:        pd_error(u->u_obj,
d_ugen.c:        for (i = 0, sigp = dc->dc_iosigs + dc->dc_ninlets; i < dc->dc_noutlets;
d_ugen.c:            if ((*sigp)->s_isborrowed && !(*sigp)->s_borrowedfrom)
d_ugen.c:                (*sigp)->s_refcount++;
d_ugen.c:                dsp_add_zero(s3->s_vec, s3->s_n);
d_ugen.c:                    post("oops, belatedly set %lx->%lx", *sigp,
d_ugen.c:                        (*sigp)->s_borrowedfrom);
d_ugen.c:    for (u = dc->dc_ugenlist; u; u = u->u_next)
d_ugen.c:        t_pd *zz = &u->u_obj->ob_pd;
d_ugen.c:            t_signal **iosigs = dc->dc_iosigs;
d_ugen.c:            if (iosigs) iosigs += dc->dc_ninlets;
d_ugen.c:        blk->x_blocklength = chainblockend - chainblockbegin;
d_ugen.c:        blk->x_epiloglength = chainafterall - chainblockend;
d_ugen.c:        blk->x_reblock = reblock;
d_ugen.c:        if (!dc->dc_parentcontext)
d_ugen.c:            for (i = dsp_chainsize, ip = dsp_chain; i--; ip++)
d_ugen.c:    while (dc->dc_ugenlist)
d_ugen.c:        for (uout = dc->dc_ugenlist->u_out, n = dc->dc_ugenlist->u_nout;
d_ugen.c:            n--; uout++)
d_ugen.c:            oc = uout->o_connections;
d_ugen.c:                oc2 = oc->oc_next;
d_ugen.c:        freebytes(dc->dc_ugenlist->u_out, dc->dc_ugenlist->u_nout *
d_ugen.c:            sizeof (*dc->dc_ugenlist->u_out));
d_ugen.c:        freebytes(dc->dc_ugenlist->u_in, dc->dc_ugenlist->u_nin *
d_ugen.c:            sizeof(*dc->dc_ugenlist->u_in));
d_ugen.c:        u = dc->dc_ugenlist;
d_ugen.c:        dc->dc_ugenlist = u->u_next;
d_ugen.c:        ugen_currentcontext = dc->dc_parentcontext;
d_ugen.c:    if (ugen_currentcontext->dc_toplevel) return (0);
d_ugen.c:    if (inout) index += ugen_currentcontext->dc_ninlets;
d_ugen.c:    return (ugen_currentcontext->dc_iosigs[index]);
d_ugen.c:/* ------------------------ samplerate~~ -------------------------- */
d_ugen.c:    t_canvas *canvas = x->x_canvas;
d_ugen.c:            srate *= (t_float)(b->x_upsample) / (t_float)(b->x_downsample); 
d_ugen.c:    outlet_float(x->x_obj.ob_outlet, srate);
d_ugen.c:    outlet_new(&x->x_obj, &s_float);
d_ugen.c:    x->x_canvas = canvas_getcurrent();
d_ugen.c:/* -------------------- setup routine -------------------------- */
g_all_guis.c:/* Copyright (c) 1997-1999 Miller Puckette.
g_all_guis.c:/* g_7_guis.c written by Thomas Musil (c) IEM KUG Graz Austria 2000-2001 */
g_all_guis.c:/*------------------ global varaibles -------------------------*/
g_all_guis.c:    "<-99",
g_all_guis.c:    "-50",
g_all_guis.c:    "-30",
g_all_guis.c:    "-20",
g_all_guis.c:    "-12",
g_all_guis.c:    "-6",
g_all_guis.c:    "-2",
g_all_guis.c:    "-0dB",
g_all_guis.c:/*------------------ global functions -------------------------*/
g_all_guis.c:        col -= IEM_GUI_MAX_COLOR;
g_all_guis.c:    if (strlen(s->s_name) >= MAXPDSTRING)
g_all_guis.c:    for (s1 = s->s_name, s2 = buf; ; s1++, s2++)
g_all_guis.c:    if (strlen(s->s_name) >= MAXPDSTRING)
g_all_guis.c:    for (s1 = s->s_name, s2 = buf; ; s1++, s2++)
g_all_guis.c:    iemgui->x_fsf.x_put_in2out = 1;
g_all_guis.c:    if(iemgui->x_fsf.x_snd_able && iemgui->x_fsf.x_rcv_able)
g_all_guis.c:        if(!strcmp(iemgui->x_snd->s_name, iemgui->x_rcv->s_name))
g_all_guis.c:            iemgui->x_fsf.x_put_in2out = 0;
g_all_guis.c:        iemgui->x_snd = iemgui_new_dogetname(iemgui, indx, argv);
g_all_guis.c:        iemgui->x_rcv = iemgui_new_dogetname(iemgui, indx+1, argv);
g_all_guis.c:        iemgui->x_lab = iemgui_new_dogetname(iemgui, indx+2, argv);
g_all_guis.c:    else iemgui->x_snd = iemgui->x_rcv = iemgui->x_lab = gensym("empty");
g_all_guis.c:    iemgui->x_snd_unexpanded = iemgui->x_rcv_unexpanded =
g_all_guis.c:        iemgui->x_lab_unexpanded = 0;
g_all_guis.c:    iemgui->x_binbufindex = indx;
g_all_guis.c:    iemgui->x_labelbindex = indx + 3;
g_all_guis.c:    iemgui->x_snd_unexpanded = srlsym[0];
g_all_guis.c:    iemgui->x_rcv_unexpanded = srlsym[1];
g_all_guis.c:    iemgui->x_lab_unexpanded = srlsym[2];
g_all_guis.c:    srlsym[0] = canvas_realizedollar(iemgui->x_glist, srlsym[0]);
g_all_guis.c:    srlsym[1] = canvas_realizedollar(iemgui->x_glist, srlsym[1]);
g_all_guis.c:    srlsym[2] = canvas_realizedollar(iemgui->x_glist, srlsym[2]);
g_all_guis.c:        t_binbuf *b = iemgui->x_obj.ob_binbuf;
g_all_guis.c:    iemgui_init_sym2dollararg(iemgui, &iemgui->x_snd_unexpanded,
g_all_guis.c:        iemgui->x_binbufindex+1, iemgui->x_snd);
g_all_guis.c:    iemgui_init_sym2dollararg(iemgui, &iemgui->x_rcv_unexpanded,
g_all_guis.c:        iemgui->x_binbufindex+2, iemgui->x_rcv);
g_all_guis.c:    iemgui_init_sym2dollararg(iemgui, &iemgui->x_lab_unexpanded,
g_all_guis.c:        iemgui->x_labelbindex, iemgui->x_lab);
g_all_guis.c:    srlsym[0] = iemgui->x_snd_unexpanded;
g_all_guis.c:    srlsym[1] = iemgui->x_rcv_unexpanded;
g_all_guis.c:    srlsym[2] = iemgui->x_lab_unexpanded;
g_all_guis.c:    bflcol[0] = -1 - (((0xfc0000 & iemgui->x_bcol) >> 6)|
g_all_guis.c:                      ((0xfc00 & iemgui->x_bcol) >> 4)|((0xfc & iemgui->x_bcol) >> 2));
g_all_guis.c:    bflcol[1] = -1 - (((0xfc0000 & iemgui->x_fcol) >> 6)|
g_all_guis.c:                      ((0xfc00 & iemgui->x_fcol) >> 4)|((0xfc & iemgui->x_fcol) >> 2));
g_all_guis.c:    bflcol[2] = -1 - (((0xfc0000 & iemgui->x_lcol) >> 6)|
g_all_guis.c:                      ((0xfc00 & iemgui->x_lcol) >> 4)|((0xfc & iemgui->x_lcol) >> 2));
g_all_guis.c:        bflcol[0] = -1 - bflcol[0];
g_all_guis.c:        iemgui->x_bcol = ((bflcol[0] & 0x3f000) << 6)|((bflcol[0] & 0xfc0) << 4)|
g_all_guis.c:        iemgui->x_bcol = iemgui_color_hex[bflcol[0]];
g_all_guis.c:        bflcol[1] = -1 - bflcol[1];
g_all_guis.c:        iemgui->x_fcol = ((bflcol[1] & 0x3f000) << 6)|((bflcol[1] & 0xfc0) << 4)|
g_all_guis.c:        iemgui->x_fcol = iemgui_color_hex[bflcol[1]];
g_all_guis.c:        bflcol[2] = -1 - bflcol[2];
g_all_guis.c:        iemgui->x_lcol = ((bflcol[2] & 0x3f000) << 6)|((bflcol[2] & 0xfc0) << 4)|
g_all_guis.c:        iemgui->x_lcol = iemgui_color_hex[bflcol[2]];
g_all_guis.c:        return((-1 -i)&0xffffff);
g_all_guis.c:    if(iemgui->x_fsf.x_rcv_able)
g_all_guis.c:    if(iemgui->x_fsf.x_snd_able)
g_all_guis.c:    if(!strcmp(s->s_name, "empty")) sndable = 0;
g_all_guis.c:    iemgui->x_snd_unexpanded = snd;
g_all_guis.c:    iemgui->x_snd = snd = canvas_realizedollar(iemgui->x_glist, snd);
g_all_guis.c:    iemgui->x_fsf.x_snd_able = sndable;
g_all_guis.c:    (*iemgui->x_draw)(x, iemgui->x_glist, IEM_GUI_DRAW_MODE_IO + oldsndrcvable);
g_all_guis.c:    if(iemgui->x_fsf.x_rcv_able)
g_all_guis.c:    if(iemgui->x_fsf.x_snd_able)
g_all_guis.c:    if(!strcmp(s->s_name, "empty")) rcvable = 0;
g_all_guis.c:    iemgui->x_rcv_unexpanded = rcv;
g_all_guis.c:    rcv = canvas_realizedollar(iemgui->x_glist, rcv);
g_all_guis.c:        if(strcmp(rcv->s_name, iemgui->x_rcv->s_name))
g_all_guis.c:            if(iemgui->x_fsf.x_rcv_able)
g_all_guis.c:                pd_unbind(&iemgui->x_obj.ob_pd, iemgui->x_rcv);
g_all_guis.c:            iemgui->x_rcv = rcv;
g_all_guis.c:            pd_bind(&iemgui->x_obj.ob_pd, iemgui->x_rcv);
g_all_guis.c:    else if(!rcvable && iemgui->x_fsf.x_rcv_able)
g_all_guis.c:        pd_unbind(&iemgui->x_obj.ob_pd, iemgui->x_rcv);
g_all_guis.c:        iemgui->x_rcv = rcv;
g_all_guis.c:    iemgui->x_fsf.x_rcv_able = rcvable;
g_all_guis.c:    (*iemgui->x_draw)(x, iemgui->x_glist, IEM_GUI_DRAW_MODE_IO + oldsndrcvable);
g_all_guis.c:    old = iemgui->x_lab;
g_all_guis.c:    iemgui->x_lab_unexpanded = iemgui_raute2dollar(s);
g_all_guis.c:    iemgui->x_lab = canvas_realizedollar(iemgui->x_glist, iemgui->x_lab_unexpanded);
g_all_guis.c:    if(glist_isvisible(iemgui->x_glist) && iemgui->x_lab != old)
g_all_guis.c:        sys_vgui(".x%lx.c itemconfigure %lxLABEL -text {%s} \n",
g_all_guis.c:                 glist_getcanvas(iemgui->x_glist), x,
g_all_guis.c:                 strcmp(s->s_name, "empty")?iemgui->x_lab->s_name:"");
g_all_guis.c:    iemgui->x_ldx = (int)atom_getintarg(0, ac, av);
g_all_guis.c:    iemgui->x_ldy = (int)atom_getintarg(1, ac, av);
g_all_guis.c:    if(glist_isvisible(iemgui->x_glist))
g_all_guis.c:                 glist_getcanvas(iemgui->x_glist), x,
g_all_guis.c:                 text_xpix((t_object *)x,iemgui->x_glist)+iemgui->x_ldx,
g_all_guis.c:                 text_ypix((t_object *)x,iemgui->x_glist)+iemgui->x_ldy);
g_all_guis.c:    if(f == 1) strcpy(iemgui->x_font, "helvetica");
g_all_guis.c:    else if(f == 2) strcpy(iemgui->x_font, "times");
g_all_guis.c:        strcpy(iemgui->x_font, sys_font);
g_all_guis.c:    iemgui->x_fsf.x_font_style = f;
g_all_guis.c:    iemgui->x_fontsize = f;
g_all_guis.c:    if(glist_isvisible(iemgui->x_glist))
g_all_guis.c:        sys_vgui(".x%lx.c itemconfigure %lxLABEL -font {{%s} -%d %s}\n",
g_all_guis.c:                 glist_getcanvas(iemgui->x_glist), x, iemgui->x_font, 
g_all_guis.c:                 iemgui->x_fontsize, sys_fontweight);
g_all_guis.c:    if(glist_isvisible(iemgui->x_glist))
g_all_guis.c:        (*iemgui->x_draw)(x, iemgui->x_glist, IEM_GUI_DRAW_MODE_MOVE);
g_all_guis.c:        canvas_fixlinesfor(iemgui->x_glist, (t_text*)x);
g_all_guis.c:    iemgui->x_obj.te_xpix += (int)atom_getintarg(0, ac, av);
g_all_guis.c:    iemgui->x_obj.te_ypix += (int)atom_getintarg(1, ac, av);
g_all_guis.c:    if(glist_isvisible(iemgui->x_glist))
g_all_guis.c:        (*iemgui->x_draw)(x, iemgui->x_glist, IEM_GUI_DRAW_MODE_MOVE);
g_all_guis.c:        canvas_fixlinesfor(iemgui->x_glist, (t_text*)x);
g_all_guis.c:    iemgui->x_obj.te_xpix = (int)atom_getintarg(0, ac, av);
g_all_guis.c:    iemgui->x_obj.te_ypix = (int)atom_getintarg(1, ac, av);
g_all_guis.c:    if(glist_isvisible(iemgui->x_glist))
g_all_guis.c:        (*iemgui->x_draw)(x, iemgui->x_glist, IEM_GUI_DRAW_MODE_MOVE);
g_all_guis.c:        canvas_fixlinesfor(iemgui->x_glist, (t_text*)x);
g_all_guis.c:    iemgui->x_bcol = iemgui_compatible_col(atom_getintarg(0, ac, av));
g_all_guis.c:        iemgui->x_fcol = iemgui_compatible_col(atom_getintarg(1, ac, av));
g_all_guis.c:        iemgui->x_lcol = iemgui_compatible_col(atom_getintarg(2, ac, av));
g_all_guis.c:        iemgui->x_lcol = iemgui_compatible_col(atom_getintarg(1, ac, av));
g_all_guis.c:    if(glist_isvisible(iemgui->x_glist))
g_all_guis.c:        (*iemgui->x_draw)(x, iemgui->x_glist, IEM_GUI_DRAW_MODE_CONFIG);
g_all_guis.c:    x->x_gui.x_obj.te_xpix += dx;
g_all_guis.c:    x->x_gui.x_obj.te_ypix += dy;
g_all_guis.c:    (*x->x_gui.x_draw)((void *)z, glist, IEM_GUI_DRAW_MODE_MOVE);
g_all_guis.c:    x->x_gui.x_fsf.x_selected = selected;
g_all_guis.c:    (*x->x_gui.x_draw)((void *)z, glist, IEM_GUI_DRAW_MODE_SELECT);
g_all_guis.c:        (*x->x_gui.x_draw)((void *)z, glist, IEM_GUI_DRAW_MODE_NEW);
g_all_guis.c:        (*x->x_gui.x_draw)((void *)z, glist, IEM_GUI_DRAW_MODE_ERASE);
g_all_guis.c:    srl[0] = iemgui->x_snd;
g_all_guis.c:    srl[1] = iemgui->x_rcv;
g_all_guis.c:    srl[2] = iemgui->x_lab;
g_all_guis.c:    srl[0] = iemgui->x_snd;
g_all_guis.c:    srl[1] = iemgui->x_rcv;
g_all_guis.c:    srl[2] = iemgui->x_lab;
g_all_guis.c:    if(iemgui->x_fsf.x_rcv_able)
g_all_guis.c:    if(iemgui->x_fsf.x_snd_able)
g_all_guis.c:    iemgui->x_isa.x_loadinit = init;
g_all_guis.c:    if(!strcmp(srl[0]->s_name, "empty")) sndable = 0;
g_all_guis.c:    if(!strcmp(srl[1]->s_name, "empty")) rcvable = 0;
g_all_guis.c:        if(strcmp(srl[1]->s_name, iemgui->x_rcv->s_name))
g_all_guis.c:            if(iemgui->x_fsf.x_rcv_able)
g_all_guis.c:                pd_unbind(&iemgui->x_obj.ob_pd, iemgui->x_rcv);
g_all_guis.c:            iemgui->x_rcv = srl[1];
g_all_guis.c:            pd_bind(&iemgui->x_obj.ob_pd, iemgui->x_rcv);
g_all_guis.c:    else if(!rcvable && iemgui->x_fsf.x_rcv_able)
g_all_guis.c:        pd_unbind(&iemgui->x_obj.ob_pd, iemgui->x_rcv);
g_all_guis.c:        iemgui->x_rcv = srl[1];
g_all_guis.c:    iemgui->x_snd = srl[0];
g_all_guis.c:    iemgui->x_fsf.x_snd_able = sndable;
g_all_guis.c:    iemgui->x_fsf.x_rcv_able = rcvable;
g_all_guis.c:    iemgui->x_lcol = lcol & 0xffffff;
g_all_guis.c:    iemgui->x_fcol = fcol & 0xffffff;
g_all_guis.c:    iemgui->x_bcol = bcol & 0xffffff;
g_all_guis.c:    iemgui->x_lab = srl[2];
g_all_guis.c:    iemgui->x_ldx = ldx;
g_all_guis.c:    iemgui->x_ldy = ldy;
g_all_guis.c:    if(f == 1) strcpy(iemgui->x_font, "helvetica");
g_all_guis.c:    else if(f == 2) strcpy(iemgui->x_font, "times");
g_all_guis.c:        strcpy(iemgui->x_font, sys_font);
g_all_guis.c:    iemgui->x_fsf.x_font_style = f;
g_all_guis.c:    iemgui->x_fontsize = fs;
g_all_guis.c:    canvas_dirty(iemgui->x_glist, 1);
g_all_guis.c:    symargp->x_loadinit = (n >>  0);
g_all_guis.c:    symargp->x_scale = (n >>  20);
g_all_guis.c:    symargp->x_flashed = 0;
g_all_guis.c:    symargp->x_locked = 0;
g_all_guis.c:    symargp->x_reverse = 0;
g_all_guis.c:    symargp->dummy = 0;
g_all_guis.c:        (((symargp->x_loadinit & 1) <<  0) |
g_all_guis.c:        ((symargp->x_scale & 1) <<  20)));
g_all_guis.c:    fstylep->x_font_style = (n >> 0);
g_all_guis.c:    fstylep->x_shiftdown = 0;
g_all_guis.c:    fstylep->x_selected = 0;
g_all_guis.c:    fstylep->x_finemoved = 0;
g_all_guis.c:    fstylep->x_put_in2out = 0;
g_all_guis.c:    fstylep->x_change = 0;
g_all_guis.c:    fstylep->x_thick = 0;
g_all_guis.c:    fstylep->x_lin0_log1 = 0;
g_all_guis.c:    fstylep->x_steady = 0;
g_all_guis.c:    fstylep->dummy = 0;
g_all_guis.c:    return ((fstylep->x_font_style << 0) & 63);
g_all_guis.h:/* Copyright (c) 1997-1999 Miller Puckette.
g_all_guis.h:/* g_7_guis.h written by Thomas Musil (c) IEM KUG Graz Austria 2000-2001 */
g_all_guis.h:#define IEM_VU_MINDB    -99.9
g_all_guis.h:#define IS_A_POINTER(atom,index) ((atom+index)->a_type == A_POINTER)
g_all_guis.h:#define IS_A_FLOAT(atom,index) ((atom+index)->a_type == A_FLOAT)
g_all_guis.h:#define IS_A_SYMBOL(atom,index) ((atom+index)->a_type == A_SYMBOL)
g_all_guis.h:#define IS_A_DOLLAR(atom,index) ((atom+index)->a_type == A_DOLLAR)
g_all_guis.h:#define IS_A_DOLLSYM(atom,index) ((atom+index)->a_type == A_DOLLSYM)
g_array.c:/* Copyright (c) 1997-1999 Miller Puckette.
g_array.c:    if (*s->s_name == '#')
g_array.c:        strncpy(buf, s->s_name, MAXPDSTRING);
g_array.c:        buf[MAXPDSTRING-1] = 0;
g_array.c:/* --------- "pure" arrays with scalars for elements. --------------- */
g_array.c:    x->a_templatesym = templatesym;
g_array.c:    x->a_n = 1;
g_array.c:    x->a_elemsize = sizeof(t_word) * template->t_n;
g_array.c:    x->a_vec = (char *)getbytes(x->a_elemsize);
g_array.c:    x->a_gp = *parent;
g_array.c:    x->a_stub = gstub_new(0, x);
g_array.c:    word_init((t_word *)(x->a_vec), template, parent);
g_array.c:    t_template *template = template_findbyname(x->a_templatesym);
g_array.c:    oldn = x->a_n;
g_array.c:    elemsize = sizeof(t_word) * template->t_n;
g_array.c:    x->a_vec = (char *)resizebytes(x->a_vec, oldn * elemsize, n * elemsize);
g_array.c:    x->a_n = n;
g_array.c:        char *cp = x->a_vec + elemsize * oldn;
g_array.c:        int i = n - oldn;
g_array.c:        for (; i--; cp += elemsize)
g_array.c:            word_init(wp, template, &x->a_gp);
g_array.c:    x->a_valid = ++glist_valid;
g_array.c:    while (a2->a_gp.gp_stub->gs_which == GP_ARRAY)
g_array.c:        a2 = a2->a_gp.gp_stub->gs_un.gs_array;
g_array.c:        gobj_vis(&a2->a_gp.gp_un.gp_scalar->sc_gobj, glist, 0);
g_array.c:        gobj_vis(&a2->a_gp.gp_un.gp_scalar->sc_gobj, glist, 1);
g_array.c:    t_template *scalartemplate = template_findbyname(x->a_templatesym);
g_array.c:    gstub_cutoff(x->a_stub);
g_array.c:    for (i = 0; i < x->a_n; i++)
g_array.c:        t_word *wp = (t_word *)(x->a_vec + x->a_elemsize * i);
g_array.c:    freebytes(x->a_vec, x->a_elemsize * x->a_n);
g_array.c:/* --------------------- graphical arrays (garrays) ------------------- */
g_array.c:/* create invisible, built-in canvases to determine the templates for floats
g_array.c:and float-arrays. */
g_array.c:/* create a new scalar attached to a symbol.  Used to make floating-point
g_array.c:    x->x_scalar = scalar_new(gl, templatesym);
g_array.c:    x->x_name = s;
g_array.c:    x->x_realname = canvas_realizedollar(gl, s);
g_array.c:    pd_bind(&x->x_gobj.g_pd, x->x_realname);
g_array.c:    x->x_usedindsp = 0;
g_array.c:    x->x_saveit = saveit;
g_array.c:    x->x_listviewing = 0;
g_array.c:    glist_add(gl, &x->x_gobj);
g_array.c:    x->x_glist = gl;
g_array.c:    t_scalar *sc = x->x_scalar;
g_array.c:    t_symbol *templatesym = sc->sc_template;
g_array.c:        error("array: couldn't find template %s", templatesym->s_name);
g_array.c:        error("array: template %s has no 'z' field", templatesym->s_name);
g_array.c:            templatesym->s_name);
g_array.c:    return (sc->sc_vec[zonset].w_array);
g_array.c:    t_template *template = template_findbyname(a->a_templatesym);
g_array.c:    *elemsizep = a->a_elemsize;
g_array.c:    *namep = x->x_name;
g_array.c:    return (x->x_hidename);
g_array.c:    t_glist *gl = x->x_glist;
g_array.c:    if (gl->gl_list == &x->x_gobj && !x->x_gobj.g_next)
g_array.c:        vmess(&gl->gl_pd, gensym("bounds"), "ffff",
g_array.c:            0., gl->gl_y1, (double)
g_array.c:                (style == PLOTSTYLE_POINTS || n == 1 ? n : n-1),
g_array.c:                    gl->gl_y2);
g_array.c:    array_resize_and_redraw(array, x->x_glist, n);
g_array.c:        error("array %s: only 'float' type understood", templateargsym->s_name);
g_array.c:    templatesym = gensym("pd-_float_array");
g_array.c:        error("array: couldn't find template %s", templatesym->s_name);
g_array.c:        error("array: template %s has no 'z' field", templatesym->s_name);
g_array.c:            templatesym->s_name);
g_array.c:        error("array: no template of type %s", zarraytype->s_name);
g_array.c:    x->x_hidename = ((flags & 8) >> 3);
g_array.c:    array_resize(x->x_scalar->sc_vec[zonset].w_array, n);
g_array.c:    template_setfloat(template, gensym("style"), x->x_scalar->sc_vec,
g_array.c:    template_setfloat(template, gensym("linewidth"), x->x_scalar->sc_vec, 
g_array.c:           /* bashily unbind #A -- this would create garbage if #A were
g_array.c:    asym->s_thing = 0;
g_array.c:    pd_bind(&x->x_gobj.g_pd, asym); 
g_array.c:    gfxstub_new(&x->gl_pd, x, cmdbuf);
g_array.c:    t_scalar *sc = x->x_scalar;
g_array.c:    sprintf(cmdbuf, ((x->x_name->s_name[0] == '$') ?
g_array.c:            x->x_name->s_name, a->a_n, x->x_saveit + 
g_array.c:            2 * (int)(template_getfloat(template_findbyname(sc->sc_template),
g_array.c:            gensym("style"), x->x_scalar->sc_vec, 1)));
g_array.c:    gfxstub_new(&x->x_gobj.g_pd, x, cmdbuf);
g_array.c:            (size > 1 ? size-1 : size), -1, 0, 0, 0, 0);
g_array.c:        template_findbyname(x->x_scalar->sc_template),
g_array.c:            gensym("style"), x->x_scalar->sc_vec, 1);
g_array.c:        int wasused = x->x_usedindsp;
g_array.c:        glist_delete(x->x_glist, &x->x_gobj);
g_array.c:        if (!(scalartemplate = template_findbyname(x->x_scalar->sc_template)))
g_array.c:                x->x_scalar->sc_template->s_name);
g_array.c:        if (argname != x->x_name)
g_array.c:            if (x->x_listviewing)
g_array.c:            x->x_name = argname;
g_array.c:            pd_unbind(&x->x_gobj.g_pd, x->x_realname);
g_array.c:            x->x_realname = canvas_realizedollar(x->x_glist, argname);
g_array.c:            pd_bind(&x->x_gobj.g_pd, x->x_realname);
g_array.c:            if (x->x_glist->gl_havewindow)
g_array.c:                canvas_redraw(x->x_glist);
g_array.c:            else if (glist_isvisible(x->x_glist->gl_owner))
g_array.c:                gobj_vis(&x->x_glist->gl_gobj, x->x_glist->gl_owner, 0);
g_array.c:                gobj_vis(&x->x_glist->gl_gobj, x->x_glist->gl_owner, 1);
g_array.c:        if (size != a->a_n)
g_array.c:            x->x_scalar->sc_vec, (t_float)style, 0);
g_array.c:        canvas_dirty(x->x_glist, 1);
g_array.c:    x->x_listviewing = 1;
g_array.c:            x->x_realname->s_name,
g_array.c:    gfxstub_new(&x->x_gobj.g_pd, x, cmdbuf);
g_array.c:    for (i = 0; i < ARRAYPAGESIZE && i < a->a_n; i++)
g_array.c:        yval = *(t_float *)(a->a_vec +
g_array.c:                 x->x_realname->s_name,
g_array.c:               x->x_realname->s_name,
g_array.c:    else if ((page * ARRAYPAGESIZE) >= a->a_n) {
g_array.c:      page = (int)(((int)a->a_n - 1)/ (int)ARRAYPAGESIZE);
g_array.c:               x->x_realname->s_name,
g_array.c:             x->x_realname->s_name,
g_array.c:             ARRAYPAGESIZE - 1);
g_array.c:         (i < (page + 1) * ARRAYPAGESIZE && i < a->a_n);
g_array.c:        yval = *(t_float *)(a->a_vec + \
g_array.c:                 x->x_realname->s_name,
g_array.c:             x->x_realname->s_name,
g_array.c:    x->x_listviewing = 0;
g_array.c:             x->x_realname->s_name);
g_array.c:        sys_unqueuegui(&x->x_gobj);
g_array.c:        if (x->x_listviewing)
g_array.c:    pd_unbind(&x->x_gobj.g_pd, x->x_realname);
g_array.c:    pd_free(&x->x_scalar->sc_gobj.g_pd);
g_array.c:/* ------------- code used by both array and plot widget functions ---- */
g_array.c:    while (a->a_gp.gp_stub->gs_which == GP_ARRAY)
g_array.c:        a = a->a_gp.gp_stub->gs_un.gs_array;
g_array.c:    scalar_redraw(a->a_gp.gp_un.gp_scalar, glist);
g_array.c:                fielddesc_cvttocoord(wfielddesc, wval)) - ypix;
g_array.c:            wpix = -wpix;
g_array.c:            /* a y-only plot. */
g_array.c:        t_float ydiff = newy - oldy;
g_array.c:            thisx = array_motion_npoints - 1;
g_array.c:        increment = (thisx > array_motion_lastx ? -1 : 1);
g_array.c:        nchange = 1 + increment * (array_motion_lastx - thisx);
g_array.c:                newy -= ydiff * (1./(nchange - 1));
g_array.c:    if (array->a_n < 2000)
g_array.c:    else incr = array->a_n / 300;
g_array.c:    for (i = 0, xsum = 0; i < array->a_n; i += incr)
g_array.c:                *(t_float *)(((char *)(array->a_vec) + elemsize * i) + xonset));
g_array.c:            *(t_float *)(((char *)(array->a_vec) + elemsize * i) + yonset)) : 0);
g_array.c:            (t_word *)((char *)(array->a_vec) + i * elemsize),
g_array.c:        int incr = (array->a_n <= 2000 ? 1 : array->a_n / 1000);
g_array.c:        for (i = 0; i < array->a_n; i += incr)
g_array.c:            array_getcoordinate(glist, (char *)(array->a_vec) + i * elemsize,
g_array.c:            dx = pxpix - xpix;
g_array.c:            if (dx < 0) dx = -dx;
g_array.c:            dy = pypix - ypix;
g_array.c:            if (dy < 0) dy = -dy;
g_array.c:                dy = (pypix + pwpix) - ypix;
g_array.c:                if (dy < 0) dy = -dy;
g_array.c:                dy = (pypix - pwpix) - ypix;
g_array.c:                if (dy < 0) dy = -dy;
g_array.c:        for (i = 0; i < array->a_n; i += incr)
g_array.c:            array_getcoordinate(glist, (char *)(array->a_vec) + i * elemsize,
g_array.c:            dx = pxpix - xpix;
g_array.c:            if (dx < 0) dx = -dx;
g_array.c:            dy = pypix - ypix;
g_array.c:            if (dy < 0) dy = -dy;
g_array.c:                dy2 = (pypix + pwpix) - ypix;
g_array.c:                if (dy2 < 0) dy2 = -dy2;
g_array.c:                dy3 = (pypix - pwpix) - ypix;
g_array.c:                if (dy3 < 0) dy3 = -dy3;
g_array.c:                    array_motion_fatten = -1;
g_array.c:                    char *elem = (char *)array->a_vec;
g_array.c:                        if (array->a_n <= 1)
g_array.c:                        memmove((char *)(array->a_vec) + elemsize * i, 
g_array.c:                            (char *)(array->a_vec) + elemsize * (i+1),
g_array.c:                                (array->a_n - 1 - i) * elemsize);
g_array.c:                        array_resize_and_redraw(array, glist, array->a_n - 1);
g_array.c:                        /* add a point (after the clicked-on one) */
g_array.c:                        array_resize_and_redraw(array, glist, array->a_n + 1);
g_array.c:                        elem = (char *)array->a_vec;
g_array.c:                                (array->a_n - i - 1) * elemsize);
g_array.c:                            array_motion_npoints = array->a_n - i;
g_array.c:                        array_motion_npoints = array->a_n;
g_array.c:                        array_motion_yperpix *= -array_motion_fatten;
g_array.c:    t_float x1 = 0x7fffffff, y1 = 0x7fffffff, x2 = -0x7fffffff, y2 = -0x7fffffff;
g_array.c:    if (!array_getfields(array->a_templatesym, &elemtemplatecanvas,
g_array.c:        if (array->a_n < 2000)
g_array.c:        else incr = array->a_n / 300;
g_array.c:        for (i = 0; i < array->a_n; i += incr)
g_array.c:            array_getcoordinate(glist, (char *)(array->a_vec) +
g_array.c:            if (pypix - pwpix < y1)
g_array.c:                y1 = pypix - pwpix;
g_array.c:/* -------------------- widget behavior for garray ------------ */
g_array.c:    gobj_getrect(&x->x_scalar->sc_gobj, glist, xp1, yp1, xp2, yp2);
g_array.c:    gobj_vis(&x->x_scalar->sc_gobj, glist, vis);
g_array.c:    return (gobj_click(&x->x_scalar->sc_gobj, glist,
g_array.c:    if (x->x_scalar->sc_template != gensym("pd-_float_array"))
g_array.c:            x->x_scalar->sc_template->s_name);
g_array.c:    if (!(scalartemplate = template_findbyname(x->x_scalar->sc_template)))
g_array.c:            x->x_scalar->sc_template->s_name);
g_array.c:            x->x_scalar->sc_vec, 0);    
g_array.c:        x->x_name, array->a_n, &s_float,
g_array.c:            x->x_saveit + 2 * filestyle + 8*x->x_hidename);
g_array.c:    if (x->x_saveit)
g_array.c:        int n = array->a_n, n2 = 0;
g_array.c:            int chunk = n - n2, i;
g_array.c:                binbuf_addv(b, "f", ((t_word *)(array->a_vec))[n2+i].w_float);
g_array.c:/* ----------------------- public functions -------------------- */
g_array.c:    x->x_usedindsp = 1;
g_array.c:    if (glist_isvisible(x->x_glist))
g_array.c:        garray_vis(&x->x_gobj, x->x_glist, 0); 
g_array.c:        garray_vis(&x->x_gobj, x->x_glist, 1);
g_array.c:    if (glist_isvisible(x->x_glist))
g_array.c:        sys_queuegui(&x->x_gobj, x->x_glist, garray_doredraw);
g_array.c:      if (x->x_listviewing)
g_array.c:                 x->x_realname->s_name);
g_array.c:        (array ? template_findbyname(array->a_templatesym) : 0);
g_array.c:    return (array->a_n);
g_array.c:    return ((char *)(array->a_vec));
g_array.c:        error("%s: needs floating-point 'y' field", x->x_realname->s_name);
g_array.c:        error("%s: has more than one field", x->x_realname->s_name);
g_array.c:    /* older, non-64-bit safe version, supplied for older externs */
g_array.c:        if (x->x_glist->gl_owner)
g_array.c:            patchname = x->x_glist->gl_owner->gl_name;
g_array.c:            patchname = x->x_glist->gl_name;
g_array.c:              x->x_name->s_name, patchname->s_name);
g_array.c:        error("failed since it uses garray_getfloatarray while running 64-bit!");
g_array.c:    if (x->x_saveit && !saveit)
g_array.c:        post("warning: array %s: clearing save-in-patch flag",
g_array.c:            x->x_name->s_name);
g_array.c:    x->x_saveit = saveit;
g_array.c:/*------------------- Pd messages ------------------------ */
g_array.c:        error("%s: needs floating-point 'y' field", x->x_realname->s_name);
g_array.c:    else for (i = 0; i < array->a_n; i++)
g_array.c:        *((t_float *)((char *)array->a_vec
g_array.c:        error("%s: needs floating-point 'y' field", x->x_realname->s_name);
g_array.c:        post("%s: rounnding to %d points", array->a_templatesym->s_name,
g_array.c:    for (i = 0, phase = -phaseincr; i < array->a_n; i++, phase += phaseincr)
g_array.c:        *((t_float *)((array->a_vec + elemsize * i)) + yonset)
g_array.c:            x->x_realname->s_name);
g_array.c:    argv++, argc--;
g_array.c:            x->x_realname->s_name);
g_array.c:    argv++, argc--;
g_array.c:        error("%s: needs floating-point 'y' field", x->x_realname->s_name);
g_array.c:    for (i = 0, maxv = 0; i < array->a_n; i++)
g_array.c:        double v = *((t_float *)(array->a_vec + elemsize * i)
g_array.c:        if (-v > maxv)
g_array.c:            maxv = -v;
g_array.c:        for (i = 0; i < array->a_n; i++)
g_array.c:            *((t_float *)(array->a_vec + elemsize * i) + yonset)
g_array.c:    /* list -- the first value is an index; subsequent values are put in
g_array.c:        error("%s: needs floating-point 'y' field", x->x_realname->s_name);
g_array.c:        argc--;
g_array.c:            argv -= firstindex;
g_array.c:        if (argc + firstindex > array->a_n)
g_array.c:            argc = array->a_n - firstindex;
g_array.c:            *((t_float *)(array->a_vec + elemsize * (i + firstindex)) + yonset)
g_array.c:    vmess(&x->x_glist->gl_pd, gensym("bounds"), "ffff", x1, y1, x2, y2);
g_array.c:    vmess(&x->x_glist->gl_pd, gensym("xticks"), "fff", point, inc, f);
g_array.c:    vmess(&x->x_glist->gl_pd, gensym("yticks"), "fff", point, inc, f);
g_array.c:    typedmess(&x->x_glist->gl_pd, s, argc, argv);
g_array.c:    typedmess(&x->x_glist->gl_pd, s, argc, argv);
g_array.c:    if (x->x_listviewing)
g_array.c:    pd_unbind(&x->x_gobj.g_pd, x->x_realname);
g_array.c:    pd_bind(&x->x_gobj.g_pd, x->x_realname = x->x_name = s);
g_array.c:        error("%s: needs floating-point 'y' field", x->x_realname->s_name);
g_array.c:    nelem = array->a_n;
g_array.c:    if ((filedesc = canvas_open(glist_getcanvas(x->x_glist),
g_array.c:            filename->s_name, "", buf, &bufptr, MAXPDSTRING, 0)) < 0 
g_array.c:        error("%s: can't open", filename->s_name);
g_array.c:                filename->s_name, i, nelem);
g_array.c:        else *((t_float *)(array->a_vec + elemsize * i) + yonset) = f;
g_array.c:        *((t_float *)(array->a_vec +
g_array.c:        error("%s: needs floating-point 'y' field", x->x_realname->s_name);
g_array.c:    canvas_makefilename(glist_getcanvas(x->x_glist), filename->s_name,
g_array.c:    for (i = 0; i < array->a_n; i++)
g_array.c:            *(t_float *)(((array->a_vec + sizeof(t_word) * i)) + yonset)) < 1)
g_array.c:            post("%s: write error", filename->s_name);
g_array.c:    t_glist *gl = x->x_glist;
g_array.c:        template_findbyname(x->x_scalar->sc_template),
g_array.c:            gensym("style"), x->x_scalar->sc_vec, 1));
g_array.c:    array_resize_and_redraw(array, x->x_glist, n);
g_array.c:    if (x->x_usedindsp)
g_array.c:        x->x_realname->s_name, array->a_templatesym->s_name, array->a_n);
g_bang.c:/* Copyright (c) 1997-1999 Miller Puckette.
g_bang.c:/* g_7_guis.c written by Thomas Musil (c) IEM KUG Graz Austria 2000-2001 */
g_bang.c:/* --------------- bng     gui-bang ------------------------- */
g_bang.c:        sys_vgui(".x%lx.c itemconfigure %lxBUT -fill #%6.6x\n", glist_getcanvas(glist), x,
g_bang.c:                 x->x_flashed?x->x_gui.x_fcol:x->x_gui.x_bcol);
g_bang.c:    int xpos=text_xpix(&x->x_gui.x_obj, glist);
g_bang.c:    int ypos=text_ypix(&x->x_gui.x_obj, glist);
g_bang.c:    sys_vgui(".x%lx.c create rectangle %d %d %d %d -fill #%6.6x -tags %lxBASE\n",
g_bang.c:             xpos + x->x_gui.x_w, ypos + x->x_gui.x_h,
g_bang.c:             x->x_gui.x_bcol, x);
g_bang.c:    sys_vgui(".x%lx.c create oval %d %d %d %d -fill #%6.6x -tags %lxBUT\n",
g_bang.c:             xpos + x->x_gui.x_w-1, ypos + x->x_gui.x_h-1,
g_bang.c:             x->x_flashed?x->x_gui.x_fcol:x->x_gui.x_bcol, x);
g_bang.c:    sys_vgui(".x%lx.c create text %d %d -text {%s} -anchor w \
g_bang.c:             -font {{%s} -%d %s} -fill #%6.6x -tags [list %lxLABEL label text]\n",
g_bang.c:             canvas, xpos+x->x_gui.x_ldx,
g_bang.c:             ypos+x->x_gui.x_ldy,
g_bang.c:             strcmp(x->x_gui.x_lab->s_name, "empty")?x->x_gui.x_lab->s_name:"",
g_bang.c:             x->x_gui.x_font, x->x_gui.x_fontsize, sys_fontweight,
g_bang.c:             x->x_gui.x_lcol, x);
g_bang.c:    if(!x->x_gui.x_fsf.x_snd_able)
g_bang.c:        sys_vgui(".x%lx.c create rectangle %d %d %d %d -tags [list %lxOUT%d outlet]\n",
g_bang.c:             ypos + x->x_gui.x_h-1, xpos + IOWIDTH,
g_bang.c:             ypos + x->x_gui.x_h, x, 0);
g_bang.c:    if(!x->x_gui.x_fsf.x_rcv_able)
g_bang.c:        sys_vgui(".x%lx.c create rectangle %d %d %d %d -tags [list %lxIN%d inlet]\n",
g_bang.c:    int xpos=text_xpix(&x->x_gui.x_obj, glist);
g_bang.c:    int ypos=text_ypix(&x->x_gui.x_obj, glist);
g_bang.c:             xpos + x->x_gui.x_w, ypos + x->x_gui.x_h);
g_bang.c:             xpos + x->x_gui.x_w-1, ypos + x->x_gui.x_h-1);
g_bang.c:    sys_vgui(".x%lx.c itemconfigure %lxBUT -fill #%6.6x\n", canvas, x,
g_bang.c:             x->x_flashed?x->x_gui.x_fcol:x->x_gui.x_bcol);
g_bang.c:             canvas, x, xpos+x->x_gui.x_ldx, ypos+x->x_gui.x_ldy);
g_bang.c:    if(!x->x_gui.x_fsf.x_snd_able)
g_bang.c:             ypos + x->x_gui.x_h-1, xpos + IOWIDTH,
g_bang.c:             ypos + x->x_gui.x_h);
g_bang.c:    if(!x->x_gui.x_fsf.x_rcv_able)
g_bang.c:    if(!x->x_gui.x_fsf.x_snd_able)
g_bang.c:    if(!x->x_gui.x_fsf.x_rcv_able)
g_bang.c:    sys_vgui(".x%lx.c itemconfigure %lxLABEL -font {{%s} -%d %s} -fill #%6.6x -text {%s} \n",
g_bang.c:             canvas, x, x->x_gui.x_font, x->x_gui.x_fontsize, sys_fontweight,
g_bang.c:             x->x_gui.x_fsf.x_selected?IEM_GUI_COLOR_SELECTED:x->x_gui.x_lcol,
g_bang.c:             strcmp(x->x_gui.x_lab->s_name, "empty")?x->x_gui.x_lab->s_name:"");
g_bang.c:    sys_vgui(".x%lx.c itemconfigure %lxBASE -fill #%6.6x\n", canvas, x, x->x_gui.x_bcol);
g_bang.c:    sys_vgui(".x%lx.c itemconfigure %lxBUT -fill #%6.6x\n", canvas, x,
g_bang.c:             x->x_flashed?x->x_gui.x_fcol:x->x_gui.x_bcol);
g_bang.c:    int xpos=text_xpix(&x->x_gui.x_obj, glist);
g_bang.c:    int ypos=text_ypix(&x->x_gui.x_obj, glist);
g_bang.c:    if((old_snd_rcv_flags & IEM_GUI_OLD_SND_FLAG) && !x->x_gui.x_fsf.x_snd_able)
g_bang.c:        sys_vgui(".x%lx.c create rectangle %d %d %d %d -tags %lxOUT%d\n",
g_bang.c:             ypos + x->x_gui.x_h-1, xpos + IOWIDTH,
g_bang.c:             ypos + x->x_gui.x_h, x, 0);
g_bang.c:    if(!(old_snd_rcv_flags & IEM_GUI_OLD_SND_FLAG) && x->x_gui.x_fsf.x_snd_able)
g_bang.c:    if((old_snd_rcv_flags & IEM_GUI_OLD_RCV_FLAG) && !x->x_gui.x_fsf.x_rcv_able)
g_bang.c:        sys_vgui(".x%lx.c create rectangle %d %d %d %d -tags %lxIN%d\n",
g_bang.c:    if(!(old_snd_rcv_flags & IEM_GUI_OLD_RCV_FLAG) && x->x_gui.x_fsf.x_rcv_able)
g_bang.c:    if(x->x_gui.x_fsf.x_selected)
g_bang.c:        sys_vgui(".x%lx.c itemconfigure %lxBASE -outline #%6.6x\n", canvas, x, IEM_GUI_COLOR_SELECTED);
g_bang.c:        sys_vgui(".x%lx.c itemconfigure %lxBUT -outline #%6.6x\n", canvas, x, IEM_GUI_COLOR_SELECTED);
g_bang.c:        sys_vgui(".x%lx.c itemconfigure %lxLABEL -fill #%6.6x\n", canvas, x, IEM_GUI_COLOR_SELECTED);
g_bang.c:        sys_vgui(".x%lx.c itemconfigure %lxBASE -outline #%6.6x\n", canvas, x, IEM_GUI_COLOR_NORMAL);
g_bang.c:        sys_vgui(".x%lx.c itemconfigure %lxBUT -outline #%6.6x\n", canvas, x, IEM_GUI_COLOR_NORMAL);
g_bang.c:        sys_vgui(".x%lx.c itemconfigure %lxLABEL -fill #%6.6x\n", canvas, x, x->x_gui.x_lcol);
g_bang.c:        bng_draw_io(x, glist, mode - IEM_GUI_DRAW_MODE_IO);
g_bang.c:/* ------------------------ bng widgetbehaviour----------------------------- */
g_bang.c:    *xp1 = text_xpix(&x->x_gui.x_obj, glist);
g_bang.c:    *yp1 = text_ypix(&x->x_gui.x_obj, glist);
g_bang.c:    *xp2 = *xp1 + x->x_gui.x_w;
g_bang.c:    *yp2 = *yp1 + x->x_gui.x_h;
g_bang.c:    iemgui_save(&x->x_gui, srl, bflcol);
g_bang.c:                (int)x->x_gui.x_obj.te_xpix, (int)x->x_gui.x_obj.te_ypix,
g_bang.c:                gensym("bng"), x->x_gui.x_w,
g_bang.c:                x->x_flashtime_hold, x->x_flashtime_break,
g_bang.c:                iem_symargstoint(&x->x_gui.x_isa),
g_bang.c:                x->x_gui.x_ldx, x->x_gui.x_ldy,
g_bang.c:                iem_fstyletoint(&x->x_gui.x_fsf), x->x_gui.x_fontsize,
g_bang.c:    x->x_flashtime_break = ftbreak;
g_bang.c:    x->x_flashtime_hold = fthold;
g_bang.c:    iemgui_properties(&x->x_gui, srl);
g_bang.c:            ----------dimensions(pix):----------- %d %d size: 0 0 empty \
g_bang.c:            --------flash-time(ms)(ms):--------- %d intrrpt: %d hold: %d \
g_bang.c:            x->x_gui.x_w, IEM_GUI_MINSIZE,
g_bang.c:            x->x_flashtime_break, x->x_flashtime_hold, 2,/*min_max_schedule+clip*/
g_bang.c:            -1, x->x_gui.x_isa.x_loadinit, -1, -1,/*no linlog, no multi*/
g_bang.c:            srl[0]->s_name, srl[1]->s_name,
g_bang.c:            srl[2]->s_name, x->x_gui.x_ldx, x->x_gui.x_ldy,
g_bang.c:            x->x_gui.x_fsf.x_font_style, x->x_gui.x_fontsize,
g_bang.c:            0xffffff & x->x_gui.x_bcol, 0xffffff & x->x_gui.x_fcol, 0xffffff & x->x_gui.x_lcol);
g_bang.c:    gfxstub_new(&x->x_gui.x_obj.ob_pd, x, buf);
g_bang.c:    if(x->x_flashed)
g_bang.c:        x->x_flashed = 0;
g_bang.c:        (*x->x_gui.x_draw)(x, x->x_gui.x_glist, IEM_GUI_DRAW_MODE_UPDATE);
g_bang.c:        clock_delay(x->x_clock_brk, x->x_flashtime_break);
g_bang.c:        x->x_flashed = 1;
g_bang.c:        x->x_flashed = 1;
g_bang.c:        (*x->x_gui.x_draw)(x, x->x_gui.x_glist, IEM_GUI_DRAW_MODE_UPDATE);
g_bang.c:    clock_delay(x->x_clock_hld, x->x_flashtime_hold);
g_bang.c:    if(!x->x_gui.x_fsf.x_put_in2out)
g_bang.c:        x->x_gui.x_isa.x_locked = 1;
g_bang.c:        clock_delay(x->x_clock_lck, 2);
g_bang.c:    outlet_bang(x->x_gui.x_obj.ob_outlet);
g_bang.c:    if(x->x_gui.x_fsf.x_snd_able && x->x_gui.x_snd->s_thing && x->x_gui.x_fsf.x_put_in2out)
g_bang.c:        pd_bang(x->x_gui.x_snd->s_thing);
g_bang.c:    if(!x->x_gui.x_fsf.x_put_in2out)
g_bang.c:        x->x_gui.x_isa.x_locked = 1;
g_bang.c:        clock_delay(x->x_clock_lck, 2);
g_bang.c:    outlet_bang(x->x_gui.x_obj.ob_outlet);
g_bang.c:    if(x->x_gui.x_fsf.x_snd_able && x->x_gui.x_snd->s_thing)
g_bang.c:        pd_bang(x->x_gui.x_snd->s_thing);
g_bang.c:    if(!x->x_gui.x_isa.x_locked)
g_bang.c:    if(!x->x_gui.x_isa.x_locked)
g_bang.c:    int sr_flags = iemgui_dialog(&x->x_gui, srl, argc, argv);
g_bang.c:    x->x_gui.x_w = iemgui_clip_size(a);
g_bang.c:    x->x_gui.x_h = x->x_gui.x_w;
g_bang.c:    (*x->x_gui.x_draw)(x, x->x_gui.x_glist, IEM_GUI_DRAW_MODE_CONFIG);
g_bang.c:    (*x->x_gui.x_draw)(x, x->x_gui.x_glist, IEM_GUI_DRAW_MODE_IO + sr_flags);
g_bang.c:    (*x->x_gui.x_draw)(x, x->x_gui.x_glist, IEM_GUI_DRAW_MODE_MOVE);
g_bang.c:    canvas_fixlinesfor(x->x_gui.x_glist, (t_text*)x);
g_bang.c:    if(!sys_noloadbang && x->x_gui.x_isa.x_loadinit)
g_bang.c:    x->x_gui.x_w = iemgui_clip_size((int)atom_getintarg(0, ac, av));
g_bang.c:    x->x_gui.x_h = x->x_gui.x_w;
g_bang.c:    iemgui_size((void *)x, &x->x_gui);
g_bang.c:{iemgui_delta((void *)x, &x->x_gui, s, ac, av);}
g_bang.c:{iemgui_pos((void *)x, &x->x_gui, s, ac, av);}
g_bang.c:{iemgui_color((void *)x, &x->x_gui, s, ac, av);}
g_bang.c:{iemgui_send(x, &x->x_gui, s);}
g_bang.c:{iemgui_receive(x, &x->x_gui, s);}
g_bang.c:{iemgui_label((void *)x, &x->x_gui, s);}
g_bang.c:{iemgui_label_pos((void *)x, &x->x_gui, s, ac, av);}
g_bang.c:{iemgui_label_font((void *)x, &x->x_gui, s, ac, av);}
g_bang.c:    x->x_gui.x_isa.x_loadinit = (f==0.0)?0:1;
g_bang.c:    x->x_flashed = 0;
g_bang.c:    (*x->x_gui.x_draw)(x, x->x_gui.x_glist, IEM_GUI_DRAW_MODE_UPDATE);
g_bang.c:    (*x->x_gui.x_draw)(x, x->x_gui.x_glist, IEM_GUI_DRAW_MODE_UPDATE);
g_bang.c:    x->x_gui.x_isa.x_locked = 0;
g_bang.c:    int bflcol[]={-262144, -1, -1};
g_bang.c:    iem_inttosymargs(&x->x_gui.x_isa, 0);
g_bang.c:    iem_inttofstyle(&x->x_gui.x_fsf, 0);
g_bang.c:        iem_inttosymargs(&x->x_gui.x_isa, atom_getintarg(3, argc, argv));
g_bang.c:        iemgui_new_getnames(&x->x_gui, 4, argv);
g_bang.c:        iem_inttofstyle(&x->x_gui.x_fsf, atom_getintarg(9, argc, argv));
g_bang.c:    else iemgui_new_getnames(&x->x_gui, 4, 0);
g_bang.c:    x->x_gui.x_draw = (t_iemfunptr)bng_draw;
g_bang.c:    x->x_gui.x_fsf.x_snd_able = 1;
g_bang.c:    x->x_gui.x_fsf.x_rcv_able = 1;
g_bang.c:    x->x_flashed = 0;
g_bang.c:    x->x_gui.x_glist = (t_glist *)canvas_getcurrent();
g_bang.c:    if (!strcmp(x->x_gui.x_snd->s_name, "empty"))
g_bang.c:        x->x_gui.x_fsf.x_snd_able = 0;
g_bang.c:    if (!strcmp(x->x_gui.x_rcv->s_name, "empty"))
g_bang.c:        x->x_gui.x_fsf.x_rcv_able = 0;
g_bang.c:    if(x->x_gui.x_fsf.x_font_style == 1) strcpy(x->x_gui.x_font, "helvetica");
g_bang.c:    else if(x->x_gui.x_fsf.x_font_style == 2) strcpy(x->x_gui.x_font, "times");
g_bang.c:    else { x->x_gui.x_fsf.x_font_style = 0;
g_bang.c:        strcpy(x->x_gui.x_font, sys_font); }
g_bang.c:    if (x->x_gui.x_fsf.x_rcv_able)
g_bang.c:        pd_bind(&x->x_gui.x_obj.ob_pd, x->x_gui.x_rcv);
g_bang.c:    x->x_gui.x_ldx = ldx;
g_bang.c:    x->x_gui.x_ldy = ldy;
g_bang.c:    x->x_gui.x_fontsize = fs;
g_bang.c:    x->x_gui.x_w = iemgui_clip_size(a);
g_bang.c:    x->x_gui.x_h = x->x_gui.x_w;
g_bang.c:    iemgui_all_colfromload(&x->x_gui, bflcol);
g_bang.c:    x->x_gui.x_isa.x_locked = 0;
g_bang.c:    iemgui_verify_snd_ne_rcv(&x->x_gui);
g_bang.c:    x->x_clock_hld = clock_new(x, (t_method)bng_tick_hld);
g_bang.c:    x->x_clock_brk = clock_new(x, (t_method)bng_tick_brk);
g_bang.c:    x->x_clock_lck = clock_new(x, (t_method)bng_tick_lck);
g_bang.c:    outlet_new(&x->x_gui.x_obj, &s_bang);
g_bang.c:    if(x->x_gui.x_fsf.x_rcv_able)
g_bang.c:        pd_unbind(&x->x_gui.x_obj.ob_pd, x->x_gui.x_rcv);
g_bang.c:    clock_free(x->x_clock_lck);
g_bang.c:    clock_free(x->x_clock_brk);
g_bang.c:    clock_free(x->x_clock_hld);
g_canvas.c:/* Copyright (c) 1997-2001 Miller Puckette and others.
g_canvas.c:/* ---------------------- variables --------------------------- */
g_canvas.c:/* ------------------ forward function declarations --------------- */
g_canvas.c:/* --------- functions to handle the canvas environment ----------- */
g_canvas.c:    x->gl_next = canvas_list;
g_canvas.c:    if (x == canvas_list) canvas_list = x->gl_next;
g_canvas.c:        for (z = canvas_list; z->gl_next != x; z = z->gl_next)
g_canvas.c:        z->gl_next = x->gl_next;
g_canvas.c:    pd_pushsym(&x->gl_pd);
g_canvas.c:    pd_popsym(&x->gl_pd);
g_canvas.c:    while (!x->gl_env)
g_canvas.c:        if (!(x = x->gl_owner))
g_canvas.c:    return (x->gl_env);
g_canvas.c:        return (env->ce_dollarzero);
g_canvas.c:    *argcp = e->ce_argc;
g_canvas.c:    *argvp = e->ce_argv;
g_canvas.c:    char *name = s->s_name;
g_canvas.c:        ret = binbuf_realizedollsym(s, env->ce_argc, env->ce_argv, 1);
g_canvas.c:    return (e->ce_dir);
g_canvas.c:    return (e->ce_dir);
g_canvas.c:    char *dir = canvas_getenv(x)->ce_dir->s_name;
g_canvas.c:        result[resultsize-1] = 0;
g_canvas.c:        result[resultsize-1] = 0;
g_canvas.c:        nleft = resultsize - strlen(result) - 1;
g_canvas.c:        result[resultsize-1] = 0;
g_canvas.c:    if (strcmp(x->gl_name->s_name, "Pd"))
g_canvas.c:        pd_unbind(&x->gl_pd, canvas_makebindsym(x->gl_name));
g_canvas.c:    x->gl_name = s;
g_canvas.c:    if (strcmp(x->gl_name->s_name, "Pd"))
g_canvas.c:        pd_bind(&x->gl_pd, canvas_makebindsym(x->gl_name));
g_canvas.c:    if (x->gl_havewindow)
g_canvas.c:        e->ce_dir = dir;
g_canvas.c:/* --------------- traversing the set of lines in a canvas ----------- */
g_canvas.c:    for (indexno = 0, y2 = x->gl_list; y2 && y2 != y; y2 = y2->g_next)
g_canvas.c:    t->tr_ob = 0;
g_canvas.c:    t->tr_x = x;
g_canvas.c:    t->tr_nextoc = 0;
g_canvas.c:    t->tr_nextoutno = t->tr_nout = 0;
g_canvas.c:    t_outconnect *rval = t->tr_nextoc;
g_canvas.c:        outno = t->tr_nextoutno;
g_canvas.c:        while (outno == t->tr_nout)
g_canvas.c:            if (!t->tr_ob) y = t->tr_x->gl_list;
g_canvas.c:            else y = t->tr_ob->ob_g.g_next;
g_canvas.c:            for (; y; y = y->g_next)
g_canvas.c:                if (ob = pd_checkobject(&y->g_pd)) break;
g_canvas.c:            t->tr_ob = ob;
g_canvas.c:            t->tr_nout = obj_noutlets(ob);
g_canvas.c:            if (glist_isvisible(t->tr_x))
g_canvas.c:                gobj_getrect(y, t->tr_x,
g_canvas.c:                    &t->tr_x11, &t->tr_y11, &t->tr_x12, &t->tr_y12);
g_canvas.c:            else t->tr_x11 = t->tr_y11 = t->tr_x12 = t->tr_y12 = 0;
g_canvas.c:        t->tr_nextoutno = outno + 1;
g_canvas.c:        rval = obj_starttraverseoutlet(t->tr_ob, &t->tr_outlet, outno);
g_canvas.c:        t->tr_outno = outno;
g_canvas.c:    t->tr_nextoc = obj_nexttraverseoutlet(rval, &t->tr_ob2,
g_canvas.c:        &t->tr_inlet, &t->tr_inno);
g_canvas.c:    t->tr_nin = obj_ninlets(t->tr_ob2);
g_canvas.c:    if (!t->tr_nin) bug("drawline");
g_canvas.c:    if (glist_isvisible(t->tr_x))
g_canvas.c:        int inplus = (t->tr_nin == 1 ? 1 : t->tr_nin - 1);
g_canvas.c:        int outplus = (t->tr_nout == 1 ? 1 : t->tr_nout - 1);
g_canvas.c:        gobj_getrect(&t->tr_ob2->ob_g, t->tr_x,
g_canvas.c:            &t->tr_x21, &t->tr_y21, &t->tr_x22, &t->tr_y22);
g_canvas.c:        t->tr_lx1 = t->tr_x11 +
g_canvas.c:            ((t->tr_x12 - t->tr_x11 - IOWIDTH) * t->tr_outno) /
g_canvas.c:        t->tr_ly1 = t->tr_y12;
g_canvas.c:        t->tr_lx2 = t->tr_x21 +
g_canvas.c:            ((t->tr_x22 - t->tr_x21 - IOWIDTH) * t->tr_inno)/inplus +
g_canvas.c:        t->tr_ly2 = t->tr_y21;
g_canvas.c:        t->tr_x21 = t->tr_y21 = t->tr_x22 = t->tr_y22 = 0;
g_canvas.c:        t->tr_lx1 = t->tr_ly1 = t->tr_lx2 = t->tr_ly2 = 0;
g_canvas.c:    t->tr_nextoc = 0;
g_canvas.c:    t->tr_nextoutno = t->tr_nout;
g_canvas.c:/* -------------------- the canvas object -------------------------- */
g_canvas.c:    memset(((char *)x) + sizeof(x->gl_pd), 0, sizeof(*x) - sizeof(x->gl_pd));
g_canvas.c:    x->gl_stub = gstub_new(x, 0);
g_canvas.c:    x->gl_valid = ++glist_valid;
g_canvas.c:    x->gl_xlabel = (t_symbol **)t_getbytes(0);
g_canvas.c:    x->gl_ylabel = (t_symbol **)t_getbytes(0);
g_canvas.c:    int font = (owner ? owner->gl_font : sys_defaultfont);
g_canvas.c:    x->gl_obj.te_type = T_OBJECT;
g_canvas.c:    if (canvas_newdirectory->s_name[0])
g_canvas.c:        t_canvasenvironment *env = x->gl_env =
g_canvas.c:            (t_canvasenvironment *)getbytes(sizeof(*x->gl_env));
g_canvas.c:        env->ce_dir = canvas_newdirectory;
g_canvas.c:        env->ce_argc = canvas_newargc;
g_canvas.c:        env->ce_argv = canvas_newargv;
g_canvas.c:        env->ce_dollarzero = dollarzero++;
g_canvas.c:        env->ce_path = 0;
g_canvas.c:    else x->gl_env = 0;
g_canvas.c:    x->gl_x1 = 0;
g_canvas.c:    x->gl_y1 = 0;
g_canvas.c:    x->gl_x2 = 1;
g_canvas.c:    x->gl_y2 = 1;
g_canvas.c:    x->gl_owner = owner;
g_canvas.c:    x->gl_name = (*s->s_name ? s : 
g_canvas.c:    if (strcmp(x->gl_name->s_name, "Pd"))
g_canvas.c:        pd_bind(&x->gl_pd, canvas_makebindsym(x->gl_name));
g_canvas.c:    x->gl_loading = 1;
g_canvas.c:    x->gl_goprect = 0;      /* no GOP rectangle unless it's turned on later */
g_canvas.c:    if (vis && gensym("#X")->s_thing && 
g_canvas.c:        ((*gensym("#X")->s_thing) == canvas_class))
g_canvas.c:        t_canvas *zzz = (t_canvas *)(gensym("#X")->s_thing);
g_canvas.c:        while (zzz && !zzz->gl_env)
g_canvas.c:            zzz = zzz->gl_owner;
g_canvas.c:        if (zzz && canvas_isabstraction(zzz) && zzz->gl_owner)
g_canvas.c:    x->gl_willvis = vis;
g_canvas.c:    x->gl_edit = !strncmp(x->gl_name->s_name, "Untitled", 8);
g_canvas.c:    x->gl_font = sys_nearestfontsize(font);
g_canvas.c:    pd_pushsym(&x->gl_pd);
g_canvas.c:    x->gl_x1 = atom_getfloatarg(0, argc, argv);
g_canvas.c:    x->gl_y1 = atom_getfloatarg(1, argc, argv);
g_canvas.c:    x->gl_x2 = atom_getfloatarg(2, argc, argv);
g_canvas.c:    x->gl_y2 = atom_getfloatarg(3, argc, argv);
g_canvas.c:    x->gl_pixwidth = atom_getintarg(4, argc, argv);
g_canvas.c:    x->gl_pixheight = atom_getintarg(5, argc, argv);
g_canvas.c:        x->gl_xmargin = atom_getintarg(7, argc, argv);
g_canvas.c:        x->gl_ymargin = atom_getintarg(8, argc, argv);
g_canvas.c:    x->gl_obj.te_type = T_OBJECT;
g_canvas.c:    if (!*sym->s_name)
g_canvas.c:    else if (!strncmp((str = sym->s_name), "graph", 5)
g_canvas.c:        x1 = 0, x2 = 100, y1 = 1, y2 = -1;
g_canvas.c:    x->gl_name = sym;
g_canvas.c:    x->gl_x1 = x1;
g_canvas.c:    x->gl_x2 = x2;
g_canvas.c:    x->gl_y1 = y1;
g_canvas.c:    x->gl_y2 = y2;
g_canvas.c:    x->gl_obj.te_xpix = px1;
g_canvas.c:    x->gl_obj.te_ypix = py1;
g_canvas.c:    x->gl_pixwidth = px2 - px1;
g_canvas.c:    x->gl_pixheight = py2 - py1;
g_canvas.c:    x->gl_font =  (canvas_getcurrent() ?
g_canvas.c:        canvas_getcurrent()->gl_font : sys_defaultfont);
g_canvas.c:    x->gl_screenx1 = 0;
g_canvas.c:    x->gl_screeny1 = GLIST_DEFCANVASYLOC;
g_canvas.c:    x->gl_screenx2 = 450;
g_canvas.c:    x->gl_screeny2 = 300;
g_canvas.c:    if (strcmp(x->gl_name->s_name, "Pd"))
g_canvas.c:        pd_bind(&x->gl_pd, canvas_makebindsym(x->gl_name));
g_canvas.c:    x->gl_owner = g;
g_canvas.c:    x->gl_isgraph = 1;
g_canvas.c:    x->gl_goprect = 0;
g_canvas.c:    x->gl_obj.te_binbuf = binbuf_new();
g_canvas.c:    binbuf_addv(x->gl_obj.te_binbuf, "s", gensym("graph"));
g_canvas.c:        pd_pushsym(&x->gl_pd);
g_canvas.c:    glist_add(g, &x->gl_gobj);
g_canvas.c:  return (x->gl_isgraph|(x->gl_hidetext<<1));
g_canvas.c:    int heightwas = y2 - y1;
g_canvas.c:    int heightchange = y2 - y1 - (x->gl_screeny2 - x->gl_screeny1);
g_canvas.c:    if (x->gl_screenx1 == x1 && x->gl_screeny1 == y1 &&
g_canvas.c:        x->gl_screenx2 == x2 && x->gl_screeny2 == y2)
g_canvas.c:    x->gl_screenx1 = x1;
g_canvas.c:    x->gl_screeny1 = y1;
g_canvas.c:    x->gl_screenx2 = x2;
g_canvas.c:    x->gl_screeny2 = y2;
g_canvas.c:    if (!glist_isgraph(x) && (x->gl_y2 < x->gl_y1)) 
g_canvas.c:        t_float diff = x->gl_y1 - x->gl_y2;
g_canvas.c:        x->gl_y1 = heightwas * diff;
g_canvas.c:        x->gl_y2 = x->gl_y1 - diff;
g_canvas.c:        for (y = x->gl_list; y; y = y->g_next)
g_canvas.c:            if (pd_checkobject(&y->g_pd))
g_canvas.c:    strcpy(buf, "pd-");
g_canvas.c:    strcat(buf, s->s_name);
g_canvas.c:    if (env->ce_argc)
g_canvas.c:        for (i = 0; i < env->ce_argc; i++)
g_canvas.c:            if (strlen(namebuf) > MAXPDSTRING/2 - 5)
g_canvas.c:            atom_string(&env->ce_argv[i], namebuf + strlen(namebuf), 
g_canvas.c:        x, canvas_getdir(x)->s_name, x->gl_name->s_name, namebuf, x->gl_dirty);
g_canvas.c:    if ((unsigned)n != x2->gl_dirty)
g_canvas.c:        x2->gl_dirty = n;
g_canvas.c:        if (x2->gl_havewindow)
g_canvas.c:            %d %d %d %d %d %d %d %d %d %d -fill #ff8080 -tags GOP\n",
g_canvas.c:            x->gl_xmargin, x->gl_ymargin,
g_canvas.c:            x->gl_xmargin + x->gl_pixwidth, x->gl_ymargin,
g_canvas.c:            x->gl_xmargin + x->gl_pixwidth, x->gl_ymargin + x->gl_pixheight,
g_canvas.c:            x->gl_xmargin, x->gl_ymargin + x->gl_pixheight,
g_canvas.c:            x->gl_xmargin, x->gl_ymargin);
g_canvas.c:            if (!x->gl_havewindow)
g_canvas.c:            for (y = x->gl_list; y; y = y->g_next)
g_canvas.c:            for (sel = x->gl_editor->e_selection; sel; sel = sel->sel_next)
g_canvas.c:                gobj_select(sel->sel_what, x, 1);
g_canvas.c:            x->gl_mapped = 1;
g_canvas.c:            if (x->gl_isgraph && x->gl_goprect)
g_canvas.c:            x->gl_mapped = 0;
g_canvas.c:    /* we call this on a non-toplevel glist to "open" it into its
g_canvas.c:        t_glist *gl2 = x->gl_owner;
g_canvas.c:            gobj_vis(&x->gl_gobj, gl2, 0);
g_canvas.c:            if (x->gl_editor)
g_canvas.c:            x->gl_havewindow = 1;
g_canvas.c:            gobj_vis(&x->gl_gobj, gl2, 1);
g_canvas.c:    return ((!x->gl_loading) && glist_getcanvas(x)->gl_mapped);
g_canvas.c:    return (x->gl_havewindow || !x->gl_isgraph);
g_canvas.c:    while (!x->gl_env)
g_canvas.c:        if (!(x = x->gl_owner))
g_canvas.c:    return (x->gl_font);
g_canvas.c:    while (y = x->gl_list)
g_canvas.c:    if (x->gl_editor)
g_canvas.c:    if (strcmp(x->gl_name->s_name, "Pd"))
g_canvas.c:        pd_unbind(&x->gl_pd, canvas_makebindsym(x->gl_name));
g_canvas.c:    if (x->gl_env)
g_canvas.c:        freebytes(x->gl_env->ce_argv, x->gl_env->ce_argc * sizeof(t_atom));
g_canvas.c:        freebytes(x->gl_env, sizeof(*x->gl_env));
g_canvas.c:    freebytes(x->gl_xlabel, x->gl_nxlabels * sizeof(*(x->gl_xlabel)));
g_canvas.c:    freebytes(x->gl_ylabel, x->gl_nylabels * sizeof(*(x->gl_ylabel)));
g_canvas.c:    gstub_cutoff(x->gl_stub);
g_canvas.c:    if (!x->gl_owner)
g_canvas.c:/* ----------------- lines ---------- */
g_canvas.c:            sys_vgui(".x%lx.c create line %d %d %d %d -width %d -tags [list l%lx cord]\n",
g_canvas.c:    pd_popsym(&x->gl_pd);
g_canvas.c:    x->gl_loading = 0;
g_canvas.c:        if (ap->a_type == A_SYMBOL)
g_canvas.c:            canvas_rename(x, binbuf_realizedollsym(ap->a_w.w_symbol,
g_canvas.c:                e->ce_argc, e->ce_argv, 1), 0);
g_canvas.c:    canvas_pop(x, x->gl_willvis);
g_canvas.c:    if (!(z = gensym("#X")->s_thing)) error("canvas_restore: out of context");
g_canvas.c:        x->gl_owner = x2;
g_canvas.c:        canvas_objfor(x2, &x->gl_obj, argc, argv);
g_canvas.c:    for (y = x->gl_list; y; y = y->g_next)
g_canvas.c:        if (pd_class(&y->g_pd) == canvas_class)
g_canvas.c:    for (y = x->gl_list; y; y = y->g_next)
g_canvas.c:        if (pd_class(&y->g_pd) == canvas_class)
g_canvas.c:    for (y = x->gl_list; y; y = y->g_next)
g_canvas.c:        if ((pd_class(&y->g_pd) != canvas_class) &&
g_canvas.c:            zgetfn(&y->g_pd, s))
g_canvas.c:                pd_vmess(&y->g_pd, s, "");
g_canvas.c:/* no longer used by 'pd-gui', but kept here for backwards compatibility.  The
g_canvas.c:    if (sscanf(canvasgeom->s_name, "%dx%d+%d+%d", &cw, &ch, &cxpix, &cypix)
g_canvas.c:        sscanf(topgeom->s_name, "%dx%d+%d+%d", &tw, &th, &txpix, &typix) < 4)
g_canvas.c:    newest = &x->gl_pd;
g_canvas.c:    pd_popsym(&x->gl_pd);
g_canvas.c:    x->gl_loading = 0;
g_canvas.c:    if (!glist_isselected(x, &y->ob_g))
g_canvas.c:        glist_select(x, &y->ob_g);
g_canvas.c:/* -------------------------- subcanvases ---------------------- */
g_canvas.c:    if (!*s->s_name) s = gensym("/SUBPATCH/");
g_canvas.c:    x->gl_owner = z;
g_canvas.c:    if (ac && av->a_type == A_SYMBOL)
g_canvas.c:        canvas_rename(x, av->a_w.w_symbol, 0);
g_canvas.c:    else if (ac && av->a_type == A_DOLLSYM)
g_canvas.c:        canvas_rename(x, binbuf_realizedollsym(av->a_w.w_symbol,
g_canvas.c:            e->ce_argc, e->ce_argv, 1), 0); 
g_canvas.c:/* ------------------ table ---------------------------*/
g_canvas.c:         sprintf(tabname, "%s%d", t->s_name, tabcount++);
g_canvas.c:    x->gl_owner = z;
g_canvas.c:    gl = glist_addglist((t_glist*)x, &s_, 0, -1, (f > 1 ? f-1 : 1), 1,
g_canvas.c:    return (x->gl_env != 0);
g_canvas.c:    t_atom *argv = (x->gl_obj.te_binbuf? binbuf_getvec(x->gl_obj.te_binbuf):0);
g_canvas.c:    int argc = (x->gl_obj.te_binbuf? binbuf_getnatom(x->gl_obj.te_binbuf) : 0);
g_canvas.c:/* JMZ: add a flag to gop-abstractions to hide the title */
g_canvas.c:    t_atom *argv = (x->gl_obj.te_binbuf? binbuf_getvec(x->gl_obj.te_binbuf):0);
g_canvas.c:    int argc = (x->gl_obj.te_binbuf? binbuf_getnatom(x->gl_obj.te_binbuf) : 0);
g_canvas.c:    if(x->gl_hidetext)
g_canvas.c:    if ((!x->gl_owner) || canvas_isabstraction(x))
g_canvas.c:    else return (canvas_getrootfor(x->gl_owner));
g_canvas.c:/* ------------------------- DSP chain handling ------------------------- */
g_canvas.c:    canvases, but is also called from the "dsp" method for sub-
g_canvas.c:        obj_nsiginlets(&x->gl_obj),
g_canvas.c:        obj_nsigoutlets(&x->gl_obj));
g_canvas.c:    for (y = x->gl_list; y; y = y->g_next)
g_canvas.c:        if ((ob = pd_checkobject(&y->g_pd)) && zgetfn(&y->g_pd, dspsym))
g_canvas.c:    for (x = canvas_list; x; x = x->gl_next)
g_canvas.c:appropriate, also opens and closes the audio device.  On exclusive-access
g_canvas.c:    for (g = canvas->gl_list; g; g = g->g_next)
g_canvas.c:        if (g->g_pd == blockclass)
g_canvas.c:    *canvasp = canvas->gl_owner;
g_canvas.c:    for (g = gl->gl_list; g; g = g->g_next)
g_canvas.c:        if (vis && g->g_pd == scalar_class)
g_canvas.c:        else if (g->g_pd == canvas_class)
g_canvas.c:    for (x = canvas_list; x; x = x->gl_next)
g_canvas.c:    for (g = x->gl_list; g; g = g->g_next)
g_canvas.c:        t_object *ob = pd_checkobject(&g->g_pd);
g_canvas.c:        if (!ob || ob->te_type != T_OBJECT ||
g_canvas.c:            binbuf_getnatom(ob->te_binbuf) < 2)
g_canvas.c:        argv = binbuf_getvec(ob->te_binbuf);
g_canvas.c:/* ------------------------------- declare ------------------------ */
g_canvas.c:search ("-path", "-stdpath") and object libraries to load
g_canvas.c:("-lib" and "-stdlib").  These must be set before the patch containing
g_canvas.c:    x->x_useme = 1;
g_canvas.c:    x->x_canvas = canvas_getcurrent();
g_canvas.c:    x->x_useme = 0;
g_canvas.c:    for (y = x->gl_list; y; y = y->g_next)
g_canvas.c:        if (pd_class(&y->g_pd) == declare_class)
g_canvas.c:            binbuf_addbinbuf(b, ((t_declare *)y)->x_obj.te_binbuf);
g_canvas.c:        else if (pd_class(&y->g_pd) == canvas_class)
g_canvas.c:        strncpy(to, sys_libdir->s_name, bufsize-4);
g_canvas.c:        to[bufsize-3] = '\0';
g_canvas.c:    strncat(to, from, bufsize-strlen(to));
g_canvas.c:    to[bufsize-1] = '\0';
g_canvas.c:    startpost("declare:: %s", s->s_name);
g_canvas.c:        char *flag = atom_getsymbolarg(i, argc, argv)->s_name;
g_canvas.c:        if ((argc > i+1) && !strcmp(flag, "-path"))
g_canvas.c:            e->ce_path = namelist_append(e->ce_path, 
g_canvas.c:                atom_getsymbolarg(i+1, argc, argv)->s_name, 0);
g_canvas.c:        else if ((argc > i+1) && !strcmp(flag, "-stdpath"))
g_canvas.c:            canvas_completepath(atom_getsymbolarg(i+1, argc, argv)->s_name,
g_canvas.c:            e->ce_path = namelist_append(e->ce_path, strbuf, 0);
g_canvas.c:        else if ((argc > i+1) && !strcmp(flag, "-lib"))
g_canvas.c:            sys_load_lib(x, atom_getsymbolarg(i+1, argc, argv)->s_name);
g_canvas.c:        else if ((argc > i+1) && !strcmp(flag, "-stdlib"))
g_canvas.c:            canvas_completepath(atom_getsymbolarg(i+1, argc, argv)->s_name,
g_canvas.c:    int fd = -1;
g_canvas.c:    for (y = x; y; y = y->gl_owner)
g_canvas.c:        if (y->gl_env)
g_canvas.c:        while (x2 && x2->gl_owner)
g_canvas.c:            x2 = x2->gl_owner;
g_canvas.c:        dir = (x2 ? canvas_getdir(x2)->s_name : ".");
g_canvas.c:        for (nl = y->gl_env->ce_path; nl; nl = nl->nl_next)
g_canvas.c:            if (sys_isabsolutepath(nl->nl_string))
g_canvas.c:                realname[MAXPDSTRING-3] = 0;
g_canvas.c:            strncat(realname, nl->nl_string, MAXPDSTRING-strlen(realname));
g_canvas.c:            realname[MAXPDSTRING-1] = 0;
g_canvas.c:    return (open_via_path((x ? canvas_getdir(x)->s_name : "."), name, ext,
g_canvas.c:/* ------------------------------- setup routine ------------------------ */
g_canvas.c:/* -------------------------- objects ----------------------------- */
g_canvas.c:/* -------------- IEMGUI: button, toggle, slider, etc.  ------------ */
g_canvas.c:/* ------------------------ gui stuff --------------------------- */
g_canvas.c:        gensym("menu-open"), A_NULL);
g_canvas.c:/* ---------------------- list handling ------------------------ */
g_canvas.c:/* ----- subcanvases, which you get by typing "pd" in a box ---- */
g_canvas.c:/*---------------------------- tables -- GG ------------------- */
g_canvas.c:/*---------------------------- declare ------------------- */
g_canvas.c:/*--------------- future message to set formatting  -------------- */
g_canvas.c:/* -------------- setups from other files for canvas_class ---------------- */
g_canvas.h:/* Copyright (c) 1997-1999 Miller Puckette.
g_canvas.h:Closing a non-root window makes it invisible; closing a root destroys it.
g_canvas.h:embedded glist can switch back and forth to appear as a toplevel by double-
g_canvas.h:clicking on it.  Single-clicking a text box makes the toplevel become visible
g_canvas.h:/* --------------------- geometry ---------------------------- */
g_canvas.h:#define IOMIDDLE ((IOWIDTH-1)/2)
g_canvas.h:/* ----------------------- data ------------------------------- */
g_canvas.h:    unsigned int gl_isdeleting:1;   /* we're inside glist_delete -- hack! */
g_canvas.h:    unsigned int gl_goprect:1;      /* draw rectangle for graph-on-parent */
g_canvas.h:    unsigned int gl_hidetext:1;     /* hide object-name + args when doing graph on parent */
g_canvas.h:/* -------- behaviors for scalars defined by objects in template --------- */
g_canvas.h:/* ------------------- functions on any gobj ----------------------------- */
g_canvas.h:/* -------------------- functions on glists --------------------- */
g_canvas.h:/* -------------------- functions on texts ------------------------- */
g_canvas.h:/* -------------------- functions on rtexts ------------------------- */
g_canvas.h:/* -------------------- functions on canvases ------------------------ */
g_canvas.h:/* ---- functions on canvasses as objects  --------------------- */
g_canvas.h:/* --------- functions on garrays (graphical arrays) -------------------- */
g_canvas.h:/* -------------------- arrays --------------------- */
g_canvas.h:/* --------------------- gpointers and stubs ---------------- */
g_canvas.h:/* --------------------- scalars ------------------------- */
g_canvas.h:/* ------helper routines for "garrays" and "plots" -------------- */
g_canvas.h:/* --------------------- templates ------------------------- */
g_canvas.h:/* ----------------------- guiconnects, g_guiconnect.c --------- */
g_canvas.h:/* ------------- IEMGUI routines used in other g_ files ---------------- */
g_editor.c:/* Copyright (c) 1997-2001 Miller Puckette and others.
g_editor.c:#include "s_utf8.h" /*-- moo --*/
g_editor.c:/* ------------------ forward declarations --------------- */
g_editor.c:/* ---------------- generic widget behavior ------------------------- */
g_editor.c:    if (x->g_pd->c_wb && x->g_pd->c_wb->w_getrectfn)
g_editor.c:        (*x->g_pd->c_wb->w_getrectfn)(x, glist, x1, y1, x2, y2);
g_editor.c:    if (x->g_pd->c_wb && x->g_pd->c_wb->w_displacefn)
g_editor.c:        (*x->g_pd->c_wb->w_displacefn)(x, glist, dx, dy);
g_editor.c:    if (x->g_pd->c_wb && x->g_pd->c_wb->w_selectfn)
g_editor.c:        (*x->g_pd->c_wb->w_selectfn)(x, glist, state);
g_editor.c:    if (x->g_pd->c_wb && x->g_pd->c_wb->w_activatefn)
g_editor.c:        (*x->g_pd->c_wb->w_activatefn)(x, glist, state);
g_editor.c:    if (x->g_pd->c_wb && x->g_pd->c_wb->w_deletefn)
g_editor.c:        (*x->g_pd->c_wb->w_deletefn)(x, glist);
g_editor.c:    if (!glist->gl_havewindow && glist->gl_isgraph && glist->gl_goprect &&
g_editor.c:        glist->gl_owner && (pd_class(&x->g_pd) != scalar_class)
g_editor.c:            && (pd_class(&x->g_pd) != garray_class))
g_editor.c:        /* if we're graphing-on-parent and the object falls outside the
g_editor.c:        gobj_getrect(&glist->gl_gobj, glist->gl_owner, &x1, &y1, &x2, &y2);
g_editor.c:    if (ob = pd_checkobject(&x->g_pd))
g_editor.c:        boxes inside graphs---except comments, if we're doing the new
g_editor.c:        return (glist->gl_havewindow ||
g_editor.c:            (ob->te_pd != canvas_class &&
g_editor.c:                ob->te_pd->c_wb != &text_widgetbehavior) ||
g_editor.c:            (ob->te_pd == canvas_class && (((t_glist *)ob)->gl_isgraph)) ||
g_editor.c:            (glist->gl_goprect && (ob->te_type == T_TEXT)));
g_editor.c:    if (x->g_pd->c_wb && x->g_pd->c_wb->w_visfn && gobj_shouldvis(x, glist))
g_editor.c:        (*x->g_pd->c_wb->w_visfn)(x, glist, flag);
g_editor.c:    if (x->g_pd->c_wb && x->g_pd->c_wb->w_clickfn)
g_editor.c:        return ((*x->g_pd->c_wb->w_clickfn)(x,
g_editor.c:/* ------------------------ managing the selection ----------------- */
g_editor.c:    if (x->gl_editor)
g_editor.c:        x->gl_editor->e_selectedline = 1;
g_editor.c:        x->gl_editor->e_selectline_index1 = index1;
g_editor.c:        x->gl_editor->e_selectline_outno = outno;
g_editor.c:        x->gl_editor->e_selectline_index2 = index2;
g_editor.c:        x->gl_editor->e_selectline_inno = inno;
g_editor.c:        x->gl_editor->e_selectline_tag = oc;
g_editor.c:        sys_vgui(".x%lx.c itemconfigure l%lx -fill blue\n",
g_editor.c:            x, x->gl_editor->e_selectline_tag);
g_editor.c:    if (x->gl_editor)
g_editor.c:        x->gl_editor->e_selectedline = 0;
g_editor.c:        sys_vgui(".x%lx.c itemconfigure l%lx -fill black\n",
g_editor.c:            x, x->gl_editor->e_selectline_tag);
g_editor.c:    if (x->gl_editor)
g_editor.c:        for (sel = x->gl_editor->e_selection; sel; sel = sel->sel_next)
g_editor.c:            if (sel->sel_what == y) return (1);
g_editor.c:    if (x->gl_editor)
g_editor.c:        if (x->gl_editor->e_selectedline)
g_editor.c:        sel->sel_next = x->gl_editor->e_selection;
g_editor.c:        sel->sel_what = y;
g_editor.c:        x->gl_editor->e_selection = sel;
g_editor.c:    if (pd_class(&g->g_pd) != canvas_class)
g_editor.c:    for (g2 = gl2->gl_list; g2; g2 = g2->g_next)
g_editor.c:    if (x->gl_editor)
g_editor.c:        if (x->gl_editor->e_textedfor)
g_editor.c:            if (x->gl_editor->e_textedfor == fuddy)
g_editor.c:                if (x->gl_editor->e_textdirty)
g_editor.c:            if (zgetfn(&y->g_pd, gensym("dsp")))
g_editor.c:        if ((sel = x->gl_editor->e_selection)->sel_what == y)
g_editor.c:            x->gl_editor->e_selection = x->gl_editor->e_selection->sel_next;
g_editor.c:            gobj_select(sel->sel_what, x, 0);
g_editor.c:            for (sel = x->gl_editor->e_selection; sel2 = sel->sel_next;
g_editor.c:                if (sel2->sel_what == y)
g_editor.c:                    sel->sel_next = sel2->sel_next;
g_editor.c:                    gobj_select(sel2->sel_what, x, 0);
g_editor.c:            x->gl_editor->e_textedfor = 0;
g_editor.c:    if (x->gl_editor)
g_editor.c:        while (x->gl_editor->e_selection)
g_editor.c:            glist_deselect(x, x->gl_editor->e_selection->sel_what);
g_editor.c:        if (x->gl_editor->e_selectedline)
g_editor.c:    if (x->gl_editor)
g_editor.c:        if (x->gl_list)
g_editor.c:            t_gobj *y = x->gl_list;
g_editor.c:            x->gl_editor->e_selection = sel;
g_editor.c:            sel->sel_what = y;
g_editor.c:            while (y = y->g_next)
g_editor.c:                sel->sel_next = sel2;
g_editor.c:                sel->sel_what = y;
g_editor.c:            sel->sel_next = 0;
g_editor.c:    for (y2 = x->gl_list, indx = 0; y2 && y2 != y; y2 = y2->g_next)
g_editor.c:    for (y2 = x->gl_list, indx = 0; y2 && y2 != y; y2 = y2->g_next)
g_editor.c:    for (y = x->gl_list, indx = 0; y; y = y->g_next, indx++)
g_editor.c:/* ------------------- support for undo/redo  -------------------------- */
g_editor.c:        old undo info is re-used; if so we shouldn't free it here. */
g_editor.c:/* ------- specific undo methods: 1. connect and disconnect -------- */
g_editor.c:    buf->u_index1 = index1;
g_editor.c:    buf->u_outletno = outno;
g_editor.c:    buf->u_index2 = index2;
g_editor.c:    buf->u_inletno = inno;
g_editor.c:        int srcno = canvas_getindex(x, &t.tr_ob->ob_g);
g_editor.c:        int sinkno = canvas_getindex(x, &t.tr_ob2->ob_g);
g_editor.c:        canvas_connect(x, buf->u_index1, buf->u_outletno,
g_editor.c:            buf->u_index2, buf->u_inletno);
g_editor.c:        canvas_disconnect(x, buf->u_index1, buf->u_outletno,
g_editor.c:            buf->u_index2, buf->u_inletno);
g_editor.c:/* ---------- ... 2. cut, clear, and typing into objects: -------- */
g_editor.c:    buf->u_mode = mode;
g_editor.c:    buf->u_redotextbuf = 0;
g_editor.c:    buf->u_reconnectbuf = binbuf_new();
g_editor.c:        int issel1 = glist_isselected(x, &t.tr_ob->ob_g);
g_editor.c:        int issel2 = glist_isselected(x, &t.tr_ob2->ob_g);
g_editor.c:            binbuf_addv(buf->u_reconnectbuf, "ssiiii;",
g_editor.c:                    + glist_selectionindex(x, &t.tr_ob->ob_g, issel1),
g_editor.c:                    glist_selectionindex(x, &t.tr_ob2->ob_g, issel2),
g_editor.c:        buf->u_objectbuf = canvas_docopy(x);
g_editor.c:        buf->u_objectbuf = 0;
g_editor.c:        buf->u_objectbuf = canvas_docopy(x);
g_editor.c:    int mode = buf->u_mode;
g_editor.c:            canvas_dopaste(x, buf->u_objectbuf);
g_editor.c:            for (y1 = x->gl_list; y2 = y1->g_next; y1 = y2)
g_editor.c:                if (!buf->u_redotextbuf)
g_editor.c:                    buf->u_redotextbuf = canvas_docopy(x);
g_editor.c:            canvas_dopaste(x, buf->u_objectbuf);
g_editor.c:        s__X.s_thing = &x->gl_pd;
g_editor.c:        binbuf_eval(buf->u_reconnectbuf, 0, 0, 0);
g_editor.c:            for (y1 = x->gl_list; y2 = y1->g_next; y1 = y2)
g_editor.c:            canvas_dopaste(x, buf->u_redotextbuf);
g_editor.c:            s__X.s_thing = &x->gl_pd;
g_editor.c:            binbuf_eval(buf->u_reconnectbuf, 0, 0, 0);
g_editor.c:        if (buf->u_objectbuf)
g_editor.c:            binbuf_free(buf->u_objectbuf);
g_editor.c:        if (buf->u_reconnectbuf)
g_editor.c:            binbuf_free(buf->u_reconnectbuf);
g_editor.c:        if (buf->u_redotextbuf)
g_editor.c:            binbuf_free(buf->u_redotextbuf);
g_editor.c:/* --------- 3. motion, including "tidy up" and stretching ----------- */
g_editor.c:    buf->u_n = selected ? glist_selectionindex(x, 0, 1) : glist_getindex(x, 0);
g_editor.c:    buf->u_vec = (t_undo_move_elem *)getbytes(sizeof(*buf->u_vec) *
g_editor.c:        for (y = x->gl_list, i = indx = 0; y; y = y->g_next, indx++)
g_editor.c:            buf->u_vec[i].e_index = indx;
g_editor.c:            buf->u_vec[i].e_xpix = x1;
g_editor.c:            buf->u_vec[i].e_ypix = y1;
g_editor.c:        for (y = x->gl_list, indx = 0; y; y = y->g_next, indx++)
g_editor.c:            buf->u_vec[indx].e_index = indx;
g_editor.c:            buf->u_vec[indx].e_xpix = x1;
g_editor.c:            buf->u_vec[indx].e_ypix = y1;
g_editor.c:        for (i = 0; i < buf->u_n; i++)
g_editor.c:            newx = buf->u_vec[i].e_xpix;
g_editor.c:            newy = buf->u_vec[i].e_ypix;
g_editor.c:            y = glist_nth(x, buf->u_vec[i].e_index);
g_editor.c:                gobj_displace(y, x, newx-x1, newy - y1);
g_editor.c:                buf->u_vec[i].e_xpix = x1;
g_editor.c:                buf->u_vec[i].e_ypix = y1;
g_editor.c:        t_freebytes(buf->u_vec, buf->u_n * sizeof(*buf->u_vec));
g_editor.c:/* --------- 4. paste (also duplicate) ----------- */
g_editor.c:    buf->u_index = glist_getindex(x, 0);
g_editor.c:        for (y = glist_nth(x, buf->u_index); y; y = y->g_next)
g_editor.c:            /* if it was "duplicate" have to re-enact the displacement. */
g_editor.c:            for (sel = x->gl_editor->e_selection; sel; sel = sel->sel_next)
g_editor.c:                gobj_displace(sel->sel_what, x, 10, 10);
g_editor.c:    int hadwindow = (gl->gl_editor != 0);
g_editor.c:    for (g = gl->gl_list, i = 0; g && i < nobj; i++)
g_editor.c:        if (g != except && pd_class(&g->g_pd) == canvas_class &&
g_editor.c:                ((t_canvas *)g)->gl_name == name &&
g_editor.c:                do g = g->g_next in this case. */
g_editor.c:            if (!gl->gl_editor)
g_editor.c:            if (!gl->gl_editor)
g_editor.c:            if (g != except && pd_class(&g->g_pd) == canvas_class)
g_editor.c:             g = g->g_next;
g_editor.c:    if (!hadwindow && gl->gl_editor)
g_editor.c:    for (x = canvas_list; x; x = x->gl_next)
g_editor.c:/* ------------------------ event handling ------------------------ */
g_editor.c:        sys_vgui(".x%lx configure -cursor %s\n", x, cursorlist[cursornum]);
g_editor.c:    *x1p = -0x7fffffff;
g_editor.c:    for (y = x->gl_list; y; y = y->g_next)
g_editor.c:    if (x->gl_editor && x->gl_editor->e_selection &&
g_editor.c:        x->gl_editor->e_selection->sel_next && !glist_isselected(x, y))
g_editor.c:        for (sel = x->gl_editor->e_selection; sel; sel = sel->sel_next)
g_editor.c:            if (canvas_hitbox(x, sel->sel_what, xpos, ypos, &x1, &y1, &x2, &y2))
g_editor.c:                    rval = sel->sel_what; 
g_editor.c:    /* right-clicking on a canvas object pops up a menu. */
g_editor.c:    canprop = (!y || (y && class_getpropertiesfn(pd_class(&y->g_pd))));
g_editor.c:    canopen = (y && zgetfn(&y->g_pd, gensym("menu-open")));
g_editor.c:/* ----  editors -- perhaps this and "vis" should go to g_editor.c ------- */
g_editor.c:    x->e_connectbuf = binbuf_new();
g_editor.c:    x->e_deleted = binbuf_new();
g_editor.c:    x->e_glist = owner;
g_editor.c:    x->e_guiconnect = guiconnect_new(&owner->gl_pd, gensym(buf));
g_editor.c:    x->e_clock = 0;
g_editor.c:    guiconnect_notarget(x->e_guiconnect, 1000);
g_editor.c:    binbuf_free(x->e_connectbuf);
g_editor.c:    binbuf_free(x->e_deleted);
g_editor.c:    if (x->e_clock)
g_editor.c:        clock_free(x->e_clock);
g_editor.c:    sub-glists, as long as they aren't toplevels. */
g_editor.c:    if (!x->gl_editor)
g_editor.c:        x->gl_editor = editor_new(x);
g_editor.c:        for (y = x->gl_list; y; y = y->g_next)
g_editor.c:            if (ob = pd_checkobject(&y->g_pd))
g_editor.c:    if (x->gl_editor)
g_editor.c:        for (y = x->gl_list; y; y = y->g_next)
g_editor.c:            if (ob = pd_checkobject(&y->g_pd))
g_editor.c:        editor_free(x->gl_editor, x);
g_editor.c:        x->gl_editor = 0;
g_editor.c:        if (x->gl_editor && x->gl_havewindow)
g_editor.c:                (int)(x->gl_screenx2 - x->gl_screenx1),
g_editor.c:                (int)(x->gl_screeny2 - x->gl_screeny1),
g_editor.c:                (int)(x->gl_screenx1), (int)(x->gl_screeny1),
g_editor.c:                x->gl_edit);
g_editor.c:            snprintf(cbuf, MAXPDSTRING - 2, "pdtk_canvas_setparents .x%lx",
g_editor.c:            while (c->gl_owner) {
g_editor.c:                c = c->gl_owner;
g_editor.c:                         MAXPDSTRING - cbuflen - 2,/* leave 2 for "\n\0" */
g_editor.c:            x->gl_havewindow = 1;
g_editor.c:        if (!x->gl_havewindow)
g_editor.c:                /* bug workaround -- a graph in a visible patch gets "invised"
g_editor.c:            if (x->gl_editor)
g_editor.c:        for (i = 1, x2 = x; x2; x2 = x2->gl_next, i++)
g_editor.c:        if (glist_isgraph(x) && x->gl_owner)
g_editor.c:            t_glist *gl2 = x->gl_owner;
g_editor.c:                gobj_vis(&x->gl_gobj, gl2, 0);
g_editor.c:            x->gl_havewindow = 0;
g_editor.c:            if (glist_isvisible(gl2) && !gl2->gl_isdeleting)
g_editor.c:                gobj_vis(&x->gl_gobj, gl2, 1);
g_editor.c:        else x->gl_havewindow = 0;
g_editor.c:    /* set a canvas up as a graph-on-parent.  Set reasonable defaults for
g_editor.c:        int hadeditor = (x->gl_editor != 0);
g_editor.c:        if (x->gl_owner && !x->gl_loading && glist_isvisible(x->gl_owner))
g_editor.c:            gobj_vis(&x->gl_gobj, x->gl_owner, 0);
g_editor.c:        x->gl_isgraph = 0;
g_editor.c:        if (x->gl_owner && !x->gl_loading && glist_isvisible(x->gl_owner))
g_editor.c:            gobj_vis(&x->gl_gobj, x->gl_owner, 1);
g_editor.c:            canvas_fixlinesfor(x->gl_owner, &x->gl_obj);
g_editor.c:        if (x->gl_pixwidth <= 0)
g_editor.c:            x->gl_pixwidth = GLIST_DEFGRAPHWIDTH;
g_editor.c:        if (x->gl_pixheight <= 0)
g_editor.c:            x->gl_pixheight = GLIST_DEFGRAPHHEIGHT;
g_editor.c:        if (x->gl_owner && !x->gl_loading && glist_isvisible(x->gl_owner))
g_editor.c:            gobj_vis(&x->gl_gobj, x->gl_owner, 0);
g_editor.c:        x->gl_isgraph = 1;
g_editor.c:        x->gl_hidetext = !(!(flag&2));
g_editor.c:        x->gl_goprect = !nogoprect;
g_editor.c:        if (glist_isvisible(x) && x->gl_goprect)
g_editor.c:        if (x->gl_owner && !x->gl_loading && glist_isvisible(x->gl_owner))
g_editor.c:            gobj_vis(&x->gl_gobj, x->gl_owner, 1);
g_editor.c:            canvas_fixlinesfor(x->gl_owner, &x->gl_obj);
g_editor.c:                x->gl_x1, x->gl_y1, x->gl_x2, x->gl_y2, 
g_editor.c:                (int)x->gl_pixwidth, (int)x->gl_pixheight,
g_editor.c:                (int)x->gl_xmargin, (int)x->gl_ymargin);
g_editor.c:                glist_dpixtodx(x, 1), -glist_dpixtody(x, 1),
g_editor.c:                0., -1., 1., 1., 
g_editor.c:                (int)x->gl_pixwidth, (int)x->gl_pixheight,
g_editor.c:                (int)x->gl_xmargin, (int)x->gl_ymargin);
g_editor.c:    gfxstub_new(&x->gl_pd, x, graphbuf);
g_editor.c:    for (y = x->gl_list; y; y = y->g_next)
g_editor.c:        if (pd_class(&y->g_pd) == garray_class) 
g_editor.c:    x->gl_pixwidth = xpix;
g_editor.c:    x->gl_pixheight = ypix;
g_editor.c:    x->gl_xmargin = xmargin;
g_editor.c:    x->gl_ymargin = ymargin;
g_editor.c:    yperpix = -yperpix;
g_editor.c:            x->gl_x1 = x1, x->gl_x2 = x2;
g_editor.c:        else x->gl_x1 = 0, x->gl_x2 = 1;
g_editor.c:            x->gl_y1 = y1, x->gl_y2 = y2;
g_editor.c:        else x->gl_y1 = 0, x->gl_y2 = 1;
g_editor.c:            x->gl_x1 = 0;
g_editor.c:            x->gl_x2 = xperpix;
g_editor.c:            x->gl_x1 = -xperpix * (x->gl_screenx2 - x->gl_screenx1);
g_editor.c:            x->gl_x2 = x->gl_x1 + xperpix;
g_editor.c:            x->gl_y1 = 0;
g_editor.c:            x->gl_y2 = yperpix;
g_editor.c:            x->gl_y1 = -yperpix * (x->gl_screeny2 - x->gl_screeny1);
g_editor.c:            x->gl_y2 = x->gl_y1 + yperpix;
g_editor.c:    if (x->gl_havewindow)
g_editor.c:    else if (glist_isvisible(x->gl_owner))
g_editor.c:        gobj_vis(&x->gl_gobj, x->gl_owner, 0);
g_editor.c:        gobj_vis(&x->gl_gobj, x->gl_owner, 1);
g_editor.c:    for (y = x->gl_list; y; y = y->g_next)
g_editor.c:                if (!class_getpropertiesfn(pd_class(&y->g_pd)))
g_editor.c:                (*class_getpropertiesfn(pd_class(&y->g_pd)))(y, x);
g_editor.c:                if (!zgetfn(&y->g_pd, gensym("menu-open")))
g_editor.c:                vmess(&y->g_pd, gensym("menu-open"), "");
g_editor.c:                if (pd_class(&y->g_pd) == canvas_class &&
g_editor.c:                    int ac = binbuf_getnatom(ob->te_binbuf);
g_editor.c:                    t_atom *av = binbuf_getvec(ob->te_binbuf);
g_editor.c:                    dir = canvas_getdir((t_canvas *)y)->s_name;
g_editor.c:                    strcpy(namebuf, class_gethelpname(pd_class(&y->g_pd)));
g_editor.c:                    dir = class_gethelpdir(pd_class(&y->g_pd));
g_editor.c:                    strcmp(namebuf + strlen(namebuf) - 3, ".pd"))
g_editor.c:        open_via_helppath("intro.pd", canvas_getdir((t_canvas *)x)->s_name);
g_editor.c:    if (!x->gl_editor)
g_editor.c:    runmode = ((mod & CTRLMOD) || (!x->gl_edit));
g_editor.c:    if (doit && x->gl_editor->e_grab && x->gl_editor->e_keyfn)
g_editor.c:        (* x->gl_editor->e_keyfn) (x->gl_editor->e_grab, 0);
g_editor.c:        sys_getrealtime() - canvas_upclicktime < DCLICKINTERVAL)
g_editor.c:    x->gl_editor->e_lastmoved = 0;
g_editor.c:        x->gl_editor->e_grab = 0;
g_editor.c:        x->gl_editor->e_onmotion = MA_NONE;
g_editor.c:    if (x->gl_editor->e_onmotion != MA_NONE)
g_editor.c:    x->gl_editor->e_xwas = xpos;
g_editor.c:    x->gl_editor->e_ywas = ypos;
g_editor.c:        for (y = x->gl_list; y; y = y->g_next)
g_editor.c:                    shiftmod, ((mod & CTRLMOD) && (!x->gl_edit)) || altmod,
g_editor.c:        t_object *ob = pd_checkobject(&y->g_pd);
g_editor.c:        ob = pd_checkobject(&y->g_pd);
g_editor.c:                if (ob && (rt = x->gl_editor->e_textedfor) &&
g_editor.c:                    rtext_mouse(rt, xpos - x1, ypos - y1, RTEXT_SHIFT);
g_editor.c:                    x->gl_editor->e_onmotion = MA_DRAGTEXT;
g_editor.c:                    x->gl_editor->e_xwas = x1;
g_editor.c:                    x->gl_editor->e_ywas = y1;
g_editor.c:                (ob->te_pd->c_wb == &text_widgetbehavior ||
g_editor.c:                    ob->ob_pd == canvas_class) &&
g_editor.c:                        xpos >= x2-4 && ypos < y2-4)
g_editor.c:                    x->gl_editor->e_onmotion = MA_RESIZE;
g_editor.c:                    x->gl_editor->e_xwas = x1;
g_editor.c:                    x->gl_editor->e_ywas = y1;
g_editor.c:                    x->gl_editor->e_xnew = xpos;
g_editor.c:                    x->gl_editor->e_ynew = ypos;
g_editor.c:            else if (ob && (noutlet = obj_noutlets(ob)) && ypos >= y2-4)
g_editor.c:                int width = x2 - x1;
g_editor.c:                int nout1 = (noutlet > 1 ? noutlet - 1 : 1);
g_editor.c:                int closest = ((xpos-x1) * (nout1) + width/2)/width;
g_editor.c:                    (width - IOWIDTH) * closest / (nout1);
g_editor.c:                    xpos >= (hotspot-1) && xpos <= hotspot + (IOWIDTH+1))
g_editor.c:                        x->gl_editor->e_onmotion = MA_CONNECT;
g_editor.c:                        x->gl_editor->e_xwas = xpos;
g_editor.c:                        x->gl_editor->e_ywas = ypos;
g_editor.c:                          ".x%lx.c create line %d %d %d %d -width %d -tags x\n",
g_editor.c:                if (ob && (rt = x->gl_editor->e_textedfor) &&
g_editor.c:                    rtext_mouse(rt, xpos - x1, ypos - y1,
g_editor.c:                    x->gl_editor->e_onmotion = MA_DRAGTEXT;
g_editor.c:                    x->gl_editor->e_xwas = x1;
g_editor.c:                    x->gl_editor->e_ywas = y1;
g_editor.c:                    x->gl_editor->e_onmotion = MA_MOVE;
g_editor.c:            t_float area = (lx2 - lx1) * (fy - ly1) -
g_editor.c:                (ly2 - ly1) * (fx - lx1);
g_editor.c:            t_float dsquare = (lx2-lx1) * (lx2-lx1) + (ly2-ly1) * (ly2-ly1);
g_editor.c:            if ((lx2-lx1) * (fx-lx1) + (ly2-ly1) * (fy-ly1) < 0) continue;
g_editor.c:            if ((lx2-lx1) * (lx2-fx) + (ly2-ly1) * (ly2-fy) < 0) continue;
g_editor.c:                    canvas_getindex(glist2, &t.tr_ob->ob_g), t.tr_outno,
g_editor.c:                    canvas_getindex(glist2, &t.tr_ob2->ob_g), t.tr_inno);
g_editor.c:        sys_vgui(".x%lx.c create rectangle %d %d %d %d -tags x\n",
g_editor.c:        x->gl_editor->e_xwas = xpos;
g_editor.c:        x->gl_editor->e_ywas = ypos;
g_editor.c:        x->gl_editor->e_onmotion = MA_REGION;
g_editor.c:    int xwas = x->gl_editor->e_xwas,
g_editor.c:        ywas = x->gl_editor->e_ywas;
g_editor.c:            x, x->gl_editor->e_xwas,
g_editor.c:                x->gl_editor->e_ywas, xpos, ypos);
g_editor.c:        t_object *ob1 = pd_checkobject(&y1->g_pd);
g_editor.c:        t_object *ob2 = pd_checkobject(&y2->g_pd);
g_editor.c:            int width1 = x12 - x11, closest1, hotspot1;
g_editor.c:            int width2 = x22 - x21, closest2, hotspot2;
g_editor.c:                closest1 = ((xwas-x11) * (noutlet1-1) + width1/2)/width1;
g_editor.c:                    (width1 - IOWIDTH) * closest1 / (noutlet1-1);
g_editor.c:                closest2 = ((xpos-x21) * (ninlet2-1) + width2/2)/width2;
g_editor.c:                    (width2 - IOWIDTH) * closest2 / (ninlet2-1);
g_editor.c:                closest1 = noutlet1 - 1;
g_editor.c:                closest2 = ninlet2 - 1;
g_editor.c:                        ((x12-x11-IOWIDTH) * closest1)/(noutlet1-1) : 0)
g_editor.c:                        ((x22-x21-IOWIDTH) * closest2)/(ninlet2-1) : 0)
g_editor.c:                sys_vgui(".x%lx.c create line %d %d %d %d -width %d -tags [list l%lx cord]\n",
g_editor.c:                        canvas_getindex(x, &ob1->ob_g), closest1,
g_editor.c:                        canvas_getindex(x, &ob2->ob_g), closest2),
g_editor.c:    for (y = x->gl_list; y; y = y->g_next)
g_editor.c:        if (x->gl_editor->e_xwas < xpos)
g_editor.c:            lox = x->gl_editor->e_xwas, hix = xpos;
g_editor.c:        else hix = x->gl_editor->e_xwas, lox = xpos;
g_editor.c:        if (x->gl_editor->e_ywas < ypos)
g_editor.c:            loy = x->gl_editor->e_ywas, hiy = ypos;
g_editor.c:        else hiy = x->gl_editor->e_ywas, loy = ypos;
g_editor.c:        x->gl_editor->e_onmotion = MA_NONE;
g_editor.c:            x, x->gl_editor->e_xwas,
g_editor.c:                x->gl_editor->e_ywas, xpos, ypos);
g_editor.c:    if (!x->gl_editor)
g_editor.c:    if (x->gl_editor->e_onmotion == MA_CONNECT)
g_editor.c:    else if (x->gl_editor->e_onmotion == MA_REGION)
g_editor.c:    else if (x->gl_editor->e_onmotion == MA_MOVE)
g_editor.c:        if (x->gl_editor->e_selection &&
g_editor.c:            !(x->gl_editor->e_selection->sel_next))
g_editor.c:            t_gobj *g = x->gl_editor->e_selection->sel_what;
g_editor.c:                dirty sub-patch that would be discarded if we edit this. */
g_editor.c:            if (pd_class(&g->g_pd) == canvas_class &&
g_editor.c:                vmess(&gl2->gl_pd, gensym("menu-open"), "");
g_editor.c:                x->gl_editor->e_onmotion = MA_NONE;
g_editor.c:                        canvas_getrootfor(gl2)->gl_name->s_name, gl2);
g_editor.c:            gobj_activate(x->gl_editor->e_selection->sel_what, x, 1);
g_editor.c:    x->gl_editor->e_onmotion = MA_NONE;
g_editor.c:    for (y = x->gl_editor->e_selection; y; y = y->sel_next)
g_editor.c:        t_class *cl = pd_class(&y->sel_what->g_pd);
g_editor.c:        gobj_displace(y->sel_what, x, dx, dy);
g_editor.c:    if (x->gl_editor->e_selection)
g_editor.c:    if (!x || !x->gl_editor)
g_editor.c:    shift = (atom_getfloat(av+2) != 0);  /* nonzero if shift-ed */
g_editor.c:        /*-- moo: assume keynum is a Unicode codepoint; encode as UTF-8 --*/
g_editor.c:        !strcmp(av[1].a_w.w_symbol->s_name, "Return"))
g_editor.c:    if (keynumsym->s_thing && down)
g_editor.c:        pd_float(keynumsym->s_thing, (t_float)keynum);
g_editor.c:    if (keyupsym->s_thing && !down)
g_editor.c:        pd_float(keyupsym->s_thing, (t_float)keynum);
g_editor.c:    if (keynamesym->s_thing)
g_editor.c:        pd_list(keynamesym->s_thing, 0, 2, at);
g_editor.c:    if (!x->gl_editor)  /* if that 'invis'ed the window, we'd better stop. */
g_editor.c:        if (x->gl_editor->e_onmotion == MA_MOVE)
g_editor.c:            x->gl_editor->e_onmotion = MA_NONE;
g_editor.c:        if (x->gl_editor->e_grab
g_editor.c:            && x->gl_editor->e_keyfn && keynum)
g_editor.c:                (* x->gl_editor->e_keyfn)
g_editor.c:                    (x->gl_editor->e_grab, (t_float)keynum);
g_editor.c:        else if (x->gl_editor->e_textedfor && (keynum
g_editor.c:            || !strcmp(gotkeysym->s_name, "Up")
g_editor.c:            || !strcmp(gotkeysym->s_name, "Down")
g_editor.c:            || !strcmp(gotkeysym->s_name, "Left")
g_editor.c:            || !strcmp(gotkeysym->s_name, "Right")))
g_editor.c:            if (!x->gl_editor->e_textdirty)
g_editor.c:            rtext_key(x->gl_editor->e_textedfor,
g_editor.c:            if (x->gl_editor->e_textdirty)
g_editor.c:            if (x->gl_editor->e_selectedline)
g_editor.c:            else if (x->gl_editor->e_selection)
g_editor.c:        else if (!strcmp(gotkeysym->s_name, "Up"))
g_editor.c:            canvas_displaceselection(x, 0, shift ? -10 : -1);
g_editor.c:        else if (!strcmp(gotkeysym->s_name, "Down"))
g_editor.c:        else if (!strcmp(gotkeysym->s_name, "Left"))
g_editor.c:            canvas_displaceselection(x, shift ? -10 : -1, 0);
g_editor.c:        else if (!strcmp(gotkeysym->s_name, "Right"))
g_editor.c:    if (x && keynum == 0 && x->gl_edit &&
g_editor.c:        !strncmp(gotkeysym->s_name, "Control", 7))
g_editor.c:       x->gl_editor->e_xnew - x->gl_editor->e_xwas,
g_editor.c:       x->gl_editor->e_ynew - x->gl_editor->e_ywas);
g_editor.c:    x->gl_editor->e_xwas = x->gl_editor->e_xnew;
g_editor.c:    x->gl_editor->e_ywas = x->gl_editor->e_ynew;
g_editor.c:    if (!x->gl_editor)
g_editor.c:    if (x->gl_editor->e_onmotion == MA_MOVE)
g_editor.c:        if (!x->gl_editor->e_clock)
g_editor.c:            x->gl_editor->e_clock = clock_new(x, (t_method)delay_move);
g_editor.c:        clock_unset(x->gl_editor->e_clock);
g_editor.c:        clock_delay(x->gl_editor->e_clock, 5);
g_editor.c:        x->gl_editor->e_xnew = xpos;
g_editor.c:        x->gl_editor->e_ynew = ypos;
g_editor.c:    else if (x->gl_editor->e_onmotion == MA_REGION)
g_editor.c:    else if (x->gl_editor->e_onmotion == MA_CONNECT)
g_editor.c:    else if (x->gl_editor->e_onmotion == MA_PASSOUT)
g_editor.c:        if (!x->gl_editor->e_motionfn)
g_editor.c:        (*x->gl_editor->e_motionfn)(&x->gl_editor->e_grab->g_pd,
g_editor.c:            xpos - x->gl_editor->e_xwas,
g_editor.c:            ypos - x->gl_editor->e_ywas);
g_editor.c:        x->gl_editor->e_xwas = xpos;
g_editor.c:        x->gl_editor->e_ywas = ypos;
g_editor.c:    else if (x->gl_editor->e_onmotion == MA_DRAGTEXT)
g_editor.c:        t_rtext *rt = x->gl_editor->e_textedfor;
g_editor.c:            rtext_mouse(rt, xpos - x->gl_editor->e_xwas,
g_editor.c:                ypos - x->gl_editor->e_ywas, RTEXT_DRAG);
g_editor.c:    else if (x->gl_editor->e_onmotion == MA_RESIZE)
g_editor.c:            x->gl_editor->e_xwas, x->gl_editor->e_ywas,
g_editor.c:            int wantwidth = xpos - x11;
g_editor.c:            t_object *ob = pd_checkobject(&y1->g_pd);
g_editor.c:            if (ob && ob->te_pd->c_wb == &text_widgetbehavior ||
g_editor.c:                    (ob->ob_pd == canvas_class &&
g_editor.c:                        !((t_canvas *)ob)->gl_isgraph))
g_editor.c:                ob->te_width = wantwidth;
g_editor.c:            else if (ob && ob->ob_pd == canvas_class)
g_editor.c:                ((t_canvas *)ob)->gl_pixwidth += xpos - x->gl_editor->e_xnew;
g_editor.c:                ((t_canvas *)ob)->gl_pixheight += ypos - x->gl_editor->e_ynew;
g_editor.c:                x->gl_editor->e_xnew = xpos;
g_editor.c:                x->gl_editor->e_ynew = ypos;
g_editor.c:    x->gl_editor->e_lastmoved = 1;
g_editor.c:    if (!x->gl_editor) return;
g_editor.c:    x->gl_editor->e_onmotion = MA_MOVE;
g_editor.c:    x->gl_editor->e_xwas = xval;
g_editor.c:    x->gl_editor->e_ywas = yval; 
g_editor.c:/* ----------------------------- window stuff ----------------------- */
g_editor.c:    if (*s->s_name) sys_vgui(".x%lx.c postscript -file %s\n", x, s->s_name);
g_editor.c:    else sys_vgui(".x%lx.c postscript -file x.ps\n", x);
g_editor.c:    /* find a dirty sub-glist, if any, of this one (including itself) */
g_editor.c:    if (x->gl_env && x->gl_dirty)
g_editor.c:    for (g = x->gl_list; g; g = g->g_next)
g_editor.c:        if (pd_class(&g->g_pd) == canvas_class &&
g_editor.c:    for (g = canvas_list; g; g = g->gl_next)
g_editor.c:        0 - request from GUI to close, verifying whether clean or dirty
g_editor.c:        1 - request from GUI to close, no verification
g_editor.c:        2 - verified - mark this one clean, then continue as in 1
g_editor.c:        3 - verified - mark this one clean, then verify-and-quit
g_editor.c:    if (x->gl_owner && (force == 0 || force == 1))
g_editor.c:            vmess(&g->gl_pd, gensym("menu-open"), "");
g_editor.c:        else pd_free(&x->gl_pd);
g_editor.c:        pd_free(&x->gl_pd);
g_editor.c:        while (x->gl_owner)
g_editor.c:            x = x->gl_owner;
g_editor.c:            vmess(&g->gl_pd, gensym("menu-open"), "");
g_editor.c:        else pd_free(&x->gl_pd);
g_editor.c:    sprintf(buf, "pdtk_canvas_dofont %%s %d\n", x2->gl_font);
g_editor.c:    gfxstub_new(&x2->gl_pd, &x2->gl_pd, buf);
g_editor.c:        for (y = x->gl_list, myindex2 = 0; y;
g_editor.c:            y = y->g_next, myindex2++)
g_editor.c:            if (ob = pd_checkobject(&y->g_pd))
g_editor.c:                if (binbuf_match(ob->ob_binbuf, canvas_findbuf,
g_editor.c:                        vmess(&x->gl_pd, gensym("menu-open"), "");
g_editor.c:    for (y = x->gl_list, myindex2 = 0; y; y = y->g_next, myindex2++)
g_editor.c:        if (pd_class(&y->g_pd) == canvas_class)
g_editor.c:    binbuf_text(canvas_findbuf, decodedsym->s_name, strlen(decodedsym->s_name));
g_editor.c:    canvas_find_index2 = -1;
g_editor.c:    if (x->gl_owner)
g_editor.c:        canvas_vis(glist_getcanvas(x->gl_owner), 1);
g_editor.c:    for (g = gl->gl_list; g; g = g->g_next)
g_editor.c:        else if (g->g_pd == canvas_class)
g_editor.c:    for (x = canvas_list; x; x = x->gl_next)
g_editor.c:    if (!x->gl_editor) return;
g_editor.c:    for (y = x->gl_list; y; y = y2)
g_editor.c:        y2 = y->g_next;
g_editor.c:                seltail->g_next = y;
g_editor.c:                y->g_next = 0;
g_editor.c:                seltail->g_next = 0;
g_editor.c:                nontail->g_next = y;
g_editor.c:                y->g_next = 0;
g_editor.c:                nontail->g_next = 0;
g_editor.c:    if (!nonhead) x->gl_list = selhead;
g_editor.c:    else x->gl_list = nonhead, nontail->g_next = selhead;
g_editor.c:    binbuf_clear(x->gl_editor->e_connectbuf);
g_editor.c:        int s1 = glist_isselected(x, &t.tr_ob->ob_g);
g_editor.c:        int s2 = glist_isselected(x, &t.tr_ob2->ob_g);
g_editor.c:            binbuf_addv(x->gl_editor->e_connectbuf, "ssiiii;",
g_editor.c:                    glist_getindex(x, &t.tr_ob->ob_g), t.tr_outno,
g_editor.c:                        glist_getindex(x, &t.tr_ob2->ob_g), t.tr_inno);
g_editor.c:    s__X.s_thing = &x->gl_pd;
g_editor.c:    binbuf_eval(x->gl_editor->e_connectbuf, 0, 0, 0);
g_editor.c:    for (y = x->gl_list; y; y = y->g_next)
g_editor.c:        if (glist_isselected(x, &t.tr_ob->ob_g)
g_editor.c:            && glist_isselected(x, &t.tr_ob2->ob_g))
g_editor.c:                glist_selectionindex(x, &t.tr_ob->ob_g, 1), t.tr_outno,
g_editor.c:                glist_selectionindex(x, &t.tr_ob2->ob_g, 1), t.tr_inno);
g_editor.c:    if (!x->gl_editor || !x->gl_editor->e_selection)
g_editor.c:    if (x->gl_editor->e_textedfor)
g_editor.c:        rtext_getseltext(x->gl_editor->e_textedfor, &buf, &bufsize);
g_editor.c:    if (x->gl_editor->e_selectedline)
g_editor.c:        canvas_disconnect(x, x->gl_editor->e_selectline_index1,
g_editor.c:             x->gl_editor->e_selectline_outno,
g_editor.c:             x->gl_editor->e_selectline_index2,
g_editor.c:             x->gl_editor->e_selectline_inno);
g_editor.c:                x->gl_editor->e_selectline_index1,
g_editor.c:                x->gl_editor->e_selectline_outno,
g_editor.c:                x->gl_editor->e_selectline_index2,
g_editor.c:                x->gl_editor->e_selectline_inno),
g_editor.c:    if (x->gl_editor->e_selectedline)
g_editor.c:        canvas_disconnect(x, x->gl_editor->e_selectline_index1,
g_editor.c:             x->gl_editor->e_selectline_outno,
g_editor.c:             x->gl_editor->e_selectline_index2,
g_editor.c:             x->gl_editor->e_selectline_inno);
g_editor.c:                x->gl_editor->e_selectline_index1,
g_editor.c:                x->gl_editor->e_selectline_outno,
g_editor.c:                x->gl_editor->e_selectline_index2,
g_editor.c:                x->gl_editor->e_selectline_inno),
g_editor.c:    if (x->gl_editor->e_textedfor)
g_editor.c:            for (y = x->gl_list; y; y = y->g_next)
g_editor.c:                if (&y->g_pd == newest) glist_select(x, y);
g_editor.c:        for (y = x->gl_list; y; y = y2)
g_editor.c:            y2 = y->g_next;
g_editor.c:                if (y2) post("cut 5 %lx %lx", y2, y2->g_next);
g_editor.c:    if (!x->gl_editor)  /* ignore if invisible */ 
g_editor.c:    if (x->gl_editor && x->gl_editor->e_selectedline)
g_editor.c:    else if (x->gl_editor->e_textedfor)
g_editor.c:        rtext_getseltext(x->gl_editor->e_textedfor, &buf, &bufsize);
g_editor.c:        rtext_key(x->gl_editor->e_textedfor, 127, &s_);
g_editor.c:    else if (x->gl_editor && x->gl_editor->e_selection)
g_editor.c:    if (x->gl_editor)
g_editor.c:        for (sel = x->gl_editor->e_selection; sel; sel = sel->sel_next)
g_editor.c:            if (pd_class(&sel->sel_what->g_pd) == canvas_class)
g_editor.c:                canvas_loadbang((t_canvas *)(&sel->sel_what->g_pd));
g_editor.c:    t_pd *boundx = s__X.s_thing, *bounda = asym->s_thing, 
g_editor.c:    asym->s_thing = 0;
g_editor.c:    s__X.s_thing = &x->gl_pd;
g_editor.c:    for (g2 = x->gl_list, nbox = 0; g2; g2 = g2->g_next) nbox++;
g_editor.c:    for (g2 = x->gl_list, count = 0; g2; g2 = g2->g_next, count++)
g_editor.c:    asym->s_thing = bounda;
g_editor.c:    if (!x->gl_editor)
g_editor.c:    if (x->gl_editor->e_textedfor)
g_editor.c:    if (!x->gl_editor)
g_editor.c:    if (x->gl_editor->e_onmotion == MA_NONE && x->gl_editor->e_selection)
g_editor.c:        for (y = x->gl_editor->e_selection; y; y = y->sel_next)
g_editor.c:            gobj_displace(y->sel_what, x,
g_editor.c:    if (!x->gl_editor)
g_editor.c:    if (!x->gl_edit)
g_editor.c:    else for (y = x->gl_list; y; y = y->g_next)
g_editor.c:    if (x->gl_editor->e_textedfor)
g_editor.c:        if ((gwas = x->gl_editor->e_selection->sel_what) &&
g_editor.c:            !x->gl_editor->e_selection->sel_next)
g_editor.c:                indx = canvas_getindex(x, x->gl_editor->e_selection->sel_what);
g_editor.c:            for (g = x->gl_list; g; g = g->g_next)
g_editor.c:            for (g = x->gl_list; g; g = g->g_next)
g_editor.c:                if (!g->g_next)
g_editor.c:    else if (x->gl_editor->e_selection &&
g_editor.c:        !x->gl_editor->e_selection->sel_next)
g_editor.c:            gobj_activate(x->gl_editor->e_selection->sel_what, x, 1);
g_editor.c:    for (src = x->gl_list; whoout; src = src->g_next, whoout--)
g_editor.c:        if (!src->g_next) goto bad; /* bug fix thanks to Hannes */
g_editor.c:    for (sink = x->gl_list; whoin; sink = sink->g_next, whoin--)
g_editor.c:        if (!sink->g_next) goto bad;
g_editor.c:    if (!(objsrc = pd_checkobject(&src->g_pd)) ||
g_editor.c:        !(objsink = pd_checkobject(&sink->g_pd)))
g_editor.c:    if (pd_class(&src->g_pd) == text_class && objsrc->te_type == T_OBJECT)
g_editor.c:    if (pd_class(&sink->g_pd) == text_class && objsink->te_type == T_OBJECT)
g_editor.c:            inlet_new(objsink, &objsink->ob_pd, 0, 0);
g_editor.c:        sys_vgui(".x%lx.c create line %d %d %d %d -width %d -tags [list l%lx cord]\n",
g_editor.c:    post("%s %d %d %d %d (%s->%s) connection failed", 
g_editor.c:        x->gl_name->s_name, nout, outno, nin, inno,
g_editor.c:            (src? class_getname(pd_class(&src->g_pd)) : "???"),
g_editor.c:            (sink? class_getname(pd_class(&sink->g_pd)) : "???"));
g_editor.c:    int all = (x->gl_editor ? (x->gl_editor->e_selection == 0) : 1);
g_editor.c:    for (y = x->gl_list; y; y = y->g_next)
g_editor.c:        for (y2 = x->gl_list; y2; y2 = y2->g_next)
g_editor.c:            if (by1 <= ay1 + YTOLERANCE && by1 >= ay1 - YTOLERANCE &&
g_editor.c:        for (y2 = x->gl_list; y2; y2 = y2->g_next)
g_editor.c:            if (by1 <= ay1 + YTOLERANCE && by1 >= ay1 - YTOLERANCE
g_editor.c:                    gobj_displace(y2, x, 0, ay1-by1);
g_editor.c:    for (i = NHIST, ip = histogram; i--; ip++) *ip = 0;
g_editor.c:    for (y = x->gl_list; y; y = y->g_next)
g_editor.c:        for (y2 = x->gl_list; y2; y2 = y2->g_next)
g_editor.c:            if (bx1 <= ax1 + XTOLERANCE && bx1 >= ax1 - XTOLERANCE)
g_editor.c:                int distance = by1-ay2;
g_editor.c:        i < (NHIST-2); i++, ip++)
g_editor.c:        int hit = ip[-2] + 2 * ip[-1] + 3 * ip[0] + 2* ip[1] + ip[2];
g_editor.c:    for (y = x->gl_list; y; y = y->g_next)
g_editor.c:        for (y2 = x->gl_list; y2; y2 = y2->g_next)
g_editor.c:            if (bx1 <= ax1 + XTOLERANCE && bx1 >= ax1 - XTOLERANCE &&
g_editor.c:                ay1 >= by2 - 10 && ay1 < by2 + NHIST)
g_editor.c:            for (y2 = x->gl_list; y2; y2 = y2->g_next)
g_editor.c:                if (bx1 <= ax1 + XTOLERANCE && bx1 >= ax1 - XTOLERANCE &&
g_editor.c:                    int vmove = ay2 + bestdist - by1;
g_editor.c:                    gobj_displace(y2, x, ax1-bx1, vmove);
g_editor.c:    if (foo = x->gl_editor->e_textedfor)
g_editor.c:    x->gl_edit = (unsigned int) state;
g_editor.c:    if (x->gl_edit && glist_isvisible(x) && glist_istoplevel(x))
g_editor.c:          glist_getcanvas(x), x->gl_edit);
g_editor.c:    x->gl_font = font;
g_editor.c:        for (y = x->gl_list; y; y = y->g_next)
g_editor.c:            gobj_displace(y, x, nx1-x1, ny1-y1);
g_editor.c:    for (y = x->gl_list; y; y = y->g_next)
g_editor.c:        if (pd_class(&y->g_pd) == canvas_class
g_editor.c:/* ------------------------ events ---------------------------------- */
g_editor.c:/* ------------------------ menu actions ---------------------------- */
g_editor.c:        gensym("done-popup"), A_FLOAT, A_FLOAT, A_FLOAT, A_NULL);
g_editor.c:/* -------------- connect method used in reading files ------------------ */
g_editor.c:/* -------------- copy buffer ------------------ */
g_graph.c:/* Copyright (c) 1997-2001 Miller Puckette and others.
g_graph.c:/* ---------------------- forward definitions ----------------- */
g_graph.c:/* -------------------- maintaining the list -------------------- */
g_graph.c:    y->g_next = 0;
g_graph.c:    if (!x->gl_list) x->gl_list = y;
g_graph.c:        for (y2 = x->gl_list; y2->g_next; y2 = y2->g_next);
g_graph.c:        y2->g_next = y;
g_graph.c:    if (x->gl_editor && (ob = pd_checkobject(&y->g_pd)))
g_graph.c:    if (x->gl_editor && x->gl_isgraph && !x->gl_goprect
g_graph.c:        && pd_checkobject(&y->g_pd))
g_graph.c:        x->gl_goprect = 1;
g_graph.c:    if (class_isdrawcommand(y->g_pd)) 
g_graph.c:            glist_getcanvas(x)->gl_name)), 0);
g_graph.c:    a sub-canvas might delete an inlet on a box, after the box had
g_graph.c:    been invisible-ized, so that we have to protect against redrawing it! */
g_graph.c:    int ret = x->gl_isdeleting;
g_graph.c:    x->gl_isdeleting = flag;
g_graph.c:    t_gotfn chkdsp = zgetfn(&y->g_pd, gensym("dsp"));
g_graph.c:    int drawcommand = class_isdrawcommand(y->g_pd);
g_graph.c:    if (x->gl_editor)
g_graph.c:        if (x->gl_editor->e_grab == y) x->gl_editor->e_grab = 0;
g_graph.c:            /* HACK -- we had phantom outlets not getting erased on the
g_graph.c:        if (pd_class(&y->g_pd) == canvas_class)
g_graph.c:            if (gl->gl_isgraph)
g_graph.c:                glist_eraseiofor(x, &gl->gl_obj, tag);
g_graph.c:                    text_eraseborder(&gl->gl_obj, x,
g_graph.c:                        rtext_gettag(glist_findrtext(x, &gl->gl_obj)));
g_graph.c:            glist_getcanvas(x)->gl_name)), 2);
g_graph.c:    if (x->gl_editor && (ob = pd_checkobject(&y->g_pd)))
g_graph.c:    if (x->gl_list == y) x->gl_list = y->g_next;
g_graph.c:    else for (g = x->gl_list; g; g = g->g_next)
g_graph.c:        if (g->g_next == y)
g_graph.c:        g->g_next = y->g_next;
g_graph.c:    pd_free(&y->g_pd);
g_graph.c:            glist_getcanvas(x)->gl_name)), 1);
g_graph.c:    x->gl_valid = ++glist_valid;
g_graph.c:    while (y = x->gl_list)
g_graph.c:        if (!suspended && pd_checkobject(&y->g_pd) && zgetfn(&y->g_pd, dspsym))
g_graph.c:    if (glist->gl_editor && glist->gl_editor->e_rtext)
g_graph.c:        x2->gl_editor->e_onmotion = MA_PASSOUT;
g_graph.c:    else x2->gl_editor->e_onmotion = 0;
g_graph.c:    x2->gl_editor->e_grab = y;
g_graph.c:    x2->gl_editor->e_motionfn = motionfn;
g_graph.c:    x2->gl_editor->e_keyfn = keyfn;
g_graph.c:    x2->gl_editor->e_xwas = xpos;
g_graph.c:    x2->gl_editor->e_ywas = ypos;
g_graph.c:    while (x->gl_owner && !x->gl_havewindow && x->gl_isgraph)
g_graph.c:            x = x->gl_owner;
g_graph.c:    if (pd_class(&g->g_pd) == scalar_class)
g_graph.c:            g9->g_next = g1, g9 = g1;
g_graph.c:        if (g1 = g1->g_next)
g_graph.c:        g9->g_next = 0;
g_graph.c:            g9->g_next = g2, g9 = g2;
g_graph.c:        if (g2 = g2->g_next)
g_graph.c:        g9->g_next = 0;
g_graph.c:        int n1 = nitems/2, n2 = nitems - n1, i;
g_graph.c:        for (g2 = g, i = n1-1; i--; g2 = g2->g_next)
g_graph.c:        g3 = g2->g_next;
g_graph.c:        g2->g_next = 0;
g_graph.c:    t_float lastx = -1e37;
g_graph.c:    for (g = x->gl_list; g; g = g->g_next)
g_graph.c:        x->gl_list = glist_dosort(x, x->gl_list, nitems);
g_graph.c:/* --------------- inlets and outlets  ----------- */
g_graph.c:    t_inlet *ip = inlet_new(&x->gl_obj, who, s, 0);
g_graph.c:    if (!x->gl_loading && x->gl_owner && glist_isvisible(x->gl_owner))
g_graph.c:        gobj_vis(&x->gl_gobj, x->gl_owner, 0);
g_graph.c:        gobj_vis(&x->gl_gobj, x->gl_owner, 1);
g_graph.c:        canvas_fixlinesfor(x->gl_owner, &x->gl_obj);
g_graph.c:    if (!x->gl_loading) canvas_resortinlets(x);
g_graph.c:    t_canvas *owner = x->gl_owner;
g_graph.c:    int redraw = (owner && glist_isvisible(owner) && (!owner->gl_isdeleting)
g_graph.c:    if (owner) canvas_deletelinesforio(owner, &x->gl_obj, ip, 0);
g_graph.c:        gobj_vis(&x->gl_gobj, x->gl_owner, 0);
g_graph.c:        gobj_vis(&x->gl_gobj, x->gl_owner, 1);
g_graph.c:        canvas_fixlinesfor(x->gl_owner, &x->gl_obj);
g_graph.c:    for (ninlets = 0, y = x->gl_list; y; y = y->g_next)
g_graph.c:        if (pd_class(&y->g_pd) == vinlet_class) ninlets++;
g_graph.c:    for (y = x->gl_list, vp = vec; y; y = y->g_next)
g_graph.c:        if (pd_class(&y->g_pd) == vinlet_class) *vp++ = y;
g_graph.c:    for (i = ninlets; i--;)
g_graph.c:        for (vp = vec, xmax = -0x7fffffff, maxp = 0, j = ninlets;
g_graph.c:            j--; vp++)
g_graph.c:        ip = vinlet_getit(&y->g_pd);
g_graph.c:        obj_moveinletfirst(&x->gl_obj, ip);
g_graph.c:    if (x->gl_owner && glist_isvisible(x->gl_owner))
g_graph.c:        canvas_fixlinesfor(x->gl_owner, &x->gl_obj);
g_graph.c:    t_outlet *op = outlet_new(&x->gl_obj, s);
g_graph.c:    if (!x->gl_loading && x->gl_owner && glist_isvisible(x->gl_owner))
g_graph.c:        gobj_vis(&x->gl_gobj, x->gl_owner, 0);
g_graph.c:        gobj_vis(&x->gl_gobj, x->gl_owner, 1);
g_graph.c:        canvas_fixlinesfor(x->gl_owner, &x->gl_obj);
g_graph.c:    if (!x->gl_loading) canvas_resortoutlets(x);
g_graph.c:    t_canvas *owner = x->gl_owner;
g_graph.c:    int redraw = (owner && glist_isvisible(owner) && (!owner->gl_isdeleting)
g_graph.c:    if (owner) canvas_deletelinesforio(owner, &x->gl_obj, 0, op);
g_graph.c:        gobj_vis(&x->gl_gobj, x->gl_owner, 0);
g_graph.c:        gobj_vis(&x->gl_gobj, x->gl_owner, 1);
g_graph.c:        canvas_fixlinesfor(x->gl_owner, &x->gl_obj);
g_graph.c:    for (noutlets = 0, y = x->gl_list; y; y = y->g_next)
g_graph.c:        if (pd_class(&y->g_pd) == voutlet_class) noutlets++;
g_graph.c:    for (y = x->gl_list, vp = vec; y; y = y->g_next)
g_graph.c:        if (pd_class(&y->g_pd) == voutlet_class) *vp++ = y;
g_graph.c:    for (i = noutlets; i--;)
g_graph.c:        for (vp = vec, xmax = -0x7fffffff, maxp = 0, j = noutlets;
g_graph.c:            j--; vp++)
g_graph.c:        ip = voutlet_getit(&y->g_pd);
g_graph.c:        obj_moveoutletfirst(&x->gl_obj, ip);
g_graph.c:    if (x->gl_owner && glist_isvisible(x->gl_owner))
g_graph.c:        canvas_fixlinesfor(x->gl_owner, &x->gl_obj);
g_graph.c:/* ----------calculating coordinates and controlling appearance --------- */
g_graph.c:    x->gl_x1 = x1;
g_graph.c:    x->gl_x2 = x2;
g_graph.c:    x->gl_y1 = y1;
g_graph.c:    x->gl_y2 = y2;
g_graph.c:    if (x->gl_x2 == x->gl_x1 ||
g_graph.c:        x->gl_y2 == x->gl_y1)
g_graph.c:    x->gl_xtick.k_point = point;
g_graph.c:    x->gl_xtick.k_inc = inc;
g_graph.c:    x->gl_xtick.k_lperb = f;
g_graph.c:    x->gl_ytick.k_point = point;
g_graph.c:    x->gl_ytick.k_inc = inc;
g_graph.c:    x->gl_ytick.k_lperb = f;
g_graph.c:        x->gl_xlabely = atom_getfloat(argv);
g_graph.c:        argv++; argc--;
g_graph.c:        x->gl_xlabel = (t_symbol **)t_resizebytes(x->gl_xlabel, 
g_graph.c:            x->gl_nxlabels * sizeof (t_symbol *), argc * sizeof (t_symbol *));
g_graph.c:        x->gl_nxlabels = argc;
g_graph.c:        for (i = 0; i < argc; i++) x->gl_xlabel[i] = atom_gensym(&argv[i]);
g_graph.c:        x->gl_ylabelx = atom_getfloat(argv);
g_graph.c:        argv++; argc--;
g_graph.c:        x->gl_ylabel = (t_symbol **)t_resizebytes(x->gl_ylabel, 
g_graph.c:            x->gl_nylabels * sizeof (t_symbol *), argc * sizeof (t_symbol *));
g_graph.c:        x->gl_nylabels = argc;
g_graph.c:        for (i = 0; i < argc; i++) x->gl_ylabel[i] = atom_gensym(&argv[i]);
g_graph.c:        of a one-pixel square at top left of the window. */
g_graph.c:    if (!x->gl_isgraph)
g_graph.c:        return (x->gl_x1 + (x->gl_x2 - x->gl_x1) * xpix);
g_graph.c:    else if (x->gl_isgraph && x->gl_havewindow)
g_graph.c:        return (x->gl_x1 + (x->gl_x2 - x->gl_x1) * 
g_graph.c:            (xpix) / (x->gl_screenx2 - x->gl_screenx1));
g_graph.c:        if (!x->gl_owner)
g_graph.c:        graph_graphrect(&x->gl_gobj, x->gl_owner, &x1, &y1, &x2, &y2);
g_graph.c:        return (x->gl_x1 + (x->gl_x2 - x->gl_x1) * 
g_graph.c:            (xpix - x1) / (x2 - x1));
g_graph.c:    if (!x->gl_isgraph)
g_graph.c:        return (x->gl_y1 + (x->gl_y2 - x->gl_y1) * ypix);
g_graph.c:    else if (x->gl_isgraph && x->gl_havewindow)
g_graph.c:        return (x->gl_y1 + (x->gl_y2 - x->gl_y1) * 
g_graph.c:                (ypix) / (x->gl_screeny2 - x->gl_screeny1));
g_graph.c:        if (!x->gl_owner)
g_graph.c:        graph_graphrect(&x->gl_gobj, x->gl_owner, &x1, &y1, &x2, &y2);
g_graph.c:        return (x->gl_y1 + (x->gl_y2 - x->gl_y1) * 
g_graph.c:            (ypix - y1) / (y2 - y1));
g_graph.c:    if (!x->gl_isgraph)
g_graph.c:        return ((xval - x->gl_x1) / (x->gl_x2 - x->gl_x1));
g_graph.c:    else if (x->gl_isgraph && x->gl_havewindow)
g_graph.c:        return (x->gl_screenx2 - x->gl_screenx1) * 
g_graph.c:            (xval - x->gl_x1) / (x->gl_x2 - x->gl_x1);
g_graph.c:        if (!x->gl_owner)
g_graph.c:        graph_graphrect(&x->gl_gobj, x->gl_owner, &x1, &y1, &x2, &y2);
g_graph.c:        return (x1 + (x2 - x1) * (xval - x->gl_x1) / (x->gl_x2 - x->gl_x1));
g_graph.c:    if (!x->gl_isgraph)
g_graph.c:        return ((yval - x->gl_y1) / (x->gl_y2 - x->gl_y1));
g_graph.c:    else if (x->gl_isgraph && x->gl_havewindow)
g_graph.c:        return (x->gl_screeny2 - x->gl_screeny1) * 
g_graph.c:                (yval - x->gl_y1) / (x->gl_y2 - x->gl_y1);
g_graph.c:        if (!x->gl_owner)
g_graph.c:        graph_graphrect(&x->gl_gobj, x->gl_owner, &x1, &y1, &x2, &y2);
g_graph.c:        return (y1 + (y2 - y1) * (yval - x->gl_y1) / (x->gl_y2 - x->gl_y1));
g_graph.c:    return (dxpix * (glist_pixelstox(x, 1) - glist_pixelstox(x, 0)));
g_graph.c:    return (dypix * (glist_pixelstoy(x, 1) - glist_pixelstoy(x, 0)));
g_graph.c:    in is toplevel.  Otherwise, if it's a new-style graph-on-parent
g_graph.c:    proportional-style GOP.  In this case we do a coordinate transformation. */
g_graph.c:    if (glist->gl_havewindow || !glist->gl_isgraph)
g_graph.c:        return (x->te_xpix);
g_graph.c:    else if (glist->gl_goprect)
g_graph.c:        return (glist_xtopixels(glist, glist->gl_x1) +
g_graph.c:            x->te_xpix - glist->gl_xmargin);
g_graph.c:            glist->gl_x1 + (glist->gl_x2 - glist->gl_x1) * 
g_graph.c:                x->te_xpix / (glist->gl_screenx2 - glist->gl_screenx1)));
g_graph.c:    if (glist->gl_havewindow || !glist->gl_isgraph)
g_graph.c:        return (x->te_ypix);
g_graph.c:    else if (glist->gl_goprect)
g_graph.c:        return (glist_ytopixels(glist, glist->gl_y1) +
g_graph.c:            x->te_ypix - glist->gl_ymargin);
g_graph.c:            glist->gl_y1 + (glist->gl_y2 - glist->gl_y1) * 
g_graph.c:                x->te_ypix / (glist->gl_screeny2 - glist->gl_screeny1)));
g_graph.c:    This is too conservative -- for instance, when you draw an "open"
g_graph.c:            for (g = x->gl_list; g; g = g->g_next)
g_graph.c:            if (x->gl_goprect)
g_graph.c:        if (x->gl_owner && glist_isvisible(x->gl_owner))
g_graph.c:            graph_vis(&x->gl_gobj, x->gl_owner, 0); 
g_graph.c:            graph_vis(&x->gl_gobj, x->gl_owner, 1);
g_graph.c:/* --------------------------- widget behavior  ------------------- */
g_graph.c:    if (!x->gl_isgraph)
g_graph.c:        rtext_draw(glist_findrtext(parent_glist, &x->gl_obj));
g_graph.c:        rtext_erase(glist_findrtext(parent_glist, &x->gl_obj));
g_graph.c:        glist_drawiofor(parent_glist, &x->gl_obj, 1,
g_graph.c:    else glist_eraseiofor(parent_glist, &x->gl_obj, tag);
g_graph.c:    if (x->gl_havewindow)
g_graph.c: %d %d %d %d %d %d %d %d %d %d -tags [list %s graph] -fill #c0c0c0\n",
g_graph.c:                glist_getcanvas(x->gl_owner),
g_graph.c:                glist_getcanvas(x->gl_owner), tag);
g_graph.c:            %d %d %d %d %d %d %d %d %d %d -tags [list %s graph]\n",
g_graph.c:            glist_getcanvas(x->gl_owner),
g_graph.c:        for (i = (y1 < y2 ? y1 : y2)-1, g = x->gl_list; g; g = g->g_next)
g_graph.c:            if (g->g_pd == garray_class &&
g_graph.c:            i -= sys_fontheight(glist_getfont(x));
g_graph.c:            sys_vgui(".x%lx.c create text %d %d -text {%s} -anchor nw\
g_graph.c:             -font {{%s} -%d %s} -tags [list %s label graph]\n",
g_graph.c:             (long)glist_getcanvas(x),  x1, i, arrayname->s_name, sys_font,
g_graph.c:        if (x->gl_xtick.k_lperb)
g_graph.c:            for (i = 0, f = x->gl_xtick.k_point;
g_graph.c:                f < 0.99 * x->gl_x2 + 0.01*x->gl_x1; i++,
g_graph.c:                    f += x->gl_xtick.k_inc)
g_graph.c:                int tickpix = (i % x->gl_xtick.k_lperb ? 2 : 4);
g_graph.c:                sys_vgui(".x%lx.c create line %d %d %d %d -tags [list %s graph]\n",
g_graph.c:                    glist_getcanvas(x->gl_owner),
g_graph.c:                    (int)glist_xtopixels(x, f), (int)upix - tickpix, tag);
g_graph.c:                sys_vgui(".x%lx.c create line %d %d %d %d -tags [list %s graph]\n",
g_graph.c:                    glist_getcanvas(x->gl_owner),
g_graph.c:            for (i = 1, f = x->gl_xtick.k_point - x->gl_xtick.k_inc;
g_graph.c:                f > 0.99 * x->gl_x1 + 0.01*x->gl_x2;
g_graph.c:                    i++, f -= x->gl_xtick.k_inc)
g_graph.c:                int tickpix = (i % x->gl_xtick.k_lperb ? 2 : 4);
g_graph.c:                sys_vgui(".x%lx.c create line %d %d %d %d -tags [list %s graph]\n",
g_graph.c:                    glist_getcanvas(x->gl_owner),
g_graph.c:                    (int)glist_xtopixels(x, f), (int)upix - tickpix, tag);
g_graph.c:                sys_vgui(".x%lx.c create line %d %d %d %d -tags [list %s graph]\n",
g_graph.c:                    glist_getcanvas(x->gl_owner),
g_graph.c:        if (x->gl_ytick.k_lperb)
g_graph.c:            if (x->gl_y2 < x->gl_y1)
g_graph.c:                ubound = x->gl_y1, lbound = x->gl_y2;
g_graph.c:            else ubound = x->gl_y2, lbound = x->gl_y1;
g_graph.c:            for (i = 0, f = x->gl_ytick.k_point;
g_graph.c:                    i++, f += x->gl_ytick.k_inc)
g_graph.c:                int tickpix = (i % x->gl_ytick.k_lperb ? 2 : 4);
g_graph.c:                sys_vgui(".x%lx.c create line %d %d %d %d -tags [list %s graph]\n",
g_graph.c:                    glist_getcanvas(x->gl_owner),
g_graph.c:                sys_vgui(".x%lx.c create line %d %d %d %d -tags [list %s graph]\n",
g_graph.c:                    glist_getcanvas(x->gl_owner),
g_graph.c:                    x2 - tickpix, (int)glist_ytopixels(x, f), tag);
g_graph.c:            for (i = 1, f = x->gl_ytick.k_point - x->gl_ytick.k_inc;
g_graph.c:                    i++, f -= x->gl_ytick.k_inc)
g_graph.c:                int tickpix = (i % x->gl_ytick.k_lperb ? 2 : 4);
g_graph.c:                sys_vgui(".x%lx.c create line %d %d %d %d -tags [list %s graph]\n",
g_graph.c:                    glist_getcanvas(x->gl_owner),
g_graph.c:                sys_vgui(".x%lx.c create line %d %d %d %d -tags [list %s graph]\n",
g_graph.c:                    glist_getcanvas(x->gl_owner),
g_graph.c:                    x2 - tickpix, (int)glist_ytopixels(x, f), tag);
g_graph.c:        for (i = 0; i < x->gl_nxlabels; i++)
g_graph.c:        %d %d -text {%s} -font {{%s} -%d %s} -tags [list %s label graph]\n",
g_graph.c:                (int)glist_xtopixels(x, atof(x->gl_xlabel[i]->s_name)),
g_graph.c:                (int)glist_ytopixels(x, x->gl_xlabely),
g_graph.c:                x->gl_xlabel[i]->s_name, sys_font, 
g_graph.c:        for (i = 0; i < x->gl_nylabels; i++)
g_graph.c:        %d %d -text {%s} -font {{%s} -%d %s} -tags [list %s label graph]\n",
g_graph.c:                (int)glist_xtopixels(x, x->gl_ylabelx),
g_graph.c:                (int)glist_ytopixels(x, atof(x->gl_ylabel[i]->s_name)),
g_graph.c:                x->gl_ylabel[i]->s_name, sys_font,
g_graph.c:        for (g = x->gl_list; g; g = g->g_next)
g_graph.c:            glist_getcanvas(x->gl_owner), tag);
g_graph.c:        for (g = x->gl_list; g; g = g->g_next)
g_graph.c:    int x1 = text_xpix(&x->gl_obj, glist);
g_graph.c:    int y1 = text_ypix(&x->gl_obj, glist);
g_graph.c:    x2 = x1 + x->gl_pixwidth;
g_graph.c:    y2 = y1 + x->gl_pixheight;
g_graph.c:    /* get the rectangle, enlarged to contain all the "contents" --
g_graph.c:    int x1 = 0x7fffffff, y1 = 0x7fffffff, x2 = -0x7fffffff, y2 = -0x7fffffff;
g_graph.c:    if (x->gl_isgraph)
g_graph.c:        if (!x->gl_goprect)
g_graph.c:            to the old (0.37) graph-on-parent behavior. */
g_graph.c:            hadwindow = x->gl_havewindow;
g_graph.c:            x->gl_havewindow = 0;
g_graph.c:            for (g = x->gl_list; g; g = g->g_next)
g_graph.c:                if (pd_class(&g->g_pd) == garray_class)
g_graph.c:            x->gl_havewindow = hadwindow;
g_graph.c:    if (!x->gl_isgraph)
g_graph.c:        x->gl_obj.te_xpix += dx;
g_graph.c:        x->gl_obj.te_ypix += dy;
g_graph.c:        canvas_fixlinesfor(glist, &x->gl_obj);
g_graph.c:    if (!x->gl_isgraph)
g_graph.c:        t_rtext *y = glist_findrtext(glist, &x->gl_obj);
g_graph.c:        sys_vgui(".x%lx.c itemconfigure %sR -fill %s\n", glist, 
g_graph.c:        sys_vgui(".x%lx.c itemconfigure graph%lx -fill %s\n",
g_graph.c:    if (!x->gl_isgraph)
g_graph.c:        while (y = x->gl_list) glist_delete(x, y);
g_graph.c:    while (y = x->gl_list)
g_graph.c:    t_garray *a = (t_garray *)(x->gl_list);
g_graph.c:        oldx = nelem - 1;
g_graph.c:        newx = nelem - 1;
g_graph.c:    if (oldx < newx - 1)
g_graph.c:            vec[i].w_float = newy + (oldy - newy) *
g_graph.c:                ((t_float)(newx - i))/(t_float)(newx - oldx);
g_graph.c:        for (i = oldx - 1; i >= newx; i--)
g_graph.c:            vec[i].w_float = newy + (oldy - newy) *
g_graph.c:                ((t_float)(newx - i))/(t_float)(newx - oldx);
g_graph.c:    if (!x->gl_isgraph)
g_graph.c:    else if (x->gl_havewindow)
g_graph.c:        for (y = x->gl_list; y; y = y->g_next)
g_graph.c:    for (z = x->gl_list; z; z = z->g_next)
g_graph.c:        if (pd_class(&z->g_pd) == canvas_class && ((t_glist *)z)->gl_isgraph)
g_guiconnect.c:/* Copyright (c) 1997-2000 Miller Puckette.
g_guiconnect.c:around (so is better suited to one-off dialogs)
g_guiconnect.c:    x->x_who = who;
g_guiconnect.c:    x->x_sym = sym;
g_guiconnect.c:    pd_bind(&x->x_obj.ob_pd, sym);
g_guiconnect.c:    if (x->x_sym)
g_guiconnect.c:        pd_unbind(&x->x_obj.ob_pd, x->x_sym);
g_guiconnect.c:    if (x->x_clock)
g_guiconnect.c:        clock_free(x->x_clock); 
g_guiconnect.c:    pd_free(&x->x_obj.ob_pd);
g_guiconnect.c:    if (!x->x_sym)
g_guiconnect.c:        pd_free(&x->x_obj.ob_pd);
g_guiconnect.c:        x->x_who = 0;
g_guiconnect.c:            x->x_clock = clock_new(x, (t_method)guiconnect_tick);
g_guiconnect.c:            clock_delay(x->x_clock, timedelay);
g_guiconnect.c:    if (x->x_who)
g_guiconnect.c:        typedmess(x->x_who, s, ac, av);
g_guiconnect.c:    if (!x->x_who)
g_guiconnect.c:        pd_free(&x->x_obj.ob_pd);
g_guiconnect.c:        pd_unbind(&x->x_obj.ob_pd, x->x_sym);
g_guiconnect.c:        x->x_sym = 0;
g_hdial.c:/* Copyright (c) 1997-1999 Miller Puckette.
g_hdial.c:/* g_7_guis.c written by Thomas Musil (c) IEM KUG Graz Austria 2000-2001 */
g_hdial.c:/* ------------- hdl     gui-horicontal dial ---------------------- */
g_hdial.c:        sys_vgui(".x%lx.c itemconfigure %lxBUT%d -fill #%6.6x -outline #%6.6x\n",
g_hdial.c:                 canvas, x, x->x_drawn,
g_hdial.c:                 x->x_gui.x_bcol, x->x_gui.x_bcol);
g_hdial.c:        sys_vgui(".x%lx.c itemconfigure %lxBUT%d -fill #%6.6x -outline #%6.6x\n",
g_hdial.c:                 canvas, x, x->x_on,
g_hdial.c:                 x->x_gui.x_fcol, x->x_gui.x_fcol);
g_hdial.c:        x->x_drawn = x->x_on;
g_hdial.c:    int n=x->x_number, i, dx=x->x_gui.x_w, s4=dx/4;
g_hdial.c:    int yy11=text_ypix(&x->x_gui.x_obj, glist), yy12=yy11+dx;
g_hdial.c:    int yy21=yy11+s4, yy22=yy12-s4;
g_hdial.c:    int xx11b=text_xpix(&x->x_gui.x_obj, glist), xx11=xx11b, xx21=xx11b+s4;
g_hdial.c:    int xx22=xx11b+dx-s4;
g_hdial.c:        sys_vgui(".x%lx.c create rectangle %d %d %d %d -fill #%6.6x -tags %lxBASE%d\n",
g_hdial.c:                 x->x_gui.x_bcol, x, i);
g_hdial.c:        sys_vgui(".x%lx.c create rectangle %d %d %d %d -fill #%6.6x -outline #%6.6x -tags %lxBUT%d\n",
g_hdial.c:                 (x->x_on==i)?x->x_gui.x_fcol:x->x_gui.x_bcol,
g_hdial.c:                 (x->x_on==i)?x->x_gui.x_fcol:x->x_gui.x_bcol, x, i);
g_hdial.c:        x->x_drawn = x->x_on;
g_hdial.c:    sys_vgui(".x%lx.c create text %d %d -text {%s} -anchor w \
g_hdial.c:             -font {{%s} -%d %s} -fill #%6.6x -tags [list %lxLABEL label text]\n",
g_hdial.c:             canvas, xx11b+x->x_gui.x_ldx, yy11+x->x_gui.x_ldy,
g_hdial.c:             strcmp(x->x_gui.x_lab->s_name, "empty")?x->x_gui.x_lab->s_name:"",
g_hdial.c:             x->x_gui.x_font, x->x_gui.x_fontsize, sys_fontweight,
g_hdial.c:             x->x_gui.x_lcol, x);
g_hdial.c:    if(!x->x_gui.x_fsf.x_snd_able)
g_hdial.c:        sys_vgui(".x%lx.c create rectangle %d %d %d %d -tags [list %lxOUT%d outlet]\n",
g_hdial.c:             canvas, xx11b, yy12-1, xx11b + IOWIDTH, yy12, x, 0);
g_hdial.c:    if(!x->x_gui.x_fsf.x_rcv_able)
g_hdial.c:        sys_vgui(".x%lx.c create rectangle %d %d %d %d -tags [list %lxIN%d inlet]\n",
g_hdial.c:    int n=x->x_number, i, dx=x->x_gui.x_w, s4=dx/4;
g_hdial.c:    int yy11=text_ypix(&x->x_gui.x_obj, glist), yy12=yy11+dx;
g_hdial.c:    int yy21=yy11+s4, yy22=yy12-s4;
g_hdial.c:    int xx11b=text_xpix(&x->x_gui.x_obj, glist), xx11=xx11b, xx21=xx11b+s4;
g_hdial.c:    int xx22=xx11b+dx-s4;
g_hdial.c:    xx22=xx11b+dx-s4;
g_hdial.c:             canvas, x, xx11b+x->x_gui.x_ldx, yy11+x->x_gui.x_ldy);
g_hdial.c:    if(!x->x_gui.x_fsf.x_snd_able)
g_hdial.c:             canvas, x, 0, xx11b, yy12-1, xx11b + IOWIDTH, yy12);
g_hdial.c:    if(!x->x_gui.x_fsf.x_rcv_able)
g_hdial.c:    int n=x->x_number, i;
g_hdial.c:    if(!x->x_gui.x_fsf.x_snd_able)
g_hdial.c:    if(!x->x_gui.x_fsf.x_rcv_able)
g_hdial.c:    int n=x->x_number, i;
g_hdial.c:    sys_vgui(".x%lx.c itemconfigure %lxLABEL -font {{%s} -%d %s} -fill #%6.6x -text {%s} \n",
g_hdial.c:             canvas, x, x->x_gui.x_font, x->x_gui.x_fontsize, sys_fontweight,
g_hdial.c:             x->x_gui.x_fsf.x_selected?IEM_GUI_COLOR_SELECTED:x->x_gui.x_lcol,
g_hdial.c:             strcmp(x->x_gui.x_lab->s_name, "empty")?x->x_gui.x_lab->s_name:"");
g_hdial.c:        sys_vgui(".x%lx.c itemconfigure %lxBASE%d -fill #%6.6x\n", canvas, x, i,
g_hdial.c:                 x->x_gui.x_bcol);
g_hdial.c:        sys_vgui(".x%lx.c itemconfigure %lxBUT%d -fill #%6.6x -outline #%6.6x\n", canvas, x, i,
g_hdial.c:                 (x->x_on==i)?x->x_gui.x_fcol:x->x_gui.x_bcol,
g_hdial.c:                 (x->x_on==i)?x->x_gui.x_fcol:x->x_gui.x_bcol);
g_hdial.c:    int xpos=text_xpix(&x->x_gui.x_obj, glist);
g_hdial.c:    int ypos=text_ypix(&x->x_gui.x_obj, glist);
g_hdial.c:    if((old_snd_rcv_flags & IEM_GUI_OLD_SND_FLAG) && !x->x_gui.x_fsf.x_snd_able)
g_hdial.c:        sys_vgui(".x%lx.c create rectangle %d %d %d %d -tags %lxOUT%d\n",
g_hdial.c:                 xpos, ypos + x->x_gui.x_w-1,
g_hdial.c:                 xpos + IOWIDTH, ypos + x->x_gui.x_w,
g_hdial.c:    if(!(old_snd_rcv_flags & IEM_GUI_OLD_SND_FLAG) && x->x_gui.x_fsf.x_snd_able)
g_hdial.c:    if((old_snd_rcv_flags & IEM_GUI_OLD_RCV_FLAG) && !x->x_gui.x_fsf.x_rcv_able)
g_hdial.c:        sys_vgui(".x%lx.c create rectangle %d %d %d %d -tags %lxIN%d\n",
g_hdial.c:    if(!(old_snd_rcv_flags & IEM_GUI_OLD_RCV_FLAG) && x->x_gui.x_fsf.x_rcv_able)
g_hdial.c:    int n=x->x_number, i;
g_hdial.c:    if(x->x_gui.x_fsf.x_selected)
g_hdial.c:            sys_vgui(".x%lx.c itemconfigure %lxBASE%d -outline #%6.6x\n", canvas, x, i,
g_hdial.c:        sys_vgui(".x%lx.c itemconfigure %lxLABEL -fill #%6.6x\n", canvas, x, IEM_GUI_COLOR_SELECTED);
g_hdial.c:            sys_vgui(".x%lx.c itemconfigure %lxBASE%d -outline #%6.6x\n", canvas, x, i,
g_hdial.c:        sys_vgui(".x%lx.c itemconfigure %lxLABEL -fill #%6.6x\n", canvas, x,
g_hdial.c:                 x->x_gui.x_lcol);
g_hdial.c:        hradio_draw_io(x, glist, mode - IEM_GUI_DRAW_MODE_IO);
g_hdial.c:/* ------------------------ hdl widgetbehaviour----------------------------- */
g_hdial.c:    *xp1 = text_xpix(&x->x_gui.x_obj, glist);
g_hdial.c:    *yp1 = text_ypix(&x->x_gui.x_obj, glist);
g_hdial.c:    *xp2 = *xp1 + x->x_gui.x_w*x->x_number;
g_hdial.c:    *yp2 = *yp1 + x->x_gui.x_h;
g_hdial.c:    iemgui_save(&x->x_gui, srl, bflcol);
g_hdial.c:                (int)x->x_gui.x_obj.te_xpix, (int)x->x_gui.x_obj.te_ypix,
g_hdial.c:                (pd_class(&x->x_gui.x_obj.ob_pd) == hradio_old_class ?
g_hdial.c:                x->x_gui.x_w,
g_hdial.c:                x->x_change, iem_symargstoint(&x->x_gui.x_isa), x->x_number,
g_hdial.c:                x->x_gui.x_ldx, x->x_gui.x_ldy,
g_hdial.c:                iem_fstyletoint(&x->x_gui.x_fsf), x->x_gui.x_fontsize,
g_hdial.c:                bflcol[0], bflcol[1], bflcol[2], x->x_on);
g_hdial.c:    int hchange=-1;
g_hdial.c:    iemgui_properties(&x->x_gui, srl);
g_hdial.c:    if (pd_class(&x->x_gui.x_obj.ob_pd) == hradio_old_class)
g_hdial.c:        hchange = x->x_change;
g_hdial.c:            ----------dimensions(pix):----------- %d %d size: 0 0 empty \
g_hdial.c:            %d new-only new&old %d %d number: %d \
g_hdial.c:            x->x_gui.x_w, IEM_GUI_MINSIZE,
g_hdial.c:            hchange, x->x_gui.x_isa.x_loadinit, -1, x->x_number,
g_hdial.c:            srl[0]->s_name, srl[1]->s_name,
g_hdial.c:            srl[2]->s_name, x->x_gui.x_ldx, x->x_gui.x_ldy,
g_hdial.c:            x->x_gui.x_fsf.x_font_style, x->x_gui.x_fontsize,
g_hdial.c:            0xffffff & x->x_gui.x_bcol, 0xffffff & x->x_gui.x_fcol, 0xffffff & x->x_gui.x_lcol);
g_hdial.c:    gfxstub_new(&x->x_gui.x_obj.ob_pd, x, buf);
g_hdial.c:    x->x_change = chg;
g_hdial.c:    sr_flags = iemgui_dialog(&x->x_gui, srl, argc, argv);
g_hdial.c:    x->x_gui.x_w = iemgui_clip_size(a);
g_hdial.c:    x->x_gui.x_h = x->x_gui.x_w;
g_hdial.c:    if(x->x_number != num)
g_hdial.c:        (*x->x_gui.x_draw)(x, x->x_gui.x_glist, IEM_GUI_DRAW_MODE_ERASE);
g_hdial.c:        x->x_number = num;
g_hdial.c:        if(x->x_on >= x->x_number)
g_hdial.c:            x->x_on = x->x_number - 1;
g_hdial.c:            x->x_on_old = x->x_on;
g_hdial.c:        (*x->x_gui.x_draw)(x, x->x_gui.x_glist, IEM_GUI_DRAW_MODE_NEW);
g_hdial.c:        (*x->x_gui.x_draw)(x, x->x_gui.x_glist, IEM_GUI_DRAW_MODE_CONFIG);
g_hdial.c:        (*x->x_gui.x_draw)(x, x->x_gui.x_glist, IEM_GUI_DRAW_MODE_IO + sr_flags);
g_hdial.c:        (*x->x_gui.x_draw)(x, x->x_gui.x_glist, IEM_GUI_DRAW_MODE_MOVE);
g_hdial.c:        canvas_fixlinesfor(x->x_gui.x_glist, (t_text*)x);
g_hdial.c:    int old=x->x_on_old;
g_hdial.c:    if(i >= x->x_number)
g_hdial.c:        i = x->x_number-1;
g_hdial.c:    if(x->x_on != x->x_on_old)
g_hdial.c:        old = x->x_on_old;
g_hdial.c:        x->x_on_old = x->x_on;
g_hdial.c:        x->x_on = i;
g_hdial.c:        (*x->x_gui.x_draw)(x, x->x_gui.x_glist, IEM_GUI_DRAW_MODE_UPDATE);
g_hdial.c:        x->x_on_old = old;
g_hdial.c:        x->x_on = i;
g_hdial.c:        (*x->x_gui.x_draw)(x, x->x_gui.x_glist, IEM_GUI_DRAW_MODE_UPDATE);
g_hdial.c:    if (pd_class(&x->x_gui.x_obj.ob_pd) == hradio_old_class)
g_hdial.c:        if((x->x_change)&&(x->x_on != x->x_on_old))
g_hdial.c:            SETFLOAT(x->x_at, (t_float)x->x_on_old);
g_hdial.c:            SETFLOAT(x->x_at+1, 0.0);
g_hdial.c:            outlet_list(x->x_gui.x_obj.ob_outlet, &s_list, 2, x->x_at);
g_hdial.c:            if(x->x_gui.x_fsf.x_snd_able && x->x_gui.x_snd->s_thing)
g_hdial.c:                pd_list(x->x_gui.x_snd->s_thing, &s_list, 2, x->x_at);
g_hdial.c:        x->x_on_old = x->x_on;
g_hdial.c:        SETFLOAT(x->x_at, (t_float)x->x_on);
g_hdial.c:        SETFLOAT(x->x_at+1, 1.0);
g_hdial.c:        outlet_list(x->x_gui.x_obj.ob_outlet, &s_list, 2, x->x_at);
g_hdial.c:        if(x->x_gui.x_fsf.x_snd_able && x->x_gui.x_snd->s_thing)
g_hdial.c:            pd_list(x->x_gui.x_snd->s_thing, &s_list, 2, x->x_at);
g_hdial.c:        outlet_float(x->x_gui.x_obj.ob_outlet, x->x_on);
g_hdial.c:        if(x->x_gui.x_fsf.x_snd_able && x->x_gui.x_snd->s_thing)
g_hdial.c:            pd_float(x->x_gui.x_snd->s_thing, x->x_on);
g_hdial.c:    if(i >= x->x_number)
g_hdial.c:        i = x->x_number-1;
g_hdial.c:    if (pd_class(&x->x_gui.x_obj.ob_pd) == hradio_old_class)
g_hdial.c:        if((x->x_change)&&(i != x->x_on_old))
g_hdial.c:            SETFLOAT(x->x_at, (t_float)x->x_on_old);
g_hdial.c:            SETFLOAT(x->x_at+1, 0.0);
g_hdial.c:            outlet_list(x->x_gui.x_obj.ob_outlet, &s_list, 2, x->x_at);
g_hdial.c:            if(x->x_gui.x_fsf.x_snd_able && x->x_gui.x_snd->s_thing)
g_hdial.c:                pd_list(x->x_gui.x_snd->s_thing, &s_list, 2, x->x_at);
g_hdial.c:        if(x->x_on != x->x_on_old)
g_hdial.c:            x->x_on_old = x->x_on;
g_hdial.c:        x->x_on = i;
g_hdial.c:        (*x->x_gui.x_draw)(x, x->x_gui.x_glist, IEM_GUI_DRAW_MODE_UPDATE);
g_hdial.c:        x->x_on_old = x->x_on;
g_hdial.c:        SETFLOAT(x->x_at, (t_float)x->x_on);
g_hdial.c:        SETFLOAT(x->x_at+1, 1.0);
g_hdial.c:        outlet_list(x->x_gui.x_obj.ob_outlet, &s_list, 2, x->x_at);
g_hdial.c:        if(x->x_gui.x_fsf.x_snd_able && x->x_gui.x_snd->s_thing)
g_hdial.c:            pd_list(x->x_gui.x_snd->s_thing, &s_list, 2, x->x_at);
g_hdial.c:        x->x_on_old = x->x_on;
g_hdial.c:        x->x_on = i;
g_hdial.c:        (*x->x_gui.x_draw)(x, x->x_gui.x_glist, IEM_GUI_DRAW_MODE_UPDATE);
g_hdial.c:        outlet_float(x->x_gui.x_obj.ob_outlet, x->x_on);
g_hdial.c:        if(x->x_gui.x_fsf.x_snd_able && x->x_gui.x_snd->s_thing)
g_hdial.c:            pd_float(x->x_gui.x_snd->s_thing, x->x_on);
g_hdial.c:    if(i >= x->x_number)
g_hdial.c:        i = x->x_number-1;
g_hdial.c:    if (pd_class(&x->x_gui.x_obj.ob_pd) == hradio_old_class)
g_hdial.c:        if((x->x_change)&&(i != x->x_on_old))
g_hdial.c:            if(x->x_gui.x_fsf.x_put_in2out)
g_hdial.c:                SETFLOAT(x->x_at, (t_float)x->x_on_old);
g_hdial.c:                SETFLOAT(x->x_at+1, 0.0);
g_hdial.c:                outlet_list(x->x_gui.x_obj.ob_outlet, &s_list, 2, x->x_at);
g_hdial.c:                if(x->x_gui.x_fsf.x_snd_able && x->x_gui.x_snd->s_thing)
g_hdial.c:                    pd_list(x->x_gui.x_snd->s_thing, &s_list, 2, x->x_at);
g_hdial.c:        if(x->x_on != x->x_on_old)
g_hdial.c:            x->x_on_old = x->x_on;
g_hdial.c:        x->x_on = i;
g_hdial.c:        (*x->x_gui.x_draw)(x, x->x_gui.x_glist, IEM_GUI_DRAW_MODE_UPDATE);
g_hdial.c:        x->x_on_old = x->x_on;
g_hdial.c:        if(x->x_gui.x_fsf.x_put_in2out)
g_hdial.c:            SETFLOAT(x->x_at, (t_float)x->x_on);
g_hdial.c:            SETFLOAT(x->x_at+1, 1.0);
g_hdial.c:            outlet_list(x->x_gui.x_obj.ob_outlet, &s_list, 2, x->x_at);
g_hdial.c:            if(x->x_gui.x_fsf.x_snd_able && x->x_gui.x_snd->s_thing)
g_hdial.c:                pd_list(x->x_gui.x_snd->s_thing, &s_list, 2, x->x_at);
g_hdial.c:        x->x_on_old = x->x_on;
g_hdial.c:        x->x_on = i;
g_hdial.c:        (*x->x_gui.x_draw)(x, x->x_gui.x_glist, IEM_GUI_DRAW_MODE_UPDATE);
g_hdial.c:        if (x->x_gui.x_fsf.x_put_in2out)
g_hdial.c:            outlet_float(x->x_gui.x_obj.ob_outlet, x->x_on);
g_hdial.c:            if(x->x_gui.x_fsf.x_snd_able && x->x_gui.x_snd->s_thing)
g_hdial.c:                pd_float(x->x_gui.x_snd->s_thing, x->x_on);
g_hdial.c:    int xx = (int)xpos - (int)text_xpix(&x->x_gui.x_obj, x->x_gui.x_glist);
g_hdial.c:    hradio_fout(x, (t_float)(xx / x->x_gui.x_w));
g_hdial.c:    if(!sys_noloadbang && x->x_gui.x_isa.x_loadinit)
g_hdial.c:    if(n != x->x_number)
g_hdial.c:        (*x->x_gui.x_draw)(x, x->x_gui.x_glist, IEM_GUI_DRAW_MODE_ERASE);
g_hdial.c:        x->x_number = n;
g_hdial.c:        if(x->x_on >= x->x_number)
g_hdial.c:            x->x_on = x->x_number - 1;
g_hdial.c:        x->x_on_old = x->x_on;
g_hdial.c:        (*x->x_gui.x_draw)(x, x->x_gui.x_glist, IEM_GUI_DRAW_MODE_NEW);
g_hdial.c:    x->x_gui.x_w = iemgui_clip_size((int)atom_getintarg(0, ac, av));
g_hdial.c:    x->x_gui.x_h = x->x_gui.x_w;
g_hdial.c:    iemgui_size((void *)x, &x->x_gui);
g_hdial.c:{iemgui_delta((void *)x, &x->x_gui, s, ac, av);}
g_hdial.c:{iemgui_pos((void *)x, &x->x_gui, s, ac, av);}
g_hdial.c:{iemgui_color((void *)x, &x->x_gui, s, ac, av);}
g_hdial.c:{iemgui_send(x, &x->x_gui, s);}
g_hdial.c:{iemgui_receive(x, &x->x_gui, s);}
g_hdial.c:{iemgui_label((void *)x, &x->x_gui, s);}
g_hdial.c:{iemgui_label_pos((void *)x, &x->x_gui, s, ac, av);}
g_hdial.c:{iemgui_label_font((void *)x, &x->x_gui, s, ac, av);}
g_hdial.c:    x->x_gui.x_isa.x_loadinit = (f==0.0)?0:1;
g_hdial.c:{x->x_change = 1;}
g_hdial.c:{x->x_change = 0;}
g_hdial.c:    int bflcol[]={-262144, -1, -1};
g_hdial.c:    int ldx=0, ldy=-8, chg=1, num=8;
g_hdial.c:    iem_inttosymargs(&x->x_gui.x_isa, 0);
g_hdial.c:    iem_inttofstyle(&x->x_gui.x_fsf, 0);
g_hdial.c:        iem_inttosymargs(&x->x_gui.x_isa, atom_getintarg(2, argc, argv));
g_hdial.c:        iemgui_new_getnames(&x->x_gui, 4, argv);
g_hdial.c:        iem_inttofstyle(&x->x_gui.x_fsf, atom_getintarg(9, argc, argv));
g_hdial.c:    else iemgui_new_getnames(&x->x_gui, 4, 0);
g_hdial.c:    x->x_gui.x_draw = (t_iemfunptr)hradio_draw;
g_hdial.c:    x->x_gui.x_fsf.x_snd_able = 1;
g_hdial.c:    x->x_gui.x_fsf.x_rcv_able = 1;
g_hdial.c:    x->x_gui.x_glist = (t_glist *)canvas_getcurrent();
g_hdial.c:    if (!strcmp(x->x_gui.x_snd->s_name, "empty"))
g_hdial.c:        x->x_gui.x_fsf.x_snd_able = 0;
g_hdial.c:    if (!strcmp(x->x_gui.x_rcv->s_name, "empty"))
g_hdial.c:        x->x_gui.x_fsf.x_rcv_able = 0;
g_hdial.c:    if(x->x_gui.x_fsf.x_font_style == 1) strcpy(x->x_gui.x_font, "helvetica");
g_hdial.c:    else if(x->x_gui.x_fsf.x_font_style == 2) strcpy(x->x_gui.x_font, "times");
g_hdial.c:    else { x->x_gui.x_fsf.x_font_style = 0;
g_hdial.c:        strcpy(x->x_gui.x_font, sys_font); }
g_hdial.c:    x->x_number = num;
g_hdial.c:    if(on >= x->x_number)
g_hdial.c:        on = x->x_number - 1;
g_hdial.c:    if(x->x_gui.x_isa.x_loadinit)
g_hdial.c:        x->x_on = on;
g_hdial.c:        x->x_on = 0;
g_hdial.c:    x->x_on_old = x->x_on;
g_hdial.c:    x->x_change = (chg==0)?0:1;
g_hdial.c:    if (x->x_gui.x_fsf.x_rcv_able)
g_hdial.c:        pd_bind(&x->x_gui.x_obj.ob_pd, x->x_gui.x_rcv);
g_hdial.c:    x->x_gui.x_ldx = ldx;
g_hdial.c:    x->x_gui.x_ldy = ldy;
g_hdial.c:    x->x_gui.x_fontsize = fs;
g_hdial.c:    x->x_gui.x_w = iemgui_clip_size(a);
g_hdial.c:    x->x_gui.x_h = x->x_gui.x_w;
g_hdial.c:    iemgui_verify_snd_ne_rcv(&x->x_gui);
g_hdial.c:    iemgui_all_colfromload(&x->x_gui, bflcol);
g_hdial.c:    outlet_new(&x->x_gui.x_obj, &s_list);
g_hdial.c:    if(x->x_gui.x_fsf.x_rcv_able)
g_hdial.c:        pd_unbind(&x->x_gui.x_obj.ob_pd, x->x_gui.x_rcv);
g_hdial.c:        /*obsolete version (0.34-0.35) */
g_hslider.c:/* Copyright (c) 1997-1999 Miller Puckette.
g_hslider.c:/* g_7_guis.c written by Thomas Musil (c) IEM KUG Graz Austria 2000-2001 */
g_hslider.c:/* ------------ hsl    gui-horicontal  slider ----------------------- */
g_hslider.c:        int r = text_xpix(&x->x_gui.x_obj, glist) + (x->x_val + 50)/100;
g_hslider.c:        int ypos=text_ypix(&x->x_gui.x_obj, glist);
g_hslider.c:                 r, ypos + x->x_gui.x_h);
g_hslider.c:        if(x->x_val == x->x_center)
g_hslider.c:            if(!x->x_thick)
g_hslider.c:                sys_vgui(".x%lx.c itemconfigure %lxKNOB -width 7\n", canvas, x);
g_hslider.c:                x->x_thick = 1;
g_hslider.c:            if(x->x_thick)
g_hslider.c:                sys_vgui(".x%lx.c itemconfigure %lxKNOB -width 3\n", canvas, x);
g_hslider.c:                x->x_thick = 0;
g_hslider.c:    int xpos=text_xpix(&x->x_gui.x_obj, glist);
g_hslider.c:    int ypos=text_ypix(&x->x_gui.x_obj, glist);
g_hslider.c:    int r = xpos + (x->x_val + 50)/100;
g_hslider.c:    sys_vgui(".x%lx.c create rectangle %d %d %d %d -fill #%6.6x -tags %lxBASE\n",
g_hslider.c:             canvas, xpos-3, ypos,
g_hslider.c:             xpos + x->x_gui.x_w+2, ypos + x->x_gui.x_h,
g_hslider.c:             x->x_gui.x_bcol, x);
g_hslider.c:    sys_vgui(".x%lx.c create line %d %d %d %d -width 3 -fill #%6.6x -tags %lxKNOB\n",
g_hslider.c:             ypos + x->x_gui.x_h, x->x_gui.x_fcol, x);
g_hslider.c:    sys_vgui(".x%lx.c create text %d %d -text {%s} -anchor w \
g_hslider.c:             -font {{%s} -%d %s} -fill #%6.6x -tags [list %lxLABEL label text]\n",
g_hslider.c:             canvas, xpos+x->x_gui.x_ldx,
g_hslider.c:             ypos+x->x_gui.x_ldy,
g_hslider.c:             strcmp(x->x_gui.x_lab->s_name, "empty")?x->x_gui.x_lab->s_name:"",
g_hslider.c:             x->x_gui.x_font, x->x_gui.x_fontsize, sys_fontweight,
g_hslider.c:             x->x_gui.x_lcol, x);
g_hslider.c:    if(!x->x_gui.x_fsf.x_snd_able)
g_hslider.c:        sys_vgui(".x%lx.c create rectangle %d %d %d %d -tags [list %lxOUT%d outlet]\n",
g_hslider.c:             canvas, xpos-3, ypos + x->x_gui.x_h-1,
g_hslider.c:             xpos+4, ypos + x->x_gui.x_h, x, 0);
g_hslider.c:    if(!x->x_gui.x_fsf.x_rcv_able)
g_hslider.c:        sys_vgui(".x%lx.c create rectangle %d %d %d %d -tags [list %lxIN%d inlet]\n",
g_hslider.c:             canvas, xpos-3, ypos,
g_hslider.c:    int xpos=text_xpix(&x->x_gui.x_obj, glist);
g_hslider.c:    int ypos=text_ypix(&x->x_gui.x_obj, glist);
g_hslider.c:    int r = xpos + (x->x_val + 50)/100;
g_hslider.c:             xpos-3, ypos,
g_hslider.c:             xpos + x->x_gui.x_w+2, ypos + x->x_gui.x_h);
g_hslider.c:             r, ypos + x->x_gui.x_h);
g_hslider.c:             canvas, x, xpos+x->x_gui.x_ldx, ypos+x->x_gui.x_ldy);
g_hslider.c:    if(!x->x_gui.x_fsf.x_snd_able)
g_hslider.c:             xpos-3, ypos + x->x_gui.x_h-1,
g_hslider.c:             xpos+4, ypos + x->x_gui.x_h);
g_hslider.c:    if(!x->x_gui.x_fsf.x_rcv_able)
g_hslider.c:             xpos-3, ypos,
g_hslider.c:    if(!x->x_gui.x_fsf.x_snd_able)
g_hslider.c:    if(!x->x_gui.x_fsf.x_rcv_able)
g_hslider.c:    sys_vgui(".x%lx.c itemconfigure %lxLABEL -font {{%s} -%d %s} -fill #%6.6x -text {%s} \n",
g_hslider.c:             canvas, x, x->x_gui.x_font, x->x_gui.x_fontsize, sys_fontweight,
g_hslider.c:             x->x_gui.x_fsf.x_selected?IEM_GUI_COLOR_SELECTED:x->x_gui.x_lcol,
g_hslider.c:             strcmp(x->x_gui.x_lab->s_name, "empty")?x->x_gui.x_lab->s_name:"");
g_hslider.c:    sys_vgui(".x%lx.c itemconfigure %lxKNOB -fill #%6.6x\n", canvas, x, x->x_gui.x_fcol);
g_hslider.c:    sys_vgui(".x%lx.c itemconfigure %lxBASE -fill #%6.6x\n", canvas, x, x->x_gui.x_bcol);
g_hslider.c:    int xpos=text_xpix(&x->x_gui.x_obj, glist);
g_hslider.c:    int ypos=text_ypix(&x->x_gui.x_obj, glist);
g_hslider.c:    if((old_snd_rcv_flags & IEM_GUI_OLD_SND_FLAG) && !x->x_gui.x_fsf.x_snd_able)
g_hslider.c:        sys_vgui(".x%lx.c create rectangle %d %d %d %d -tags %lxOUT%d\n",
g_hslider.c:             canvas, xpos-3, ypos + x->x_gui.x_h-1,
g_hslider.c:             xpos+4, ypos + x->x_gui.x_h, x, 0);
g_hslider.c:    if(!(old_snd_rcv_flags & IEM_GUI_OLD_SND_FLAG) && x->x_gui.x_fsf.x_snd_able)
g_hslider.c:    if((old_snd_rcv_flags & IEM_GUI_OLD_RCV_FLAG) && !x->x_gui.x_fsf.x_rcv_able)
g_hslider.c:        sys_vgui(".x%lx.c create rectangle %d %d %d %d -tags %lxIN%d\n",
g_hslider.c:             canvas, xpos-3, ypos,
g_hslider.c:    if(!(old_snd_rcv_flags & IEM_GUI_OLD_RCV_FLAG) && x->x_gui.x_fsf.x_rcv_able)
g_hslider.c:    if(x->x_gui.x_fsf.x_selected)
g_hslider.c:        sys_vgui(".x%lx.c itemconfigure %lxBASE -outline #%6.6x\n", canvas, x, IEM_GUI_COLOR_SELECTED);
g_hslider.c:        sys_vgui(".x%lx.c itemconfigure %lxLABEL -fill #%6.6x\n", canvas, x, IEM_GUI_COLOR_SELECTED);
g_hslider.c:        sys_vgui(".x%lx.c itemconfigure %lxBASE -outline #%6.6x\n", canvas, x, IEM_GUI_COLOR_NORMAL);
g_hslider.c:        sys_vgui(".x%lx.c itemconfigure %lxLABEL -fill #%6.6x\n", canvas, x, x->x_gui.x_lcol);
g_hslider.c:        hslider_draw_io(x, glist, mode - IEM_GUI_DRAW_MODE_IO);
g_hslider.c:/* ------------------------ hsl widgetbehaviour----------------------------- */
g_hslider.c:    *xp1 = text_xpix(&x->x_gui.x_obj, glist) - 3;
g_hslider.c:    *yp1 = text_ypix(&x->x_gui.x_obj, glist);
g_hslider.c:    *xp2 = *xp1 + x->x_gui.x_w + 5;
g_hslider.c:    *yp2 = *yp1 + x->x_gui.x_h;
g_hslider.c:    iemgui_save(&x->x_gui, srl, bflcol);
g_hslider.c:                (int)x->x_gui.x_obj.te_xpix, (int)x->x_gui.x_obj.te_ypix,
g_hslider.c:                gensym("hsl"), x->x_gui.x_w, x->x_gui.x_h,
g_hslider.c:                (t_float)x->x_min, (t_float)x->x_max,
g_hslider.c:                x->x_lin0_log1, iem_symargstoint(&x->x_gui.x_isa),
g_hslider.c:                x->x_gui.x_ldx, x->x_gui.x_ldy,
g_hslider.c:                iem_fstyletoint(&x->x_gui.x_fsf), x->x_gui.x_fontsize,
g_hslider.c:                x->x_val, x->x_steady);
g_hslider.c:    x->x_gui.x_w = w;
g_hslider.c:    x->x_center = (x->x_gui.x_w-1)*50;
g_hslider.c:    if(x->x_val > (x->x_gui.x_w*100 - 100))
g_hslider.c:        x->x_pos = x->x_gui.x_w*100 - 100;
g_hslider.c:        x->x_val = x->x_pos;
g_hslider.c:    if(x->x_lin0_log1)
g_hslider.c:        x->x_k = log(x->x_max/x->x_min)/(double)(x->x_gui.x_w - 1);
g_hslider.c:        x->x_k = (x->x_max - x->x_min)/(double)(x->x_gui.x_w - 1);
g_hslider.c:    if(x->x_lin0_log1)
g_hslider.c:    x->x_min = min;
g_hslider.c:    x->x_max = max;
g_hslider.c:    if(x->x_min > x->x_max)                /* bugfix */
g_hslider.c:        x->x_gui.x_isa.x_reverse = 1;
g_hslider.c:        x->x_gui.x_isa.x_reverse = 0;
g_hslider.c:    if(x->x_lin0_log1)
g_hslider.c:        x->x_k = log(x->x_max/x->x_min)/(double)(x->x_gui.x_w - 1);
g_hslider.c:        x->x_k = (x->x_max - x->x_min)/(double)(x->x_gui.x_w - 1);
g_hslider.c:    iemgui_properties(&x->x_gui, srl);
g_hslider.c:            --------dimensions(pix)(pix):-------- %d %d width: %d %d height: \
g_hslider.c:            -----------output-range:----------- %g left: %g right: %g \
g_hslider.c:            x->x_gui.x_w, IEM_SL_MINSIZE, x->x_gui.x_h, IEM_GUI_MINSIZE,
g_hslider.c:            x->x_min, x->x_max, 0.0,/*no_schedule*/
g_hslider.c:            x->x_lin0_log1, x->x_gui.x_isa.x_loadinit, x->x_steady, -1,/*no multi, but iem-characteristic*/
g_hslider.c:            srl[0]->s_name, srl[1]->s_name,
g_hslider.c:            srl[2]->s_name, x->x_gui.x_ldx, x->x_gui.x_ldy,
g_hslider.c:            x->x_gui.x_fsf.x_font_style, x->x_gui.x_fontsize,
g_hslider.c:            0xffffff & x->x_gui.x_bcol, 0xffffff & x->x_gui.x_fcol, 0xffffff & x->x_gui.x_lcol);
g_hslider.c:    gfxstub_new(&x->x_gui.x_obj.ob_pd, x, buf);
g_hslider.c:    int old = x->x_val;
g_hslider.c:    if(x->x_gui.x_isa.x_reverse)    /* bugfix */
g_hslider.c:        if(f > x->x_min)
g_hslider.c:            f = x->x_min;
g_hslider.c:        if(f < x->x_max)
g_hslider.c:            f = x->x_max;
g_hslider.c:        if(f > x->x_max)
g_hslider.c:            f = x->x_max;
g_hslider.c:        if(f < x->x_min)
g_hslider.c:            f = x->x_min;
g_hslider.c:    if(x->x_lin0_log1)
g_hslider.c:        g = log(f/x->x_min)/x->x_k;
g_hslider.c:        g = (f - x->x_min) / x->x_k;
g_hslider.c:    x->x_val = (int)(100.0*g + 0.49999);
g_hslider.c:    x->x_pos = x->x_val;
g_hslider.c:    if(x->x_val != old)
g_hslider.c:        (*x->x_gui.x_draw)(x, x->x_gui.x_glist, IEM_GUI_DRAW_MODE_UPDATE);
g_hslider.c:    if(x->x_lin0_log1)
g_hslider.c:        out = x->x_min*exp(x->x_k*(double)(x->x_val)*0.01);
g_hslider.c:        out = (double)(x->x_val)*0.01*x->x_k + x->x_min;
g_hslider.c:    if((out < 1.0e-10)&&(out > -1.0e-10))
g_hslider.c:    outlet_float(x->x_gui.x_obj.ob_outlet, out);
g_hslider.c:    if(x->x_gui.x_fsf.x_snd_able && x->x_gui.x_snd->s_thing)
g_hslider.c:        pd_float(x->x_gui.x_snd->s_thing, out);
g_hslider.c:    x->x_lin0_log1 = lilo;
g_hslider.c:        x->x_steady = 1;
g_hslider.c:        x->x_steady = 0;
g_hslider.c:    sr_flags = iemgui_dialog(&x->x_gui, srl, argc, argv);
g_hslider.c:    x->x_gui.x_h = iemgui_clip_size(h);
g_hslider.c:    (*x->x_gui.x_draw)(x, x->x_gui.x_glist, IEM_GUI_DRAW_MODE_CONFIG);
g_hslider.c:    (*x->x_gui.x_draw)(x, x->x_gui.x_glist, IEM_GUI_DRAW_MODE_IO + sr_flags);
g_hslider.c:    (*x->x_gui.x_draw)(x, x->x_gui.x_glist, IEM_GUI_DRAW_MODE_MOVE);
g_hslider.c:    canvas_fixlinesfor(x->x_gui.x_glist, (t_text*)x);
g_hslider.c:    int old = x->x_val;
g_hslider.c:    if(x->x_gui.x_fsf.x_finemoved)
g_hslider.c:        x->x_pos += (int)dx;
g_hslider.c:        x->x_pos += 100*(int)dx;
g_hslider.c:    x->x_val = x->x_pos;
g_hslider.c:    if(x->x_val > (100*x->x_gui.x_w - 100))
g_hslider.c:        x->x_val = 100*x->x_gui.x_w - 100;
g_hslider.c:        x->x_pos += 50;
g_hslider.c:        x->x_pos -= x->x_pos%100;
g_hslider.c:    if(x->x_val < 0)
g_hslider.c:        x->x_val = 0;
g_hslider.c:        x->x_pos -= 50;
g_hslider.c:        x->x_pos -= x->x_pos%100;
g_hslider.c:    if(old != x->x_val)
g_hslider.c:        (*x->x_gui.x_draw)(x, x->x_gui.x_glist, IEM_GUI_DRAW_MODE_UPDATE);
g_hslider.c:    if(!x->x_steady)
g_hslider.c:        x->x_val = (int)(100.0 * (xpos - text_xpix(&x->x_gui.x_obj, x->x_gui.x_glist)));
g_hslider.c:    if(x->x_val > (100*x->x_gui.x_w - 100))
g_hslider.c:        x->x_val = 100*x->x_gui.x_w - 100;
g_hslider.c:    if(x->x_val < 0)
g_hslider.c:        x->x_val = 0;
g_hslider.c:    x->x_pos = x->x_val;
g_hslider.c:    (*x->x_gui.x_draw)(x, x->x_gui.x_glist, IEM_GUI_DRAW_MODE_UPDATE);
g_hslider.c:    glist_grab(x->x_gui.x_glist, &x->x_gui.x_obj.te_g, (t_glistmotionfn)hslider_motion,
g_hslider.c:            x->x_gui.x_fsf.x_finemoved = 1;
g_hslider.c:            x->x_gui.x_fsf.x_finemoved = 0;
g_hslider.c:        x->x_gui.x_h = iemgui_clip_size((int)atom_getintarg(1, ac, av));
g_hslider.c:    iemgui_size((void *)x, &x->x_gui);
g_hslider.c:{iemgui_delta((void *)x, &x->x_gui, s, ac, av);}
g_hslider.c:{iemgui_pos((void *)x, &x->x_gui, s, ac, av);}
g_hslider.c:{iemgui_color((void *)x, &x->x_gui, s, ac, av);}
g_hslider.c:{iemgui_send(x, &x->x_gui, s);}
g_hslider.c:{iemgui_receive(x, &x->x_gui, s);}
g_hslider.c:{iemgui_label((void *)x, &x->x_gui, s);}
g_hslider.c:{iemgui_label_pos((void *)x, &x->x_gui, s, ac, av);}
g_hslider.c:{iemgui_label_font((void *)x, &x->x_gui, s, ac, av);}
g_hslider.c:    x->x_lin0_log1 = 1;
g_hslider.c:    hslider_check_minmax(x, x->x_min, x->x_max);
g_hslider.c:    x->x_lin0_log1 = 0;
g_hslider.c:    x->x_k = (x->x_max - x->x_min)/(double)(x->x_gui.x_w - 1);
g_hslider.c:    x->x_gui.x_isa.x_loadinit = (f==0.0)?0:1;
g_hslider.c:    x->x_steady = (f==0.0)?0:1;
g_hslider.c:    if(x->x_lin0_log1)
g_hslider.c:        out = x->x_min*exp(x->x_k*(double)(x->x_val)*0.01);
g_hslider.c:        out = (double)(x->x_val)*0.01*x->x_k + x->x_min;
g_hslider.c:    if((out < 1.0e-10)&&(out > -1.0e-10))
g_hslider.c:    if(x->x_gui.x_fsf.x_put_in2out)
g_hslider.c:        outlet_float(x->x_gui.x_obj.ob_outlet, out);
g_hslider.c:        if(x->x_gui.x_fsf.x_snd_able && x->x_gui.x_snd->s_thing)
g_hslider.c:            pd_float(x->x_gui.x_snd->s_thing, out);
g_hslider.c:    if(!sys_noloadbang && x->x_gui.x_isa.x_loadinit)
g_hslider.c:        (*x->x_gui.x_draw)(x, x->x_gui.x_glist, IEM_GUI_DRAW_MODE_UPDATE);
g_hslider.c:    int bflcol[]={-262144, -1, -1};
g_hslider.c:    int lilo=0, ldx=-2, ldy=-8, f=0, v=0, steady=1;
g_hslider.c:    double min=0.0, max=(double)(IEM_SL_DEFAULTSIZE-1);
g_hslider.c:    iem_inttosymargs(&x->x_gui.x_isa, 0);
g_hslider.c:    iem_inttofstyle(&x->x_gui.x_fsf, 0);
g_hslider.c:        iem_inttosymargs(&x->x_gui.x_isa, atom_getintarg(5, argc, argv));
g_hslider.c:        iemgui_new_getnames(&x->x_gui, 6, argv);
g_hslider.c:        iem_inttofstyle(&x->x_gui.x_fsf, atom_getintarg(11, argc, argv));
g_hslider.c:    else iemgui_new_getnames(&x->x_gui, 6, 0);
g_hslider.c:    x->x_gui.x_draw = (t_iemfunptr)hslider_draw;
g_hslider.c:    x->x_gui.x_fsf.x_snd_able = 1;
g_hslider.c:    x->x_gui.x_fsf.x_rcv_able = 1;
g_hslider.c:    x->x_gui.x_glist = (t_glist *)canvas_getcurrent();
g_hslider.c:    if(x->x_gui.x_isa.x_loadinit)
g_hslider.c:        x->x_val = v;
g_hslider.c:        x->x_val = 0;
g_hslider.c:    x->x_pos = x->x_val;
g_hslider.c:    x->x_lin0_log1 = lilo;
g_hslider.c:    x->x_steady = steady;
g_hslider.c:    if (!strcmp(x->x_gui.x_snd->s_name, "empty"))
g_hslider.c:        x->x_gui.x_fsf.x_snd_able = 0;
g_hslider.c:    if (!strcmp(x->x_gui.x_rcv->s_name, "empty"))
g_hslider.c:        x->x_gui.x_fsf.x_rcv_able = 0;
g_hslider.c:    if(x->x_gui.x_fsf.x_font_style == 1) strcpy(x->x_gui.x_font, "helvetica");
g_hslider.c:    else if(x->x_gui.x_fsf.x_font_style == 2) strcpy(x->x_gui.x_font, "times");
g_hslider.c:    else { x->x_gui.x_fsf.x_font_style = 0;
g_hslider.c:        strcpy(x->x_gui.x_font, sys_font); }
g_hslider.c:    if(x->x_gui.x_fsf.x_rcv_able)
g_hslider.c:        pd_bind(&x->x_gui.x_obj.ob_pd, x->x_gui.x_rcv);
g_hslider.c:    x->x_gui.x_ldx = ldx;
g_hslider.c:    x->x_gui.x_ldy = ldy;
g_hslider.c:    x->x_gui.x_fontsize = fs;
g_hslider.c:    x->x_gui.x_h = iemgui_clip_size(h);
g_hslider.c:    iemgui_all_colfromload(&x->x_gui, bflcol);
g_hslider.c:    x->x_thick = 0;
g_hslider.c:    iemgui_verify_snd_ne_rcv(&x->x_gui);
g_hslider.c:    outlet_new(&x->x_gui.x_obj, &s_float);
g_hslider.c:    if(x->x_gui.x_fsf.x_rcv_able)
g_hslider.c:        pd_unbind(&x->x_gui.x_obj.ob_pd, x->x_gui.x_rcv);
g_io.c:/* Copyright (c) 1997-1999 Miller Puckette.
g_io.c:/* ------------------------- vinlet -------------------------- */
g_io.c:    x->x_canvas = canvas_getcurrent();
g_io.c:    x->x_inlet = canvas_addinlet(x->x_canvas, &x->x_obj.ob_pd, 0);
g_io.c:    x->x_bufsize = 0;
g_io.c:    x->x_buf = 0;
g_io.c:    outlet_new(&x->x_obj, 0);
g_io.c:    outlet_bang(x->x_obj.ob_outlet);
g_io.c:    outlet_pointer(x->x_obj.ob_outlet, gp);
g_io.c:    outlet_float(x->x_obj.ob_outlet, f);
g_io.c:    outlet_symbol(x->x_obj.ob_outlet, s);
g_io.c:    outlet_list(x->x_obj.ob_outlet, s, argc, argv);
g_io.c:    outlet_anything(x->x_obj.ob_outlet, s, argc, argv);
g_io.c:    canvas_rminlet(x->x_canvas, x->x_inlet);
g_io.c:    resample_free(&x->x_updown);
g_io.c:    return (((t_vinlet *)x)->x_inlet);
g_io.c:/* ------------------------- signal inlet -------------------------- */
g_io.c:    return (x->x_buf != 0);
g_io.c:    t_float *in = x->x_read;
g_io.c:    if (tot < 5) post("-in %lx out %lx n %d", in, out, n);
g_io.c:    if (tot < 5) post("-buf %lx endbuf %lx", x->x_buf, x->x_endbuf);
g_io.c:    while (n--) *out++ = *in++;
g_io.c:    if (in == x->x_endbuf) in = x->x_buf;
g_io.c:    x->x_read = in;
g_io.c:    if (!x->x_buf)
g_io.c:    if (x->x_directsignal)
g_io.c:        signal_setborrowed(sp[0], x->x_directsignal);
g_io.c:        dsp_add(vinlet_perform, 3, x, outsig->s_vec, outsig->s_vecsize);
g_io.c:        x->x_read = x->x_buf;
g_io.c:    t_float *out = x->x_fill;
g_io.c:    if (out == x->x_endbuf)
g_io.c:      t_float *f1 = x->x_buf, *f2 = x->x_buf + x->x_hop;
g_io.c:        int nshift = x->x_bufsize - x->x_hop;
g_io.c:        out -= x->x_hop;
g_io.c:        while (nshift--) *f1++ = *f2++;
g_io.c:    while (n--) *out++ = *in++;
g_io.c:    x->x_fill = out;
g_io.c:    if (!x->x_buf)
g_io.c:    x->x_updown.downsample = downsample;
g_io.c:    x->x_updown.upsample   = upsample;
g_io.c:        if (!x->x_buf) return;
g_io.c:            /* the prolog code counts from 0 to period-1; the
g_io.c:        prologphase = (phase - 1) & (period - 1);
g_io.c:            insig = parentsigs[inlet_getsignalindex(x->x_inlet)];
g_io.c:            parentvecsize = insig->s_vecsize;
g_io.c:        if (bufsize != (oldbufsize = x->x_bufsize))
g_io.c:            t_float *buf = x->x_buf;
g_io.c:            x->x_bufsize = bufsize;
g_io.c:            x->x_endbuf = buf + bufsize;
g_io.c:            x->x_buf = buf;
g_io.c:            x->x_hop = period * re_parentvecsize;
g_io.c:            x->x_fill = x->x_endbuf -
g_io.c:              (x->x_hop - prologphase * re_parentvecsize);
g_io.c:                    dsp_add(vinlet_doprolog, 3, x, insig->s_vec,
g_io.c:              int method = (x->x_updown.method == 3?
g_io.c:                (pd_compatibilitylevel < 044 ? 0 : 1) : x->x_updown.method);
g_io.c:              resamplefrom_dsp(&x->x_updown, insig->s_vec, parentvecsize,
g_io.c:              dsp_add(vinlet_doprolog, 3, x, x->x_updown.s_vec,
g_io.c:            if (!insig->s_refcount)
g_io.c:        else memset((char *)(x->x_buf), 0, bufsize * sizeof(*x->x_buf));
g_io.c:        x->x_directsignal = 0;
g_io.c:        x->x_directsignal = parentsigs[inlet_getsignalindex(x->x_inlet)];
g_io.c:    x->x_canvas = canvas_getcurrent();
g_io.c:    x->x_inlet = canvas_addinlet(x->x_canvas, &x->x_obj.ob_pd, &s_signal);
g_io.c:    x->x_endbuf = x->x_buf = (t_float *)getbytes(0);
g_io.c:    x->x_bufsize = 0;
g_io.c:    x->x_directsignal = 0;
g_io.c:    outlet_new(&x->x_obj, &s_signal);
g_io.c:    resample_init(&x->x_updown);
g_io.c:     * it might prove hard to provide consistency between labeled up- & downsampling methods
g_io.c:        x->x_updown.method=1;       /* up: sample and hold */
g_io.c:        x->x_updown.method=2;       /* up: linear interpolation */
g_io.c:        x->x_updown.method=0;       /* up: zero-padding */
g_io.c:    else x->x_updown.method=3;      /* sample/hold unless version<0.44 */
g_io.c:/* ------------------------- voutlet -------------------------- */
g_io.c:    x->x_canvas = canvas_getcurrent();
g_io.c:    x->x_parentoutlet = canvas_addoutlet(x->x_canvas, &x->x_obj.ob_pd, 0);
g_io.c:    inlet_new(&x->x_obj, &x->x_obj.ob_pd, 0, 0);
g_io.c:    x->x_bufsize = 0;
g_io.c:    x->x_buf = 0;
g_io.c:    outlet_bang(x->x_parentoutlet);
g_io.c:    outlet_pointer(x->x_parentoutlet, gp);
g_io.c:    outlet_float(x->x_parentoutlet, f);
g_io.c:    outlet_symbol(x->x_parentoutlet, s);
g_io.c:    outlet_list(x->x_parentoutlet, s, argc, argv);
g_io.c:    outlet_anything(x->x_parentoutlet, s, argc, argv);
g_io.c:    canvas_rmoutlet(x->x_canvas, x->x_parentoutlet);
g_io.c:    resample_free(&x->x_updown);
g_io.c:    return (((t_voutlet *)x)->x_parentoutlet);
g_io.c:/* ------------------------- signal outlet -------------------------- */
g_io.c:    return (x->x_buf != 0);
g_io.c:    /* LATER optimize for non-overlapped case where the "+=" isn't needed */
g_io.c:    t_sample *out = x->x_write, *outwas = out;
g_io.c:    if (tot < 5) post("-in %lx out %lx n %d", in, out, n);
g_io.c:    if (tot < 5) post("-buf %lx endbuf %lx", x->x_buf, x->x_endbuf);
g_io.c:    while (n--)
g_io.c:        if (out == x->x_endbuf) out = x->x_buf;
g_io.c:    outwas += x->x_hop;
g_io.c:    if (outwas >= x->x_endbuf) outwas = x->x_buf;
g_io.c:    x->x_write = outwas;
g_io.c:    t_sample *in = x->x_empty;
g_io.c:    if (x->x_updown.downsample != x->x_updown.upsample)
g_io.c:        out = x->x_updown.s_vec;
g_io.c:    for (; n--; in++) *out++ = *in, *in = 0;
g_io.c:    if (in == x->x_endbuf) in = x->x_buf;
g_io.c:    x->x_empty = in;
g_io.c:    t_sample *in  = x->x_empty;
g_io.c:    t_sample *out = x->x_updown.s_vec;
g_io.c:    for (; n--; in++) *out++ = *in, *in = 0;
g_io.c:    if (in == x->x_endbuf) in = x->x_buf;
g_io.c:    x->x_empty = in;
g_io.c:        /* prolog for outlets -- store pointer to the outlet on the
g_io.c:    if (!x->x_buf)
g_io.c:    x->x_updown.downsample=downsample;
g_io.c:    x->x_updown.upsample=upsample;
g_io.c:    x->x_justcopyout = (switched && !reblock);
g_io.c:        x->x_directsignal = 0;
g_io.c:        x->x_directsignal =
g_io.c:            parentsigs[outlet_getsignalindex(x->x_parentoutlet)];
g_io.c:    if (!x->x_buf) return;
g_io.c:    if (x->x_justcopyout)
g_io.c:        dsp_add_copy(insig->s_vec, x->x_directsignal->s_vec, insig->s_n);
g_io.c:    else if (x->x_directsignal)
g_io.c:        /* this is done elsewhere--> sp[0]->s_refcount++; */
g_io.c:        signal_setborrowed(x->x_directsignal, sp[0]);
g_io.c:        dsp_add(voutlet_perform, 3, x, insig->s_vec, insig->s_n);
g_io.c:    if (!x->x_buf) return;  /* this shouldn't be necesssary... */
g_io.c:    x->x_updown.downsample=downsample;
g_io.c:    x->x_updown.upsample=upsample;
g_io.c:            outsig = parentsigs[outlet_getsignalindex(x->x_parentoutlet)];
g_io.c:            parentvecsize = outsig->s_vecsize;
g_io.c:        epilogphase = phase & (bigperiod - 1);
g_io.c:        blockphase = (phase + period - 1) & (bigperiod - 1) & (- period);
g_io.c:        if (bufsize != (oldbufsize = x->x_bufsize))
g_io.c:            t_sample *buf = x->x_buf;
g_io.c:            x->x_bufsize = bufsize;
g_io.c:            x->x_endbuf = buf + bufsize;
g_io.c:            x->x_buf = buf;
g_io.c:        x->x_write = x->x_buf + re_parentvecsize * blockphase;
g_io.c:        if (x->x_write == x->x_endbuf) x->x_write = x->x_buf;
g_io.c:            x->x_hop = re_parentvecsize / frequency;
g_io.c:        else x->x_hop = period * re_parentvecsize;
g_io.c:            x->x_empty = x->x_buf + re_parentvecsize * epilogphase;
g_io.c:                dsp_add(voutlet_doepilog, 3, x, outsig->s_vec,
g_io.c:                int method = (x->x_updown.method == 3?
g_io.c:                    (pd_compatibilitylevel < 044 ? 0 : 1) : x->x_updown.method);
g_io.c:                resampleto_dsp(&x->x_updown, outsig->s_vec, re_parentvecsize,
g_io.c:                parentsigs[outlet_getsignalindex(x->x_parentoutlet)];
g_io.c:            dsp_add_zero(outsig->s_vec, outsig->s_n);
g_io.c:    x->x_canvas = canvas_getcurrent();
g_io.c:    x->x_parentoutlet = canvas_addoutlet(x->x_canvas,
g_io.c:        &x->x_obj.ob_pd, &s_signal);
g_io.c:    inlet_new(&x->x_obj, &x->x_obj.ob_pd, &s_signal, &s_signal);
g_io.c:    x->x_endbuf = x->x_buf = (t_sample *)getbytes(0);
g_io.c:    x->x_bufsize = 0;
g_io.c:    resample_init(&x->x_updown);
g_io.c:     * it might prove hard to provide consistency between labeled up- & downsampling methods
g_io.c:    if (s == gensym("hold"))x->x_updown.method=1;        /* up: sample and hold */
g_io.c:    else if (s == gensym("lin"))x->x_updown.method=2;    /* up: linear interpolation */
g_io.c:    else if (s == gensym("linear"))x->x_updown.method=2; /* up: linear interpolation */
g_io.c:    else if (s == gensym("pad"))x->x_updown.method=0;    /* up: zero pad */
g_io.c:    else x->x_updown.method=3;                           /* up: zero-padding; down: ignore samples inbetween */
g_io.c:/* ---------------------------- overall setup ----------------------------- */
g_mycanvas.c:/* Copyright (c) 1997-1999 Miller Puckette.
g_mycanvas.c:/* g_7_guis.c written by Thomas Musil (c) IEM KUG Graz Austria 2000-2001 */
g_mycanvas.c:/* ---------- cnv  my gui-canvas for a window ---------------- */
g_mycanvas.c:    int xpos=text_xpix(&x->x_gui.x_obj, glist);
g_mycanvas.c:    int ypos=text_ypix(&x->x_gui.x_obj, glist);
g_mycanvas.c:    sys_vgui(".x%lx.c create rectangle %d %d %d %d -fill #%6.6x -outline #%6.6x -tags %lxRECT\n",
g_mycanvas.c:             xpos + x->x_vis_w, ypos + x->x_vis_h,
g_mycanvas.c:             x->x_gui.x_bcol, x->x_gui.x_bcol, x);
g_mycanvas.c:    sys_vgui(".x%lx.c create rectangle %d %d %d %d -outline #%6.6x -tags %lxBASE\n",
g_mycanvas.c:             xpos + x->x_gui.x_w, ypos + x->x_gui.x_h,
g_mycanvas.c:             x->x_gui.x_bcol, x);
g_mycanvas.c:    sys_vgui(".x%lx.c create text %d %d -text {%s} -anchor w \
g_mycanvas.c:             -font {{%s} -%d %s} -fill #%6.6x -tags [list %lxLABEL label text]\n",
g_mycanvas.c:             canvas, xpos+x->x_gui.x_ldx, ypos+x->x_gui.x_ldy,
g_mycanvas.c:             strcmp(x->x_gui.x_lab->s_name, "empty")?x->x_gui.x_lab->s_name:"",
g_mycanvas.c:             x->x_gui.x_font, x->x_gui.x_fontsize, sys_fontweight,
g_mycanvas.c:             x->x_gui.x_lcol, x);
g_mycanvas.c:    int xpos=text_xpix(&x->x_gui.x_obj, glist);
g_mycanvas.c:    int ypos=text_ypix(&x->x_gui.x_obj, glist);
g_mycanvas.c:             canvas, x, xpos, ypos, xpos + x->x_vis_w,
g_mycanvas.c:             ypos + x->x_vis_h);
g_mycanvas.c:             xpos + x->x_gui.x_w, ypos + x->x_gui.x_h);
g_mycanvas.c:             canvas, x, xpos+x->x_gui.x_ldx,
g_mycanvas.c:             ypos+x->x_gui.x_ldy);
g_mycanvas.c:    sys_vgui(".x%lx.c itemconfigure %lxRECT -fill #%6.6x -outline #%6.6x\n", canvas, x,
g_mycanvas.c:             x->x_gui.x_bcol, x->x_gui.x_bcol);
g_mycanvas.c:    sys_vgui(".x%lx.c itemconfigure %lxBASE -outline #%6.6x\n", canvas, x,
g_mycanvas.c:             x->x_gui.x_fsf.x_selected?IEM_GUI_COLOR_SELECTED:x->x_gui.x_bcol);
g_mycanvas.c:    sys_vgui(".x%lx.c itemconfigure %lxLABEL -font {{%s} -%d %s} -fill #%6.6x -text {%s} \n",
g_mycanvas.c:             canvas, x, x->x_gui.x_font, x->x_gui.x_fontsize, sys_fontweight,
g_mycanvas.c:             x->x_gui.x_lcol,
g_mycanvas.c:             strcmp(x->x_gui.x_lab->s_name, "empty")?x->x_gui.x_lab->s_name:"");
g_mycanvas.c:    if(x->x_gui.x_fsf.x_selected)
g_mycanvas.c:        sys_vgui(".x%lx.c itemconfigure %lxBASE -outline #%6.6x\n", canvas, x, IEM_GUI_COLOR_SELECTED);
g_mycanvas.c:        sys_vgui(".x%lx.c itemconfigure %lxBASE -outline #%6.6x\n", canvas, x, x->x_gui.x_bcol);
g_mycanvas.c:/* ------------------------ cnv widgetbehaviour----------------------------- */
g_mycanvas.c:    *xp1 = text_xpix(&x->x_gui.x_obj, glist);
g_mycanvas.c:    *yp1 = text_ypix(&x->x_gui.x_obj, glist);
g_mycanvas.c:    *xp2 = *xp1 + x->x_gui.x_w;
g_mycanvas.c:    *yp2 = *yp1 + x->x_gui.x_h;
g_mycanvas.c:    iemgui_save(&x->x_gui, srl, bflcol);
g_mycanvas.c:                (int)x->x_gui.x_obj.te_xpix, (int)x->x_gui.x_obj.te_ypix,
g_mycanvas.c:                gensym("cnv"), x->x_gui.x_w, x->x_vis_w, x->x_vis_h,
g_mycanvas.c:                srl[0], srl[1], srl[2], x->x_gui.x_ldx, x->x_gui.x_ldy,
g_mycanvas.c:                iem_fstyletoint(&x->x_gui.x_fsf), x->x_gui.x_fontsize,
g_mycanvas.c:                bflcol[0], bflcol[2], iem_symargstoint(&x->x_gui.x_isa));
g_mycanvas.c:    iemgui_properties(&x->x_gui, srl);
g_mycanvas.c:            ------selectable_dimensions(pix):------ %d %d size: 0.0 0.0 empty \
g_mycanvas.c:            ------visible_rectangle(pix)(pix):------ %d width: %d height: %d \
g_mycanvas.c:            x->x_gui.x_w, 1,
g_mycanvas.c:            x->x_vis_w, x->x_vis_h, 0,/*no_schedule*/
g_mycanvas.c:            -1, -1, -1, -1,/*no linlog, no init, no multi*/
g_mycanvas.c:            srl[0]->s_name, srl[1]->s_name,
g_mycanvas.c:            srl[2]->s_name, x->x_gui.x_ldx, x->x_gui.x_ldy,
g_mycanvas.c:            x->x_gui.x_fsf.x_font_style, x->x_gui.x_fontsize,
g_mycanvas.c:            0xffffff & x->x_gui.x_bcol, -1/*no frontcolor*/, 0xffffff & x->x_gui.x_lcol);
g_mycanvas.c:    gfxstub_new(&x->x_gui.x_obj.ob_pd, x, buf);
g_mycanvas.c:    if(x->x_gui.x_fsf.x_snd_able && x->x_gui.x_snd->s_thing)
g_mycanvas.c:        x->x_at[0].a_w.w_float = text_xpix(&x->x_gui.x_obj, x->x_gui.x_glist);
g_mycanvas.c:        x->x_at[1].a_w.w_float = text_ypix(&x->x_gui.x_obj, x->x_gui.x_glist);
g_mycanvas.c:        pd_list(x->x_gui.x_snd->s_thing, &s_list, 2, x->x_at);
g_mycanvas.c:    int sr_flags = iemgui_dialog(&x->x_gui, srl, argc, argv);
g_mycanvas.c:    x->x_gui.x_isa.x_loadinit = 0;
g_mycanvas.c:    x->x_gui.x_w = a;
g_mycanvas.c:    x->x_gui.x_h = x->x_gui.x_w;
g_mycanvas.c:    x->x_vis_w = w;
g_mycanvas.c:    x->x_vis_h = h;
g_mycanvas.c:    (*x->x_gui.x_draw)(x, x->x_gui.x_glist, IEM_GUI_DRAW_MODE_CONFIG);
g_mycanvas.c:    (*x->x_gui.x_draw)(x, x->x_gui.x_glist, IEM_GUI_DRAW_MODE_MOVE);
g_mycanvas.c:    x->x_gui.x_w = i;
g_mycanvas.c:    x->x_gui.x_h = i;
g_mycanvas.c:    iemgui_size((void *)x, &x->x_gui);
g_mycanvas.c:{iemgui_delta((void *)x, &x->x_gui, s, ac, av);}
g_mycanvas.c:{iemgui_pos((void *)x, &x->x_gui, s, ac, av);}
g_mycanvas.c:    x->x_vis_w = i;
g_mycanvas.c:    x->x_vis_h = i;
g_mycanvas.c:    if(glist_isvisible(x->x_gui.x_glist))
g_mycanvas.c:        (*x->x_gui.x_draw)(x, x->x_gui.x_glist, IEM_GUI_DRAW_MODE_MOVE);
g_mycanvas.c:{iemgui_color((void *)x, &x->x_gui, s, ac, av);}
g_mycanvas.c:{iemgui_send(x, &x->x_gui, s);}
g_mycanvas.c:{iemgui_receive(x, &x->x_gui, s);}
g_mycanvas.c:{iemgui_label((void *)x, &x->x_gui, s);}
g_mycanvas.c:{iemgui_label_pos((void *)x, &x->x_gui, s, ac, av);}
g_mycanvas.c:{iemgui_label_font((void *)x, &x->x_gui, s, ac, av);}
g_mycanvas.c:    int bflcol[]={-233017, -1, -66577};
g_mycanvas.c:    iem_inttosymargs(&x->x_gui.x_isa, 0);
g_mycanvas.c:    iem_inttofstyle(&x->x_gui.x_fsf, 0);
g_mycanvas.c:        iemgui_new_getnames(&x->x_gui, 3, argv);
g_mycanvas.c:        iemgui_new_getnames(&x->x_gui, 3, argv);
g_mycanvas.c:    else iemgui_new_getnames(&x->x_gui, 3, 0);
g_mycanvas.c:        iemgui_new_dogetname(&x->x_gui, i+3, argv);
g_mycanvas.c:        x->x_gui.x_labelbindex = i+4;
g_mycanvas.c:        iem_inttofstyle(&x->x_gui.x_fsf, atom_getintarg(i+6, argc, argv));
g_mycanvas.c:        iem_inttosymargs(&x->x_gui.x_isa, atom_getintarg(i+10, argc, argv));
g_mycanvas.c:    x->x_gui.x_draw = (t_iemfunptr)my_canvas_draw;
g_mycanvas.c:    x->x_gui.x_fsf.x_snd_able = 1;
g_mycanvas.c:    x->x_gui.x_fsf.x_rcv_able = 1;
g_mycanvas.c:    x->x_gui.x_glist = (t_glist *)canvas_getcurrent();
g_mycanvas.c:    if (!strcmp(x->x_gui.x_snd->s_name, "empty"))
g_mycanvas.c:        x->x_gui.x_fsf.x_snd_able = 0;
g_mycanvas.c:    if (!strcmp(x->x_gui.x_rcv->s_name, "empty"))
g_mycanvas.c:        x->x_gui.x_fsf.x_rcv_able = 0;
g_mycanvas.c:    x->x_gui.x_w = a;
g_mycanvas.c:    x->x_gui.x_h = x->x_gui.x_w;
g_mycanvas.c:    x->x_vis_w = w;
g_mycanvas.c:    x->x_vis_h = h;
g_mycanvas.c:    if(x->x_gui.x_fsf.x_font_style == 1) strcpy(x->x_gui.x_font, "helvetica");
g_mycanvas.c:    else if(x->x_gui.x_fsf.x_font_style == 2) strcpy(x->x_gui.x_font, "times");
g_mycanvas.c:    else { x->x_gui.x_fsf.x_font_style = 0;
g_mycanvas.c:        strcpy(x->x_gui.x_font, sys_font); }
g_mycanvas.c:    if (x->x_gui.x_fsf.x_rcv_able)
g_mycanvas.c:        pd_bind(&x->x_gui.x_obj.ob_pd, x->x_gui.x_rcv);
g_mycanvas.c:    x->x_gui.x_ldx = ldx;
g_mycanvas.c:    x->x_gui.x_ldy = ldy;
g_mycanvas.c:    x->x_gui.x_fontsize = fs;
g_mycanvas.c:    iemgui_all_colfromload(&x->x_gui, bflcol);
g_mycanvas.c:    x->x_at[0].a_type = A_FLOAT;
g_mycanvas.c:    x->x_at[1].a_type = A_FLOAT;
g_mycanvas.c:    iemgui_verify_snd_ne_rcv(&x->x_gui);
g_mycanvas.c:    if(x->x_gui.x_fsf.x_rcv_able)
g_mycanvas.c:        pd_unbind(&x->x_gui.x_obj.ob_pd, x->x_gui.x_rcv);
g_numbox.c:/* Copyright (c) 1997-1999 Miller Puckette.
g_numbox.c:/* my_numbox.c written by Thomas Musil (c) IEM KUG Graz Austria 2000-2001 */
g_numbox.c:/*------------------ global varaibles -------------------------*/
g_numbox.c:/*------------------ global functions -------------------------*/
g_numbox.c:/* ------------ nmx gui-my number box ----------------------- */
g_numbox.c:    if(x->x_gui.x_fsf.x_change && x->x_gui.x_glist)
g_numbox.c:        x->x_gui.x_fsf.x_change = 0;
g_numbox.c:        sys_queuegui(x, x->x_gui.x_glist, my_numbox_draw_update);
g_numbox.c:    sys_queuegui(x, x->x_gui.x_glist, my_numbox_draw_update);
g_numbox.c:    if(x->x_val < x->x_min)
g_numbox.c:        x->x_val = x->x_min;
g_numbox.c:    if(x->x_val > x->x_max)
g_numbox.c:        x->x_val = x->x_max;
g_numbox.c:    if(x->x_gui.x_fsf.x_font_style == 1)
g_numbox.c:    else if(x->x_gui.x_fsf.x_font_style == 2)
g_numbox.c:    w = x->x_gui.x_fontsize * f * x->x_gui.x_w;
g_numbox.c:    x->x_numwidth = w + (x->x_gui.x_h / 2) + 4;
g_numbox.c:    double f=x->x_val;
g_numbox.c:    sprintf(x->x_buf, "%g", f);
g_numbox.c:    bufsize = strlen(x->x_buf);
g_numbox.c:        i = bufsize - 4;
g_numbox.c:        if((x->x_buf[i] == 'e') || (x->x_buf[i] == 'E'))
g_numbox.c:    if(bufsize > x->x_gui.x_w)/* if to reduce */
g_numbox.c:            if(x->x_gui.x_w <= 5)
g_numbox.c:                x->x_buf[0] = (f < 0.0 ? '-' : '+');
g_numbox.c:                x->x_buf[1] = 0;
g_numbox.c:            i = bufsize - 4;
g_numbox.c:                if(x->x_buf[idecimal] == '.')
g_numbox.c:            if(idecimal > (x->x_gui.x_w - 4))
g_numbox.c:                x->x_buf[0] = (f < 0.0 ? '-' : '+');
g_numbox.c:                x->x_buf[1] = 0;
g_numbox.c:                int new_exp_index=x->x_gui.x_w-4, old_exp_index=bufsize-4;
g_numbox.c:                    x->x_buf[new_exp_index] = x->x_buf[old_exp_index];
g_numbox.c:                x->x_buf[x->x_gui.x_w] = 0;
g_numbox.c:                if(x->x_buf[idecimal] == '.')
g_numbox.c:            if(idecimal > x->x_gui.x_w)
g_numbox.c:                x->x_buf[0] = (f < 0.0 ? '-' : '+');
g_numbox.c:                x->x_buf[1] = 0;
g_numbox.c:                x->x_buf[x->x_gui.x_w] = 0;
g_numbox.c:        if(x->x_gui.x_fsf.x_change)
g_numbox.c:            if(x->x_buf[0])
g_numbox.c:                char *cp=x->x_buf;
g_numbox.c:                int sl = strlen(x->x_buf);
g_numbox.c:                x->x_buf[sl] = '>';
g_numbox.c:                x->x_buf[sl+1] = 0;
g_numbox.c:                if(sl >= x->x_gui.x_w)
g_numbox.c:                    cp += sl - x->x_gui.x_w + 1;
g_numbox.c:                    ".x%lx.c itemconfigure %lxNUMBER -fill #%6.6x -text {%s} \n",
g_numbox.c:                x->x_buf[sl] = 0;
g_numbox.c:                    ".x%lx.c itemconfigure %lxNUMBER -fill #%6.6x -text {%s} \n",
g_numbox.c:                    glist_getcanvas(glist), x, IEM_GUI_COLOR_EDITED, x->x_buf);
g_numbox.c:                x->x_buf[0] = 0;
g_numbox.c:                ".x%lx.c itemconfigure %lxNUMBER -fill #%6.6x -text {%s} \n",
g_numbox.c:                x->x_gui.x_fsf.x_selected?
g_numbox.c:                    IEM_GUI_COLOR_SELECTED:x->x_gui.x_fcol,
g_numbox.c:                x->x_buf);
g_numbox.c:            x->x_buf[0] = 0;
g_numbox.c:    int half=x->x_gui.x_h/2, d=1+x->x_gui.x_h/34;
g_numbox.c:    int xpos=text_xpix(&x->x_gui.x_obj, glist);
g_numbox.c:    int ypos=text_ypix(&x->x_gui.x_obj, glist);
g_numbox.c:".x%lx.c create polygon %d %d %d %d %d %d %d %d %d %d -outline #%6.6x \
g_numbox.c:-fill #%6.6x -tags %lxBASE1\n",
g_numbox.c:             xpos + x->x_numwidth-4, ypos,
g_numbox.c:             xpos + x->x_numwidth, ypos+4,
g_numbox.c:             xpos + x->x_numwidth, ypos + x->x_gui.x_h,
g_numbox.c:             xpos, ypos + x->x_gui.x_h,
g_numbox.c:             IEM_GUI_COLOR_NORMAL, x->x_gui.x_bcol, x);
g_numbox.c:        ".x%lx.c create line %d %d %d %d %d %d -fill #%6.6x -tags %lxBASE2\n",
g_numbox.c:        xpos, ypos + x->x_gui.x_h,
g_numbox.c:        x->x_gui.x_fcol, x);
g_numbox.c:    sys_vgui(".x%lx.c create text %d %d -text {%s} -anchor w \
g_numbox.c:        -font {{%s} -%d %s} -fill #%6.6x -tags [list %lxLABEL label text]\n",
g_numbox.c:        canvas, xpos+x->x_gui.x_ldx, ypos+x->x_gui.x_ldy,
g_numbox.c:        strcmp(x->x_gui.x_lab->s_name, "empty")?x->x_gui.x_lab->s_name:"",
g_numbox.c:        x->x_gui.x_font, x->x_gui.x_fontsize, sys_fontweight,
g_numbox.c:             x->x_gui.x_lcol, x);
g_numbox.c:    sys_vgui(".x%lx.c create text %d %d -text {%s} -anchor w \
g_numbox.c:        -font {{%s} -%d %s} -fill #%6.6x -tags %lxNUMBER\n",
g_numbox.c:        x->x_buf, x->x_gui.x_font, x->x_gui.x_fontsize, sys_fontweight,
g_numbox.c:        x->x_gui.x_fcol, x);
g_numbox.c:    if(!x->x_gui.x_fsf.x_snd_able)
g_numbox.c:        sys_vgui(".x%lx.c create rectangle %d %d %d %d -tags [list %lxOUT%d outlet]\n",
g_numbox.c:             xpos, ypos + x->x_gui.x_h-1,
g_numbox.c:             xpos+IOWIDTH, ypos + x->x_gui.x_h,
g_numbox.c:    if(!x->x_gui.x_fsf.x_rcv_able)
g_numbox.c:        sys_vgui(".x%lx.c create rectangle %d %d %d %d -tags [list %lxIN%d inlet]\n",
g_numbox.c:    int half = x->x_gui.x_h/2, d=1+x->x_gui.x_h/34;
g_numbox.c:    int xpos=text_xpix(&x->x_gui.x_obj, glist);
g_numbox.c:    int ypos=text_ypix(&x->x_gui.x_obj, glist);
g_numbox.c:             xpos + x->x_numwidth-4, ypos,
g_numbox.c:             xpos + x->x_numwidth, ypos+4,
g_numbox.c:             xpos + x->x_numwidth, ypos + x->x_gui.x_h,
g_numbox.c:             xpos, ypos + x->x_gui.x_h);
g_numbox.c:             xpos, ypos + x->x_gui.x_h);
g_numbox.c:             canvas, x, xpos+x->x_gui.x_ldx, ypos+x->x_gui.x_ldy);
g_numbox.c:   if(!x->x_gui.x_fsf.x_snd_able)
g_numbox.c:             xpos, ypos + x->x_gui.x_h-1,
g_numbox.c:             xpos+IOWIDTH, ypos + x->x_gui.x_h);
g_numbox.c:   if(!x->x_gui.x_fsf.x_rcv_able)
g_numbox.c:    if(!x->x_gui.x_fsf.x_snd_able)
g_numbox.c:    if(!x->x_gui.x_fsf.x_rcv_able)
g_numbox.c:    sys_vgui(".x%lx.c itemconfigure %lxLABEL -font {{%s} -%d %s} -fill #%6.6x -text {%s} \n",
g_numbox.c:             canvas, x, x->x_gui.x_font, x->x_gui.x_fontsize, sys_fontweight,
g_numbox.c:             x->x_gui.x_fsf.x_selected?IEM_GUI_COLOR_SELECTED:x->x_gui.x_lcol,
g_numbox.c:             strcmp(x->x_gui.x_lab->s_name, "empty")?x->x_gui.x_lab->s_name:"");
g_numbox.c:    sys_vgui(".x%lx.c itemconfigure %lxNUMBER -font {{%s} -%d %s} -fill #%6.6x \n",
g_numbox.c:             canvas, x, x->x_gui.x_font, x->x_gui.x_fontsize, sys_fontweight,
g_numbox.c:             x->x_gui.x_fsf.x_selected?IEM_GUI_COLOR_SELECTED:x->x_gui.x_fcol);
g_numbox.c:    sys_vgui(".x%lx.c itemconfigure %lxBASE1 -fill #%6.6x\n", canvas,
g_numbox.c:             x, x->x_gui.x_bcol);
g_numbox.c:    sys_vgui(".x%lx.c itemconfigure %lxBASE2 -fill #%6.6x\n", canvas,
g_numbox.c:             x, x->x_gui.x_fsf.x_selected?IEM_GUI_COLOR_SELECTED:x->x_gui.x_fcol);
g_numbox.c:    int xpos=text_xpix(&x->x_gui.x_obj, glist);
g_numbox.c:    int ypos=text_ypix(&x->x_gui.x_obj, glist);
g_numbox.c:    if((old_snd_rcv_flags & IEM_GUI_OLD_SND_FLAG) && !x->x_gui.x_fsf.x_snd_able)
g_numbox.c:        sys_vgui(".x%lx.c create rectangle %d %d %d %d -tags %lxOUT%d\n",
g_numbox.c:             xpos, ypos + x->x_gui.x_h-1,
g_numbox.c:             xpos+IOWIDTH, ypos + x->x_gui.x_h,
g_numbox.c:    if(!(old_snd_rcv_flags & IEM_GUI_OLD_SND_FLAG) && x->x_gui.x_fsf.x_snd_able)
g_numbox.c:    if((old_snd_rcv_flags & IEM_GUI_OLD_RCV_FLAG) && !x->x_gui.x_fsf.x_rcv_able)
g_numbox.c:        sys_vgui(".x%lx.c create rectangle %d %d %d %d -tags %lxIN%d\n",
g_numbox.c:    if(!(old_snd_rcv_flags & IEM_GUI_OLD_RCV_FLAG) && x->x_gui.x_fsf.x_rcv_able)
g_numbox.c:    if(x->x_gui.x_fsf.x_selected)
g_numbox.c:        if(x->x_gui.x_fsf.x_change)
g_numbox.c:            x->x_gui.x_fsf.x_change = 0;
g_numbox.c:            clock_unset(x->x_clock_reset);
g_numbox.c:            x->x_buf[0] = 0;
g_numbox.c:            sys_queuegui(x, x->x_gui.x_glist, my_numbox_draw_update);
g_numbox.c:        sys_vgui(".x%lx.c itemconfigure %lxBASE1 -outline #%6.6x\n",
g_numbox.c:        sys_vgui(".x%lx.c itemconfigure %lxBASE2 -fill #%6.6x\n",
g_numbox.c:        sys_vgui(".x%lx.c itemconfigure %lxLABEL -fill #%6.6x\n",
g_numbox.c:        sys_vgui(".x%lx.c itemconfigure %lxNUMBER -fill #%6.6x\n",
g_numbox.c:        sys_vgui(".x%lx.c itemconfigure %lxBASE1 -outline #%6.6x\n",
g_numbox.c:        sys_vgui(".x%lx.c itemconfigure %lxBASE2 -fill #%6.6x\n",
g_numbox.c:            canvas, x, x->x_gui.x_fcol);
g_numbox.c:        sys_vgui(".x%lx.c itemconfigure %lxLABEL -fill #%6.6x\n",
g_numbox.c:            canvas, x, x->x_gui.x_lcol);
g_numbox.c:        sys_vgui(".x%lx.c itemconfigure %lxNUMBER -fill #%6.6x\n",
g_numbox.c:            canvas, x, x->x_gui.x_fcol);
g_numbox.c:        my_numbox_draw_io(x, glist, mode - IEM_GUI_DRAW_MODE_IO);
g_numbox.c:/* ------------------------ nbx widgetbehaviour----------------------------- */
g_numbox.c:    *xp1 = text_xpix(&x->x_gui.x_obj, glist);
g_numbox.c:    *yp1 = text_ypix(&x->x_gui.x_obj, glist);
g_numbox.c:    *xp2 = *xp1 + x->x_numwidth;
g_numbox.c:    *yp2 = *yp1 + x->x_gui.x_h;
g_numbox.c:    iemgui_save(&x->x_gui, srl, bflcol);
g_numbox.c:    if(x->x_gui.x_fsf.x_change)
g_numbox.c:        x->x_gui.x_fsf.x_change = 0;
g_numbox.c:        clock_unset(x->x_clock_reset);
g_numbox.c:        sys_queuegui(x, x->x_gui.x_glist, my_numbox_draw_update);
g_numbox.c:                (int)x->x_gui.x_obj.te_xpix, (int)x->x_gui.x_obj.te_ypix,
g_numbox.c:                gensym("nbx"), x->x_gui.x_w, x->x_gui.x_h,
g_numbox.c:                (t_float)x->x_min, (t_float)x->x_max,
g_numbox.c:                x->x_lin0_log1, iem_symargstoint(&x->x_gui.x_isa),
g_numbox.c:                x->x_gui.x_ldx, x->x_gui.x_ldy,
g_numbox.c:                iem_fstyletoint(&x->x_gui.x_fsf), x->x_gui.x_fontsize,
g_numbox.c:                x->x_val, x->x_log_height);
g_numbox.c:    if(x->x_lin0_log1)
g_numbox.c:    x->x_min = min;
g_numbox.c:    x->x_max = max;
g_numbox.c:    if(x->x_val < x->x_min)
g_numbox.c:        x->x_val = x->x_min;
g_numbox.c:    if(x->x_val > x->x_max)
g_numbox.c:        x->x_val = x->x_max;
g_numbox.c:    if(x->x_lin0_log1)
g_numbox.c:        x->x_k = exp(log(x->x_max/x->x_min)/(double)(x->x_log_height));
g_numbox.c:        x->x_k = 1.0;
g_numbox.c:    iemgui_properties(&x->x_gui, srl);
g_numbox.c:    if(x->x_gui.x_fsf.x_change)
g_numbox.c:        x->x_gui.x_fsf.x_change = 0;
g_numbox.c:        clock_unset(x->x_clock_reset);
g_numbox.c:        sys_queuegui(x, x->x_gui.x_glist, my_numbox_draw_update);
g_numbox.c:            -------dimensions(digits)(pix):------- %d %d width: %d %d height: \
g_numbox.c:            -----------output-range:----------- %g min: %g max: %d \
g_numbox.c:            %d lin log %d %d log-height: %d \
g_numbox.c:            x->x_gui.x_w, 1, x->x_gui.x_h, 8,
g_numbox.c:            x->x_min, x->x_max, 0,/*no_schedule*/
g_numbox.c:            x->x_lin0_log1, x->x_gui.x_isa.x_loadinit, -1,
g_numbox.c:                x->x_log_height, /*no multi, but iem-characteristic*/
g_numbox.c:            srl[0]->s_name, srl[1]->s_name,
g_numbox.c:            srl[2]->s_name, x->x_gui.x_ldx, x->x_gui.x_ldy,
g_numbox.c:            x->x_gui.x_fsf.x_font_style, x->x_gui.x_fontsize,
g_numbox.c:            0xffffff & x->x_gui.x_bcol, 0xffffff & x->x_gui.x_fcol,
g_numbox.c:                0xffffff & x->x_gui.x_lcol);
g_numbox.c:    gfxstub_new(&x->x_gui.x_obj.ob_pd, x, buf);
g_numbox.c:    outlet_float(x->x_gui.x_obj.ob_outlet, x->x_val);
g_numbox.c:    if(x->x_gui.x_fsf.x_snd_able && x->x_gui.x_snd->s_thing)
g_numbox.c:        pd_float(x->x_gui.x_snd->s_thing, x->x_val);
g_numbox.c:    x->x_lin0_log1 = lilo;
g_numbox.c:    sr_flags = iemgui_dialog(&x->x_gui, srl, argc, argv);
g_numbox.c:    x->x_gui.x_w = w;
g_numbox.c:    x->x_gui.x_h = h;
g_numbox.c:    x->x_log_height = log_height;
g_numbox.c:    (*x->x_gui.x_draw)(x, x->x_gui.x_glist, IEM_GUI_DRAW_MODE_UPDATE);
g_numbox.c:    (*x->x_gui.x_draw)(x, x->x_gui.x_glist, IEM_GUI_DRAW_MODE_IO + sr_flags);
g_numbox.c:    (*x->x_gui.x_draw)(x, x->x_gui.x_glist, IEM_GUI_DRAW_MODE_CONFIG);
g_numbox.c:    (*x->x_gui.x_draw)(x, x->x_gui.x_glist, IEM_GUI_DRAW_MODE_MOVE);
g_numbox.c:    canvas_fixlinesfor(x->x_gui.x_glist, (t_text*)x);
g_numbox.c:    if(x->x_gui.x_fsf.x_finemoved)
g_numbox.c:    if(x->x_lin0_log1)
g_numbox.c:        x->x_val *= pow(x->x_k, -k2*dy);
g_numbox.c:        x->x_val -= k2*dy;
g_numbox.c:    sys_queuegui(x, x->x_gui.x_glist, my_numbox_draw_update);
g_numbox.c:    clock_unset(x->x_clock_reset);
g_numbox.c:    glist_grab(x->x_gui.x_glist, &x->x_gui.x_obj.te_g,
g_numbox.c:            x->x_gui.x_fsf.x_finemoved = 1;
g_numbox.c:            x->x_gui.x_fsf.x_finemoved = 0;
g_numbox.c:        if(!x->x_gui.x_fsf.x_change)
g_numbox.c:            clock_delay(x->x_clock_wait, 50);
g_numbox.c:            x->x_gui.x_fsf.x_change = 1;
g_numbox.c:            clock_delay(x->x_clock_reset, 3000);
g_numbox.c:            x->x_buf[0] = 0;
g_numbox.c:            x->x_gui.x_fsf.x_change = 0;
g_numbox.c:            clock_unset(x->x_clock_reset);
g_numbox.c:            x->x_buf[0] = 0;
g_numbox.c:            sys_queuegui(x, x->x_gui.x_glist, my_numbox_draw_update);
g_numbox.c:    if(x->x_val != f)
g_numbox.c:        x->x_val = f;
g_numbox.c:        sys_queuegui(x, x->x_gui.x_glist, my_numbox_draw_update);
g_numbox.c:    x->x_log_height = (int)lh;
g_numbox.c:    if(x->x_lin0_log1)
g_numbox.c:        x->x_k = exp(log(x->x_max/x->x_min)/(double)(x->x_log_height));
g_numbox.c:        x->x_k = 1.0;
g_numbox.c:    if(x->x_gui.x_fsf.x_put_in2out)
g_numbox.c:    x->x_gui.x_w = w;
g_numbox.c:        x->x_gui.x_h = h;
g_numbox.c:    iemgui_size((void *)x, &x->x_gui);
g_numbox.c:{iemgui_delta((void *)x, &x->x_gui, s, ac, av);}
g_numbox.c:{iemgui_pos((void *)x, &x->x_gui, s, ac, av);}
g_numbox.c:        sys_queuegui(x, x->x_gui.x_glist, my_numbox_draw_update);
g_numbox.c:{iemgui_color((void *)x, &x->x_gui, s, ac, av);}
g_numbox.c:{iemgui_send(x, &x->x_gui, s);}
g_numbox.c:{iemgui_receive(x, &x->x_gui, s);}
g_numbox.c:{iemgui_label((void *)x, &x->x_gui, s);}
g_numbox.c:{iemgui_label_pos((void *)x, &x->x_gui, s, ac, av);}
g_numbox.c:    x->x_gui.x_fontsize = f;
g_numbox.c:    x->x_gui.x_fsf.x_font_style = f;
g_numbox.c:    iemgui_label_font((void *)x, &x->x_gui, s, ac, av);
g_numbox.c:    x->x_lin0_log1 = 1;
g_numbox.c:    if(my_numbox_check_minmax(x, x->x_min, x->x_max))
g_numbox.c:        sys_queuegui(x, x->x_gui.x_glist, my_numbox_draw_update);
g_numbox.c:    x->x_lin0_log1 = 0;
g_numbox.c:    x->x_gui.x_isa.x_loadinit = (f==0.0)?0:1;
g_numbox.c:    if(!sys_noloadbang && x->x_gui.x_isa.x_loadinit)
g_numbox.c:        sys_queuegui(x, x->x_gui.x_glist, my_numbox_draw_update);
g_numbox.c:        x->x_gui.x_fsf.x_change = 0;
g_numbox.c:        clock_unset(x->x_clock_reset);
g_numbox.c:        sys_queuegui(x, x->x_gui.x_glist, my_numbox_draw_update);
g_numbox.c:    if(((c>='0')&&(c<='9'))||(c=='.')||(c=='-')||
g_numbox.c:        if(strlen(x->x_buf) < (IEMGUI_MAX_NUM_LEN-2))
g_numbox.c:            strcat(x->x_buf, buf);
g_numbox.c:            sys_queuegui(x, x->x_gui.x_glist, my_numbox_draw_update);
g_numbox.c:        int sl=strlen(x->x_buf)-1;
g_numbox.c:        x->x_buf[sl] = 0;
g_numbox.c:        sys_queuegui(x, x->x_gui.x_glist, my_numbox_draw_update);
g_numbox.c:        x->x_val = atof(x->x_buf);
g_numbox.c:        x->x_buf[0] = 0;
g_numbox.c:        x->x_gui.x_fsf.x_change = 0;
g_numbox.c:        clock_unset(x->x_clock_reset);
g_numbox.c:        sys_queuegui(x, x->x_gui.x_glist, my_numbox_draw_update);
g_numbox.c:    clock_delay(x->x_clock_reset, 3000);
g_numbox.c:    int bflcol[]={-262144, -1, -1};
g_numbox.c:    int lilo=0, f=0, ldx=0, ldy=-8;
g_numbox.c:    double min=-1.0e+37, max=1.0e+37,v=0.0;
g_numbox.c:        iem_inttosymargs(&x->x_gui.x_isa, atom_getintarg(5, argc, argv));
g_numbox.c:        iemgui_new_getnames(&x->x_gui, 6, argv);
g_numbox.c:        iem_inttofstyle(&x->x_gui.x_fsf, atom_getintarg(11, argc, argv));
g_numbox.c:    else iemgui_new_getnames(&x->x_gui, 6, 0);
g_numbox.c:    x->x_gui.x_draw = (t_iemfunptr)my_numbox_draw;
g_numbox.c:    x->x_gui.x_fsf.x_snd_able = 1;
g_numbox.c:    x->x_gui.x_fsf.x_rcv_able = 1;
g_numbox.c:    x->x_gui.x_glist = (t_glist *)canvas_getcurrent();
g_numbox.c:    if(x->x_gui.x_isa.x_loadinit)
g_numbox.c:        x->x_val = v;
g_numbox.c:        x->x_val = 0.0;
g_numbox.c:    x->x_lin0_log1 = lilo;
g_numbox.c:    x->x_log_height = log_height;
g_numbox.c:    if (!strcmp(x->x_gui.x_snd->s_name, "empty"))
g_numbox.c:        x->x_gui.x_fsf.x_snd_able = 0;
g_numbox.c:    if (!strcmp(x->x_gui.x_rcv->s_name, "empty"))
g_numbox.c:        x->x_gui.x_fsf.x_rcv_able = 0;
g_numbox.c:    if(x->x_gui.x_fsf.x_font_style == 1) strcpy(x->x_gui.x_font, "helvetica");
g_numbox.c:    else if(x->x_gui.x_fsf.x_font_style == 2) strcpy(x->x_gui.x_font, "times");
g_numbox.c:    else { x->x_gui.x_fsf.x_font_style = 0;
g_numbox.c:        strcpy(x->x_gui.x_font, sys_font); }
g_numbox.c:    if (x->x_gui.x_fsf.x_rcv_able)
g_numbox.c:        pd_bind(&x->x_gui.x_obj.ob_pd, x->x_gui.x_rcv);
g_numbox.c:    x->x_gui.x_ldx = ldx;
g_numbox.c:    x->x_gui.x_ldy = ldy;
g_numbox.c:    x->x_gui.x_fontsize = fs;
g_numbox.c:    x->x_gui.x_w = w;
g_numbox.c:    x->x_gui.x_h = h;
g_numbox.c:    x->x_buf[0] = 0;
g_numbox.c:    iemgui_all_colfromload(&x->x_gui, bflcol);
g_numbox.c:    iemgui_verify_snd_ne_rcv(&x->x_gui);
g_numbox.c:    x->x_clock_reset = clock_new(x, (t_method)my_numbox_tick_reset);
g_numbox.c:    x->x_clock_wait = clock_new(x, (t_method)my_numbox_tick_wait);
g_numbox.c:    x->x_gui.x_fsf.x_change = 0;
g_numbox.c:    outlet_new(&x->x_gui.x_obj, &s_float);
g_numbox.c:    if(x->x_gui.x_fsf.x_rcv_able)
g_numbox.c:        pd_unbind(&x->x_gui.x_obj.ob_pd, x->x_gui.x_rcv);
g_numbox.c:    clock_free(x->x_clock_reset);
g_numbox.c:    clock_free(x->x_clock_wait);
g_readwrite.c:/* Copyright (c) 1997-2002 Miller Puckette and others.
g_readwrite.c:    return (i - indexwas);
g_readwrite.c:        error("%s: no such template", templatesym->s_name);
g_readwrite.c:    n = template->t_n;
g_readwrite.c:        if (template->t_vec[i].ds_type == DT_ARRAY)
g_readwrite.c:            int elemsize = a->a_elemsize, nitems = 0;
g_readwrite.c:            t_symbol *arraytemplatesym = template->t_vec[i].ds_arraytemplate;
g_readwrite.c:                error("%s: no such template", arraytemplatesym->s_name);
g_readwrite.c:                element = (t_word *)(((char *)a->a_vec) +
g_readwrite.c:        else if (template->t_vec[i].ds_type == DT_LIST)
g_readwrite.c:                if (!glist_readscalar(w->w_list, natoms, vec,
g_readwrite.c:        error("canvas_read: %s: no such template", templatesym->s_name);
g_readwrite.c:        error("couldn't create scalar \"%s\"", templatesym->s_name);
g_readwrite.c:        glist_getcanvas(x)->gl_mapped = 0;
g_readwrite.c:    glist_add(x, &sc->sc_gobj);
g_readwrite.c:    glist_readatoms(x, natoms, vec, p_nextmsg, templatesym, sc->sc_vec, 
g_readwrite.c:        glist_getcanvas(x)->gl_mapped = 1;
g_readwrite.c:        gobj_vis(&sc->sc_gobj, x, 1);
g_readwrite.c:        glist_select(x, &sc->sc_gobj);
g_readwrite.c:        strcmp(vec[message].a_w.w_symbol->s_name, "data"))
g_readwrite.c:            strcmp(vec[message].a_w.w_symbol->s_name, "template") ||
g_readwrite.c:                templatesym->s_name);
g_readwrite.c:                templatesym->s_name);
g_readwrite.c:    if (!strcmp(format->s_name, "cr"))
g_readwrite.c:    else if (*format->s_name)
g_readwrite.c:        error("qlist_read: unknown flag: %s", format->s_name);
g_readwrite.c:    if (binbuf_read_via_canvas(b, filename->s_name, canvas, cr))
g_readwrite.c:    glist_readfrombinbuf(x, b, filename->s_name, 0);
g_readwrite.c:    for (y = x->gl_list, ntotal = 0, scindex = -1; y; y = y->g_next)
g_readwrite.c:        if (y == &sc->sc_gobj)
g_readwrite.c:    if (scindex == -1)
g_readwrite.c:            for (y = x->gl_list, nnew = 1; y2 = y->g_next;
g_readwrite.c:                y->g_next = y2->g_next;
g_readwrite.c:        else newone = x->gl_list, x->gl_list = newone->g_next;
g_readwrite.c:            for (y = x->gl_list, nnew = 1; y;
g_readwrite.c:                y = y->g_next, nnew++)
g_readwrite.c:                    if (nnew == scindex || !y->g_next)
g_readwrite.c:                newone->g_next = y->g_next;
g_readwrite.c:                y->g_next = newone;
g_readwrite.c:        else newone->g_next = x->gl_list, x->gl_list = newone;
g_readwrite.c:    /* ----------- routines to write data to a binbuf ----------- */
g_readwrite.c:    int i, n = template->t_n, natom = 0;
g_readwrite.c:        SETSYMBOL(&templatename, gensym(templatesym->s_name + 3));
g_readwrite.c:        if (template->t_vec[i].ds_type == DT_FLOAT ||
g_readwrite.c:            template->t_vec[i].ds_type == DT_SYMBOL)
g_readwrite.c:            if (template->t_vec[i].ds_type == DT_FLOAT)
g_readwrite.c:        if (template->t_vec[i].ds_type == DT_ARRAY)
g_readwrite.c:            int elemsize = a->a_elemsize, nitems = a->a_n;
g_readwrite.c:            t_symbol *arraytemplatesym = template->t_vec[i].ds_arraytemplate;
g_readwrite.c:                    (t_word *)(((char *)a->a_vec) + elemsize * j), b, 1);
g_readwrite.c:        else if (template->t_vec[i].ds_type == DT_LIST)
g_readwrite.c:            glist_writelist(w->w_list->gl_list, b);
g_readwrite.c:    for (; y; y = y->g_next)
g_readwrite.c:        if (pd_class(&y->g_pd) == scalar_class)
g_readwrite.c:            canvas_writescalar(((t_scalar *)y)->sc_template,
g_readwrite.c:                ((t_scalar *)y)->sc_vec, b, 0);
g_readwrite.c:    /* ------------ routines to write out templates for data ------- */
g_readwrite.c:    else for (ds = template->t_vec, i = template->t_n; i--; ds++, w++)
g_readwrite.c:        if (ds->ds_type == DT_ARRAY)
g_readwrite.c:            t_array *a = w->w_array;
g_readwrite.c:            int elemsize = a->a_elemsize, nitems = a->a_n;
g_readwrite.c:            t_symbol *arraytemplatesym = ds->ds_arraytemplate;
g_readwrite.c:                    (t_word *)(((char *)a->a_vec) + elemsize * j), 
g_readwrite.c:        else if (ds->ds_type == DT_LIST)
g_readwrite.c:            canvas_addtemplatesforlist(w->w_list->gl_list,
g_readwrite.c:    for (; y; y = y->g_next)
g_readwrite.c:        if (pd_class(&y->g_pd) == scalar_class)
g_readwrite.c:            canvas_addtemplatesforscalar(((t_scalar *)y)->sc_template,
g_readwrite.c:                ((t_scalar *)y)->sc_vec, p_ntemplates, p_templatevec);
g_readwrite.c:    for (y = x->gl_list; y; y = y->g_next)
g_readwrite.c:        if ((pd_class(&y->g_pd) == scalar_class) &&
g_readwrite.c:            canvas_addtemplatesforscalar(((t_scalar *)y)->sc_template,
g_readwrite.c:                ((t_scalar *)y)->sc_vec,  &ntemplates, &templatevec);
g_readwrite.c:        int j, m = template->t_n;
g_readwrite.c:            /* drop "pd-" prefix from template symbol to print it: */
g_readwrite.c:            gensym(templatevec[i]->s_name + 3));
g_readwrite.c:            switch (template->t_vec[j].ds_type)
g_readwrite.c:            if (template->t_vec[j].ds_type == DT_ARRAY)
g_readwrite.c:                binbuf_addv(b, "sss;", type, template->t_vec[j].ds_name,
g_readwrite.c:                    gensym(template->t_vec[j].ds_arraytemplate->s_name + 3));
g_readwrite.c:            else binbuf_addv(b, "ss;", type, template->t_vec[j].ds_name);
g_readwrite.c:    for (y = x->gl_list; y; y = y->g_next)
g_readwrite.c:        if ((pd_class(&y->g_pd) == scalar_class) &&
g_readwrite.c:            canvas_writescalar(((t_scalar *)y)->sc_template,
g_readwrite.c:                ((t_scalar *)y)->sc_vec,  b, 0);
g_readwrite.c:    canvas_makefilename(canvas, filename->s_name, buf, MAXPDSTRING);
g_readwrite.c:    if (!strcmp(format->s_name, "cr"))
g_readwrite.c:    else if (*format->s_name)
g_readwrite.c:        error("qlist_read: unknown flag: %s", format->s_name);
g_readwrite.c:            error("%s: write failed", filename->s_name);
g_readwrite.c:/* ------ routines to save and restore canvases (patches) recursively. ----*/
g_readwrite.c:    if (x->gl_owner && !x->gl_env)
g_readwrite.c:        binbuf_addbinbuf(bz, x->gl_obj.ob_binbuf);
g_readwrite.c:            (int)(x->gl_screenx1),
g_readwrite.c:            (int)(x->gl_screeny1),
g_readwrite.c:            (int)(x->gl_screenx2 - x->gl_screenx1),
g_readwrite.c:            (int)(x->gl_screeny2 - x->gl_screeny1),
g_readwrite.c:            x->gl_mapped);
g_readwrite.c:            (int)(x->gl_screenx1),
g_readwrite.c:            (int)(x->gl_screeny1),
g_readwrite.c:            (int)(x->gl_screenx2 - x->gl_screenx1),
g_readwrite.c:            (int)(x->gl_screeny2 - x->gl_screeny1),
g_readwrite.c:                (int)x->gl_font);
g_readwrite.c:    for (y = x->gl_list; y; y = y->g_next)
g_readwrite.c:        int srcno = canvas_getindex(x, &t.tr_ob->ob_g);
g_readwrite.c:        int sinkno = canvas_getindex(x, &t.tr_ob2->ob_g);
g_readwrite.c:    if (x->gl_isgraph || x->gl_x1 || x->gl_y1 ||
g_readwrite.c:        x->gl_x2 != 1 ||  x->gl_y2 != 1 || x->gl_pixwidth || x->gl_pixheight)
g_readwrite.c:        if (x->gl_isgraph && x->gl_goprect)
g_readwrite.c:                /* if we have a graph-on-parent rectangle, we're new style.
g_readwrite.c:                x->gl_x1, x->gl_y1,
g_readwrite.c:                x->gl_x2, x->gl_y2,
g_readwrite.c:                (t_float)x->gl_pixwidth, (t_float)x->gl_pixheight,
g_readwrite.c:                (t_float)((x->gl_hidetext)?2.:1.),
g_readwrite.c:                (t_float)x->gl_xmargin, (t_float)x->gl_ymargin); 
g_readwrite.c:                    /* otherwise write in 0.38-compatible form */
g_readwrite.c:                x->gl_x1, x->gl_y1,
g_readwrite.c:                x->gl_x2, x->gl_y2,
g_readwrite.c:                (t_float)x->gl_pixwidth, (t_float)x->gl_pixheight,
g_readwrite.c:                (t_float)x->gl_isgraph);
g_readwrite.c:    for (y = x->gl_list; y; y = y->g_next)
g_readwrite.c:        if ((pd_class(&y->g_pd) == scalar_class) &&
g_readwrite.c:                canvas_addtemplatesforscalar(((t_scalar *)y)->sc_template,
g_readwrite.c:                    ((t_scalar *)y)->sc_vec,  ntemplatesp, templatevecp);
g_readwrite.c:        else if ((pd_class(&y->g_pd) == canvas_class) &&
g_readwrite.c:        int j, m = template->t_n;
g_readwrite.c:            /* drop "pd-" prefix from template symbol to print */
g_readwrite.c:            gensym(templatevec[i]->s_name + 3));
g_readwrite.c:            switch (template->t_vec[j].ds_type)
g_readwrite.c:            if (template->t_vec[j].ds_type == DT_ARRAY)
g_readwrite.c:                binbuf_addv(b, "sss", type, template->t_vec[j].ds_name,
g_readwrite.c:                    gensym(template->t_vec[j].ds_arraytemplate->s_name + 3));
g_readwrite.c:            else binbuf_addv(b, "ss", type, template->t_vec[j].ds_name);
g_readwrite.c:    if (binbuf_write(b, filename->s_name, dir->s_name, 0)) sys_ouch();
g_readwrite.c:        if (!x->gl_owner)
g_readwrite.c:        post("saved to: %s/%s", dir->s_name, filename->s_name);
g_readwrite.c:        canvas_reload(filename, dir, &x->gl_gobj);
g_readwrite.c:        x2->gl_name->s_name, canvas_getdir(x2)->s_name);
g_readwrite.c:    char *name = x2->gl_name->s_name;
g_readwrite.c:            && (strlen(name) < 4 || strcmp(name + strlen(name)-4, ".pat")
g_readwrite.c:                || strcmp(name + strlen(name)-4, ".mxt")))
g_readwrite.c:            canvas_savetofile(x2, x2->gl_name, canvas_getdir(x2));
g_readwrite.c:/* ------------------ from the menu ------------------------- */
g_rtext.c:/* Copyright (c) 1997-1999 Miller Puckette.
g_rtext.c:/* have to insert gui-objects into editor-list */
g_rtext.c:    char *x_buf;    /*-- raw byte string, assumed UTF-8 encoded (moo) --*/
g_rtext.c:    int x_bufsize;  /*-- byte length --*/
g_rtext.c:    int x_selstart; /*-- byte offset --*/
g_rtext.c:    int x_selend;   /*-- byte offset --*/
g_rtext.c:    x->x_height = -1;
g_rtext.c:    x->x_text = who;
g_rtext.c:    x->x_glist = glist;
g_rtext.c:    x->x_next = glist->gl_editor->e_rtext;
g_rtext.c:    x->x_selstart = x->x_selend = x->x_active =
g_rtext.c:        x->x_drawnwidth = x->x_drawnheight = 0;
g_rtext.c:    binbuf_gettext(who->te_binbuf, &x->x_buf, &x->x_bufsize);
g_rtext.c:    glist->gl_editor->e_rtext = x;
g_rtext.c:    sprintf(x->x_tag, ".x%lx.t%lx", (t_int)glist_getcanvas(x->x_glist),
g_rtext.c:    if (x->x_glist->gl_editor->e_textedfor == x)
g_rtext.c:        x->x_glist->gl_editor->e_textedfor = 0;
g_rtext.c:    if (x->x_glist->gl_editor->e_rtext == x)
g_rtext.c:        x->x_glist->gl_editor->e_rtext = x->x_next;
g_rtext.c:        for (e2 = x->x_glist->gl_editor->e_rtext; e2; e2 = e2->x_next)
g_rtext.c:            if (e2->x_next == x)
g_rtext.c:            e2->x_next = x->x_next;
g_rtext.c:    freebytes(x->x_buf, x->x_bufsize);
g_rtext.c:    return (x->x_tag);
g_rtext.c:    *buf = x->x_buf;
g_rtext.c:    *bufsize = x->x_bufsize;
g_rtext.c:    *buf = x->x_buf + x->x_selstart;
g_rtext.c:    *bufsize = x->x_selend - x->x_selstart;
g_rtext.c:    switch (x->x_text->te_type) 
g_rtext.c:/* LATER deal with tcl-significant characters */
g_rtext.c: *  + returns byte offset of (first|last) occurrence of 'c' in 's[0..n-1]', or
g_rtext.c: *    -1 if none was found
g_rtext.c:    return (-1);
g_rtext.c:        s2--;
g_rtext.c:        n--;
g_rtext.c:    return (-1);
g_rtext.c:        SEND_FIRST - draw the box  for the first time
g_rtext.c:        SEND_UPDATE - redraw the updated box
g_rtext.c:        otherwise - don't draw, just calculate.
g_rtext.c:   /*-- moo: 
g_rtext.c:    *   (assuming valid UTF-8 encoded byte string in x->x_buf)
g_rtext.c:    t_canvas *canvas = glist_getcanvas(x->x_glist);
g_rtext.c:    int widthspec_c = x->x_text->te_width;
g_rtext.c:    int x_bufsize_c = u8_charnum(x->x_buf, x->x_bufsize);
g_rtext.c:    if (pd_class(&x->x_text->te_pd) == canvas_class &&
g_rtext.c:        ((t_glist *)(x->x_text))->gl_isgraph &&
g_rtext.c:        ((t_glist *)(x->x_text))->gl_goprect)
g_rtext.c:            font =  glist_getfont((t_glist *)(x->x_text));
g_rtext.c:    else font = glist_getfont(x->x_glist);
g_rtext.c:    if (x->x_bufsize >= 100)
g_rtext.c:         tempbuf = (char *)t_getbytes(2 * x->x_bufsize + 1);
g_rtext.c:    while (x_bufsize_c - inindex_c > 0)
g_rtext.c:        int inchars_b  = x->x_bufsize - inindex_b;
g_rtext.c:        int inchars_c  = x_bufsize_c  - inindex_c;
g_rtext.c:        int maxindex_b = u8_offset(x->x_buf + inindex_b, maxindex_c);
g_rtext.c:        int foundit_b  = firstone(x->x_buf + inindex_b, '\n', maxindex_b);
g_rtext.c:                foundit_b = lastone(x->x_buf + inindex_b, ' ', maxindex_b);
g_rtext.c:                    foundit_c = u8_charnum(x->x_buf + inindex_b, foundit_b);
g_rtext.c:            foundit_c = u8_charnum(x->x_buf + inindex_b, foundit_b);
g_rtext.c:            *indexp = inindex_b + u8_offset(x->x_buf + inindex_b, actualx);
g_rtext.c:        strncpy(tempbuf+outchars_b, x->x_buf + inindex_b, foundit_b);
g_rtext.c:        if (x->x_selstart >= inindex_b &&
g_rtext.c:            x->x_selstart <= inindex_b + foundit_b + eatchar)
g_rtext.c:                selstart_b = x->x_selstart + outchars_b - inindex_b;
g_rtext.c:        if (x->x_selend >= inindex_b &&
g_rtext.c:            x->x_selend <= inindex_b + foundit_b + eatchar)
g_rtext.c:                selend_b = x->x_selend + outchars_b - inindex_b;
g_rtext.c:        if (inindex_b < x->x_bufsize)
g_rtext.c:    dispx = text_xpix(x->x_text, x->x_glist);
g_rtext.c:    dispy = text_ypix(x->x_text, x->x_glist);
g_rtext.c:        while (ncolumns < (x->x_text->te_type == T_OBJECT ? 3 : 1))
g_rtext.c:        if (x->x_text->te_width && x->x_text->te_type != T_ATOM)
g_rtext.c:            int widthwas = x->x_text->te_width, newwidth = 0, newheight = 0,
g_rtext.c:            x->x_text->te_width = 0;
g_rtext.c:                x->x_text->te_width = widthwas;
g_rtext.c:            else x->x_text->te_width = 0;
g_rtext.c:                x->x_text->te_width);
g_rtext.c:            canvas, x->x_tag, rtext_gettype(x)->s_name,
g_rtext.c:            (glist_isselected(x->x_glist,
g_rtext.c:                &x->x_glist->gl_gobj)? "blue" : "black"));
g_rtext.c:            canvas, x->x_tag, outchars_b, tempbuf);
g_rtext.c:        if (pixwide != x->x_drawnwidth || pixhigh != x->x_drawnheight) 
g_rtext.c:            text_drawborder(x->x_text, x->x_glist, x->x_tag,
g_rtext.c:        if (x->x_active)
g_rtext.c:                    x->x_tag, u8_charnum(x->x_buf, selstart_b));
g_rtext.c:                    x->x_tag, u8_charnum(x->x_buf, selend_b) - 1);
g_rtext.c:                sys_vgui(".x%lx.c icursor %s %d\n", canvas, x->x_tag,
g_rtext.c:                    u8_charnum(x->x_buf, selstart_b));
g_rtext.c:                sys_vgui(".x%lx.c focus %s\n", canvas, x->x_tag);        
g_rtext.c:    x->x_drawnwidth = pixwide;
g_rtext.c:    x->x_drawnheight = pixhigh;
g_rtext.c:        t_freebytes(tempbuf, 2 * x->x_bufsize + 1);
g_rtext.c:    t_text *text = x->x_text;
g_rtext.c:    t_freebytes(x->x_buf, x->x_bufsize);
g_rtext.c:    binbuf_gettext(text->te_binbuf, &x->x_buf, &x->x_bufsize);
g_rtext.c:    if (text->te_width > 0 && text->te_type == T_ATOM &&
g_rtext.c:        x->x_bufsize > text->te_width)
g_rtext.c:        t_atom *atomp = binbuf_getvec(text->te_binbuf);
g_rtext.c:        int natom = binbuf_getnatom(text->te_binbuf);
g_rtext.c:        int bufsize = x->x_bufsize;
g_rtext.c:        if (natom == 1 && atomp->a_type == A_FLOAT)
g_rtext.c:            int wantreduce = bufsize - text->te_width;
g_rtext.c:            char *decimal = 0, *nextchar, *ebuf = x->x_buf + bufsize,
g_rtext.c:            for (decimal = x->x_buf; decimal < ebuf; decimal++)
g_rtext.c:            if (nextchar - decimal - 1 < wantreduce)
g_rtext.c:            for (s1 = nextchar - wantreduce, s2 = s1 + wantreduce;
g_rtext.c:            x->x_buf = t_resizebytes(x->x_buf, bufsize, text->te_width);
g_rtext.c:            bufsize = text->te_width;
g_rtext.c:                /* give up and bash it to "+" or "-" */
g_rtext.c:            x->x_buf[0] = (atomp->a_w.w_float < 0 ? '-' : '+');
g_rtext.c:            x->x_buf = t_resizebytes(x->x_buf, bufsize, 1);
g_rtext.c:        else if (bufsize > text->te_width)
g_rtext.c:            x->x_buf[text->te_width - 1] = '>';
g_rtext.c:            x->x_buf = t_resizebytes(x->x_buf, bufsize, text->te_width);
g_rtext.c:            bufsize = text->te_width;
g_rtext.c:        x->x_bufsize = bufsize;
g_rtext.c:    if (!gl->gl_editor)
g_rtext.c:    for (x = gl->gl_editor->e_rtext; x && x->x_text != who; x = x->x_next)
g_rtext.c:    sys_vgui(".x%lx.c delete %s\n", glist_getcanvas(x->x_glist), x->x_tag);
g_rtext.c:    sys_vgui(".x%lx.c move %s %d %d\n", glist_getcanvas(x->x_glist), 
g_rtext.c:        x->x_tag, dx, dy);
g_rtext.c:    t_glist *glist = x->x_glist;
g_rtext.c:    sys_vgui(".x%lx.c itemconfigure %s -fill %s\n", canvas, 
g_rtext.c:        x->x_tag, (state? "blue" : "black"));
g_rtext.c:    t_glist *glist = x->x_glist;
g_rtext.c:        sys_vgui("pdtk_text_editing .x%lx %s 1\n", canvas, x->x_tag);
g_rtext.c:        glist->gl_editor->e_textedfor = x;
g_rtext.c:        glist->gl_editor->e_textdirty = 0;
g_rtext.c:        x->x_dragfrom = x->x_selstart = 0;
g_rtext.c:        x->x_selend = x->x_bufsize;
g_rtext.c:        x->x_active = 1;
g_rtext.c:        if (glist->gl_editor->e_textedfor == x)
g_rtext.c:            glist->gl_editor->e_textedfor = 0;
g_rtext.c:        x->x_active = 0;
g_rtext.c:            /* if ((!x->x_selstart) && (x->x_selend == x->x_bufsize))
g_rtext.c:            if (x->x_selstart && (x->x_selstart == x->x_selend))
g_rtext.c:                u8_dec(x->x_buf, &x->x_selstart);
g_rtext.c:            if (x->x_selend < x->x_bufsize && (x->x_selstart == x->x_selend))
g_rtext.c:                u8_inc(x->x_buf, &x->x_selend);
g_rtext.c:        ndel = x->x_selend - x->x_selstart;
g_rtext.c:        for (i = x->x_selend; i < x->x_bufsize; i++)
g_rtext.c:            x->x_buf[i- ndel] = x->x_buf[i];
g_rtext.c:        newsize = x->x_bufsize - ndel;
g_rtext.c:        x->x_buf = resizebytes(x->x_buf, x->x_bufsize, newsize);
g_rtext.c:        x->x_bufsize = newsize;
g_rtext.c:be printable in whatever 8-bit character set we find ourselves. */
g_rtext.c:/*-- moo:
g_rtext.c:            newsize = x->x_bufsize+1;
g_rtext.c:            x->x_buf = resizebytes(x->x_buf, x->x_bufsize, newsize);
g_rtext.c:            for (i = x->x_bufsize; i > x->x_selstart; i--)
g_rtext.c:                x->x_buf[i] = x->x_buf[i-1];
g_rtext.c:            x->x_buf[x->x_selstart] = n;
g_rtext.c:            x->x_bufsize = newsize;
g_rtext.c:            x->x_selstart = x->x_selstart + 1;
g_rtext.c:        /*--moo: check for unicode codepoints beyond 7-bit ASCII --*/
g_rtext.c:            newsize = x->x_bufsize + ch_nbytes;
g_rtext.c:            x->x_buf = resizebytes(x->x_buf, x->x_bufsize, newsize);
g_rtext.c:            for (i = x->x_bufsize; i > x->x_selstart; i--)
g_rtext.c:                x->x_buf[i] = x->x_buf[i-1];
g_rtext.c:            x->x_bufsize = newsize;
g_rtext.c:            /*-- moo: assume canvas_key() has encoded keysym as UTF-8 */
g_rtext.c:            strncpy(x->x_buf+x->x_selstart, keysym->s_name, ch_nbytes);
g_rtext.c:            x->x_selstart = x->x_selstart + ch_nbytes;
g_rtext.c:        x->x_selend = x->x_selstart;
g_rtext.c:        x->x_glist->gl_editor->e_textdirty = 1;
g_rtext.c:    else if (!strcmp(keysym->s_name, "Right"))
g_rtext.c:        if (x->x_selend == x->x_selstart && x->x_selstart < x->x_bufsize)
g_rtext.c:            u8_inc(x->x_buf, &x->x_selstart);
g_rtext.c:            x->x_selend = x->x_selstart;
g_rtext.c:            x->x_selstart = x->x_selend;
g_rtext.c:    else if (!strcmp(keysym->s_name, "Left"))
g_rtext.c:        if (x->x_selend == x->x_selstart && x->x_selstart > 0)
g_rtext.c:            u8_dec(x->x_buf, &x->x_selstart);
g_rtext.c:            x->x_selend = x->x_selstart;
g_rtext.c:            x->x_selend = x->x_selstart;
g_rtext.c:    else if (!strcmp(keysym->s_name, "Up"))
g_rtext.c:        if (x->x_selstart)
g_rtext.c:            u8_dec(x->x_buf, &x->x_selstart);
g_rtext.c:        while (x->x_selstart > 0 && x->x_buf[x->x_selstart] != '\n')
g_rtext.c:            u8_dec(x->x_buf, &x->x_selstart);
g_rtext.c:        x->x_selend = x->x_selstart;
g_rtext.c:    else if (!strcmp(keysym->s_name, "Down"))
g_rtext.c:        while (x->x_selend < x->x_bufsize &&
g_rtext.c:            x->x_buf[x->x_selend] != '\n')
g_rtext.c:            u8_inc(x->x_buf, &x->x_selend);
g_rtext.c:        if (x->x_selend < x->x_bufsize)
g_rtext.c:            u8_inc(x->x_buf, &x->x_selend);
g_rtext.c:        x->x_selstart = x->x_selend;
g_rtext.c:        x->x_dragfrom = x->x_selstart = x->x_selend = indx;
g_rtext.c:        x->x_dragfrom = -1;
g_rtext.c:        if ((newseparator = lastone(x->x_buf, ' ', indx)) > whereseparator)
g_rtext.c:        if ((newseparator = lastone(x->x_buf, '\n', indx)) > whereseparator)
g_rtext.c:        if ((newseparator = lastone(x->x_buf, ';', indx)) > whereseparator)
g_rtext.c:        if ((newseparator = lastone(x->x_buf, ',', indx)) > whereseparator)
g_rtext.c:        x->x_selstart = whereseparator;
g_rtext.c:        whereseparator = x->x_bufsize - indx;
g_rtext.c:            firstone(x->x_buf+indx, ' ', x->x_bufsize - indx)) >= 0 &&
g_rtext.c:            firstone(x->x_buf+indx, '\n', x->x_bufsize - indx)) >= 0 &&
g_rtext.c:            firstone(x->x_buf+indx, ';', x->x_bufsize - indx)) >= 0 &&
g_rtext.c:            firstone(x->x_buf+indx, ',', x->x_bufsize - indx)) >= 0 &&
g_rtext.c:        x->x_selend = indx + whereseparator;
g_rtext.c:        if (indx * 2 > x->x_selstart + x->x_selend)
g_rtext.c:            x->x_dragfrom = x->x_selstart, x->x_selend = indx;
g_rtext.c:            x->x_dragfrom = x->x_selend, x->x_selstart = indx;
g_rtext.c:        if (x->x_dragfrom < 0)
g_rtext.c:        x->x_selstart = (x->x_dragfrom < indx ? x->x_dragfrom : indx);
g_rtext.c:        x->x_selend = (x->x_dragfrom > indx ? x->x_dragfrom : indx);
g_scalar.c:/* Copyright (c) 1997-1999 Miller Puckette.
g_scalar.c:    int i, nitems = template->t_n;
g_scalar.c:    t_dataslot *datatypes = template->t_vec;
g_scalar.c:        int type = datatypes->ds_type;
g_scalar.c:            wp->w_float = 0; 
g_scalar.c:            wp->w_symbol = &s_symbol;
g_scalar.c:            wp->w_array = array_new(datatypes->ds_arraytemplate, gp);
g_scalar.c:            wp->w_list = canvas_new(0, 0, 0, 0);
g_scalar.c:    int i, nitems = template->t_n;
g_scalar.c:    t_dataslot *datatypes = template->t_vec;
g_scalar.c:        int type = datatypes->ds_type;
g_scalar.c:                argv++, argc--;
g_scalar.c:            wp->w_float = f; 
g_scalar.c:                argv++, argc--;
g_scalar.c:            wp->w_symbol = s;
g_scalar.c:    for (dt = template->t_vec, i = 0; i < template->t_n; i++, dt++)
g_scalar.c:        if (dt->ds_type == DT_ARRAY)
g_scalar.c:        else if (dt->ds_type == DT_LIST)
g_scalar.c:        error("scalar: couldn't find template %s", templatesym->s_name);
g_scalar.c:        (template->t_n - 1) * sizeof(*x->sc_vec));
g_scalar.c:    x->sc_gobj.g_pd = scalar_class;
g_scalar.c:    x->sc_template = templatesym;
g_scalar.c:    word_init(x->sc_vec, template, &gp);
g_scalar.c:            atom_getsymbolarg(0, argc, argv)->s_name);
g_scalar.c:/* -------------------- widget behavior for scalar ------------ */
g_scalar.c:    t_template *template = template_findbyname(x->sc_template);
g_scalar.c:    *basex = template_getfloat(template, gensym("x"), x->sc_vec, 0);
g_scalar.c:    *basey = template_getfloat(template, gensym("y"), x->sc_vec, 0);
g_scalar.c:    t_template *template = template_findbyname(x->sc_template);
g_scalar.c:    int x1 = 0x7fffffff, x2 = -0x7fffffff, y1 = 0x7fffffff, y2 = -0x7fffffff;
g_scalar.c:        x2 = y2 = -0x7fffffff;
g_scalar.c:        for (y = templatecanvas->gl_list; y; y = y->g_next)
g_scalar.c:            t_parentwidgetbehavior *wb = pd_getparentwidget(&y->g_pd);
g_scalar.c:            (*wb->w_parentgetrectfn)(y, owner,
g_scalar.c:                x->sc_vec, template, basex, basey,
g_scalar.c:        scalar_getrect(&x->sc_gobj, glist, &x1, &y1, &x2, &y2);
g_scalar.c:        x1--; x2++; y1--; y2++;
g_scalar.c:            -width 0 -fill blue -tags select%lx\n",
g_scalar.c:    t_symbol *templatesym = x->sc_template;
g_scalar.c:    t_symbol *templatesym = x->sc_template;
g_scalar.c:        error("scalar: couldn't find template %s", templatesym->s_name);
g_scalar.c:        *(t_float *)(((char *)(x->sc_vec)) + xonset) +=
g_scalar.c:            dx * (glist_pixelstox(glist, 1) - glist_pixelstox(glist, 0));
g_scalar.c:        *(t_float *)(((char *)(x->sc_vec)) + yonset) +=
g_scalar.c:            dy * (glist_pixelstoy(glist, 1) - glist_pixelstoy(glist, 0));
g_scalar.c:    t_template *template = template_findbyname(x->sc_template);
g_scalar.c:            sys_vgui(".x%lx.c create rectangle %d %d %d %d -tags scalar%lx\n",
g_scalar.c:                glist_getcanvas(owner), x1-1, y1-1, x1+1, y1+1, x);
g_scalar.c:    for (y = templatecanvas->gl_list; y; y = y->g_next)
g_scalar.c:        t_parentwidgetbehavior *wb = pd_getparentwidget(&y->g_pd);
g_scalar.c:        (*wb->w_parentvisfn)(y, owner, x->sc_vec, template, basex, basey, vis);
g_scalar.c:    if (glist_isselected(owner, &x->sc_gobj))
g_scalar.c:    for (y = templatecanvas->gl_list; y; y = y->g_next)
g_scalar.c:        t_parentwidgetbehavior *wb = pd_getparentwidget(&y->g_pd);
g_scalar.c:        if (hit = (*wb->w_parentclickfn)(y, owner,
g_scalar.c:    t_template *template = template_findbyname(x->sc_template);
g_scalar.c:    return (scalar_doclick(x->sc_vec, template, x, 0,
g_scalar.c:    canvas_writescalar(x->sc_template, x->sc_vec, b2, 0);
g_scalar.c:    t_symbol *templatesym = x->sc_template;
g_scalar.c:        error("scalar: couldn't find template %s", templatesym->s_name);
g_scalar.c:    word_free(x->sc_vec, template);
g_scalar.c:    freebytes(x, sizeof(t_scalar) + (template->t_n - 1) * sizeof(*x->sc_vec));
g_scalar.c:/* ----------------- setup function ------------------- */
g_template.c:/* Copyright (c) 1997-1999 Miller Puckette.
g_template.c:/* ---------------- forward definitions ---------------- */
g_template.c:/* ---------------------- storage ------------------------- */
g_template.c:/* there's a pre-defined "float" template.  LATER should we bind this
g_template.c:to a symbol such as "pd-float"??? */
g_template.c:    return ((!nametoo || ds1->ds_name == ds2->ds_name) &&
g_template.c:        ds1->ds_type == ds2->ds_type &&
g_template.c:            (ds1->ds_type != DT_ARRAY ||
g_template.c:                ds1->ds_arraytemplate == ds2->ds_arraytemplate));
g_template.c:/* -- templates, the active ingredient in gtemplates defined below. ------- */
g_template.c:    x->t_n = 0;
g_template.c:    x->t_vec = (t_dataslot *)t_getbytes(0);
g_template.c:            argc--;
g_template.c:            pd_error(x, "%s: no such type", newtypesym->s_name);
g_template.c:        newn = (oldn = x->t_n) + 1;
g_template.c:        x->t_vec = (t_dataslot *)t_resizebytes(x->t_vec,
g_template.c:            oldn * sizeof(*x->t_vec), newn * sizeof(*x->t_vec));
g_template.c:        x->t_n = newn;
g_template.c:        x->t_vec[oldn].ds_type = newtype;
g_template.c:        x->t_vec[oldn].ds_name = newname;
g_template.c:        x->t_vec[oldn].ds_arraytemplate = newarraytemplate;
g_template.c:        argc -= 2; argv += 2;
g_template.c:    if (*templatesym->s_name)
g_template.c:        x->t_sym = templatesym;
g_template.c:        pd_bind(&x->t_pdobj, x->t_sym);
g_template.c:    else x->t_sym = templatesym;
g_template.c:    return (x->t_n * sizeof(t_word));
g_template.c:    n = x->t_n;
g_template.c:        if (x->t_vec[i].ds_name == name)
g_template.c:        *p_type = x->t_vec[i].ds_type;
g_template.c:        *p_arraytype = x->t_vec[i].ds_arraytemplate;
g_template.c:            x->t_sym->s_name, fieldname->s_name);
g_template.c:        x->t_sym->s_name, fieldname->s_name);
g_template.c:            x->t_sym->s_name, fieldname->s_name);
g_template.c:        x->t_sym->s_name, fieldname->s_name);
g_template.c:            x->t_sym->s_name, fieldname->s_name);
g_template.c:        x->t_sym->s_name, fieldname->s_name);
g_template.c:            x->t_sym->s_name, fieldname->s_name);
g_template.c:        x->t_sym->s_name, fieldname->s_name);
g_template.c:    if (x1->t_n < x2->t_n)
g_template.c:    for (i = x2->t_n; i < x1->t_n; i++)
g_template.c:        if (x1->t_vec[i].ds_type == DT_ARRAY || 
g_template.c:            x1->t_vec[i].ds_type == DT_LIST)
g_template.c:    if (x2->t_n > x1->t_n)
g_template.c:    for (i = 0; i < x2->t_n; i++)
g_template.c:        if (!dataslot_matches(&x1->t_vec[i], &x2->t_vec[i], 1))
g_template.c:/* --------------- CONFORMING TO CHANGES IN A TEMPLATE ------------ */
g_template.c:    int nfrom = tfrom->t_n, nto = tto->t_n, i;
g_template.c:    int nto = tto->t_n, nfrom = tfrom->t_n, i;
g_template.c:    if (scfrom->sc_template == tfrom->t_sym)
g_template.c:            (tto->t_n - 1) * sizeof(*x->sc_vec));
g_template.c:        x->sc_gobj.g_pd = scalar_class;
g_template.c:        x->sc_template = tfrom->t_sym;
g_template.c:        word_init(x->sc_vec, tto, &gp);
g_template.c:            scfrom->sc_vec, x->sc_vec);
g_template.c:        if (glist->gl_list == &scfrom->sc_gobj)
g_template.c:            glist->gl_list = &x->sc_gobj;
g_template.c:            x->sc_gobj.g_next = scfrom->sc_gobj.g_next;
g_template.c:            for (y = glist->gl_list; y2 = y->g_next; y = y2)
g_template.c:                if (y2 == &scfrom->sc_gobj)
g_template.c:                x->sc_gobj.g_next = y2->g_next;
g_template.c:                y->g_next = &x->sc_gobj;
g_template.c:        pd_free(&scfrom->sc_gobj.g_pd);
g_template.c:        scalartemplate = template_findbyname(x->sc_template);
g_template.c:    for (i = 0; i < scalartemplate->t_n; i++)
g_template.c:        t_dataslot *ds = scalartemplate->t_vec + i;
g_template.c:        if (ds->ds_type == DT_LIST)
g_template.c:            t_glist *gl2 = x->sc_vec[i].w_list;
g_template.c:        else if (ds->ds_type == DT_ARRAY)
g_template.c:                x->sc_vec[i].w_array);
g_template.c:    if (a->a_templatesym == tfrom->t_sym)
g_template.c:        int oldelemsize = sizeof(t_word) * tfrom->t_n,
g_template.c:            newelemsize = sizeof(t_word) * tto->t_n;
g_template.c:        char *newarray = getbytes(newelemsize * a->a_n);
g_template.c:        char *oldarray = a->a_vec;
g_template.c:        if (a->a_elemsize != oldelemsize)
g_template.c:        for (i = 0; i < a->a_n; i++)
g_template.c:            word_init(wp, tto, &a->a_gp);
g_template.c:        a->a_vec = newarray;
g_template.c:        freebytes(oldarray, oldelemsize * a->a_n);
g_template.c:    else scalartemplate = template_findbyname(a->a_templatesym);
g_template.c:    for (i = 0; i < a->a_n; i++)
g_template.c:        t_word *wp = (t_word *)(a->a_vec + sizeof(t_word) * a->a_n * i);
g_template.c:        for (j = 0; j < scalartemplate->t_n; j++)
g_template.c:            t_dataslot *ds = scalartemplate->t_vec + j;
g_template.c:            if (ds->ds_type == DT_LIST)
g_template.c:            else if (ds->ds_type == DT_ARRAY)
g_template.c:    /* post("conform glist %s", glist->gl_name->s_name); */
g_template.c:    for (g = glist->gl_list; g; g = g->g_next)
g_template.c:        if (pd_class(&g->g_pd) == scalar_class)
g_template.c:                glist, (t_scalar *)g)->sc_gobj;
g_template.c:        else if (pd_class(&g->g_pd) == canvas_class)
g_template.c:        else if (pd_class(&g->g_pd) == garray_class)
g_template.c:    int nto = tto->t_n, nfrom = tfrom->t_n, i, j,
g_template.c:        conformaction[i] = -1;
g_template.c:        t_dataslot *dataslot = &tto->t_vec[i];
g_template.c:            t_dataslot *dataslot2 = &tfrom->t_vec[j];
g_template.c:        t_dataslot *dataslot = &tto->t_vec[i];
g_template.c:                dataslot_matches(dataslot, &tfrom->t_vec[j], 0))
g_template.c:            tfrom->t_sym->s_name);
g_template.c:        for (gl = canvas_list; gl; gl = gl->gl_next)
g_template.c:    if (!(gt = template->t_list))
g_template.c:    return (gt->x_owner);
g_template.c:    /* return ((t_canvas *)pd_findbyclass(template->t_sym, canvas_class)); */
g_template.c:    if (template->t_list)
g_template.c:        outlet_anything(template->t_list->x_obj.ob_outlet, s, argc, argv);
g_template.c:    to the pre-existing struct. */
g_template.c:    argc--; argv++;
g_template.c:            if (x->t_list)
g_template.c:                    templatesym->s_name);
g_template.c:                pd_free(&x->t_pdobj);
g_template.c:                y2->t_list = 0;
g_template.c:        pd_free(&y->t_pdobj);
g_template.c:    if (*x->t_sym->s_name)
g_template.c:        pd_unbind(&x->t_pdobj, x->t_sym);
g_template.c:    t_freebytes(x->t_vec, x->t_n * sizeof(*x->t_vec));
g_template.c:/* ---------------- gtemplates.  One per canvas. ----------- */
g_template.c:    x->x_owner = canvas_getcurrent();
g_template.c:    x->x_next = 0;
g_template.c:    x->x_sym = sym;
g_template.c:    x->x_argc = argc;
g_template.c:    x->x_argv = (t_atom *)getbytes(argc * sizeof(t_atom));
g_template.c:        x->x_argv[i] = argv[i];
g_template.c:        x->x_template = t;
g_template.c:        if (t->t_list)
g_template.c:            for (x2 = x->x_template->t_list; x3 = x2->x_next; x2 = x3)
g_template.c:            x2->x_next = x;
g_template.c:            post("template %s: warning: already exists.", sym->s_name);
g_template.c:                pd_free(&t->t_pdobj);
g_template.c:            pd_free(&y->t_pdobj);
g_template.c:            t->t_list = x;
g_template.c:        x->x_template = t = template_new(sym, argc, argv);
g_template.c:        t->t_list = x;
g_template.c:    outlet_new(&x->x_obj, 0);
g_template.c:        argc--; argv++;
g_template.c:    /* old version (0.34) -- delete 2003 or so */
g_template.c:    t_symbol *sym = canvas_makebindsym(canvas_getcurrent()->gl_name);
g_template.c:        post("warning -- 'template' (%s) is obsolete; replace with 'struct'",
g_template.c:            sym->s_name);
g_template.c:    return (x->x_template);
g_template.c:    t_template *t = x->x_template;
g_template.c:    if (x == t->t_list)
g_template.c:        if (x->x_next)
g_template.c:                first-on-list and replace the existing template with it. */
g_template.c:                x->x_next->x_argc, x->x_next->x_argv);
g_template.c:            pd_free(&t->t_pdobj);
g_template.c:            pd_free(&z->t_pdobj);
g_template.c:            z = template_new(x->x_sym, x->x_next->x_argc, x->x_next->x_argv);
g_template.c:            z->t_list = x->x_next;
g_template.c:            for (y = z->t_list; y ; y = y->x_next)
g_template.c:                y->x_template = z;
g_template.c:        else t->t_list = 0;
g_template.c:        for (x2 = t->t_list; x3 = x2->x_next; x2 = x3)
g_template.c:                x2->x_next = x3->x_next;
g_template.c:    freebytes(x->x_argv, sizeof(t_atom) * x->x_argc);
g_template.c:/* ---------------  FIELD DESCRIPTORS ---------------------- */
g_template.c:    fd->fd_type = A_FLOAT;
g_template.c:    fd->fd_var = 0;
g_template.c:    fd->fd_un.fd_float = f;
g_template.c:    fd->fd_v1 = fd->fd_v2 = fd->fd_screen1 = fd->fd_screen2 =
g_template.c:        fd->fd_quantum = 0;
g_template.c:    fd->fd_type = A_SYMBOL;
g_template.c:    fd->fd_var = 0;
g_template.c:    fd->fd_un.fd_symbol = s;
g_template.c:    fd->fd_v1 = fd->fd_v2 = fd->fd_screen1 = fd->fd_screen2 =
g_template.c:        fd->fd_quantum = 0;
g_template.c:    fd->fd_type = A_FLOAT;
g_template.c:    fd->fd_var = 1;
g_template.c:    if (!(s1 = strchr(s->s_name, '(')) || !(s2 = strchr(s->s_name, ')'))
g_template.c:        fd->fd_un.fd_varsym = s;
g_template.c:        fd->fd_v1 = fd->fd_v2 = fd->fd_screen1 = fd->fd_screen2 =
g_template.c:            fd->fd_quantum = 0;
g_template.c:        int cpy = s1 - s->s_name, got;
g_template.c:        if (cpy > MAXPDSTRING-5)
g_template.c:            cpy = MAXPDSTRING-5;
g_template.c:        strncpy(strbuf, s->s_name, cpy);
g_template.c:        fd->fd_un.fd_varsym = gensym(strbuf);
g_template.c:        fd->fd_v1=v1;
g_template.c:        fd->fd_v2=v2;
g_template.c:        fd->fd_screen1=screen1;
g_template.c:        fd->fd_screen2=screen2;
g_template.c:        fd->fd_quantum=quantum;
g_template.c:            fd->fd_quantum = 0;
g_template.c:            fd->fd_quantum = 0;
g_template.c:            fd->fd_screen1 = fd->fd_v1;
g_template.c:            fd->fd_screen2 = fd->fd_v2;
g_template.c:        post("parse error: %s", s->s_name);
g_template.c:        fd->fd_v1 = fd->fd_screen1 = fd->fd_v2 = fd->fd_screen2 =
g_template.c:            fd->fd_quantum = 0;
g_template.c:        else if (argv->a_type == A_SYMBOL)
g_template.c:            fielddesc_setfloat_var(fd, argv->a_w.w_symbol);
g_template.c:        else fielddesc_setfloat_const(fd, argv->a_w.w_float);
g_template.c:        else if (argv->a_type == A_SYMBOL)
g_template.c:            fd->fd_type = A_SYMBOL;
g_template.c:            fd->fd_var = 1;
g_template.c:            fd->fd_un.fd_varsym = argv->a_w.w_symbol;
g_template.c:            fd->fd_v1 = fd->fd_v2 = fd->fd_screen1 = fd->fd_screen2 =
g_template.c:                fd->fd_quantum = 0;
g_template.c:        else if (argv->a_type == A_SYMBOL)
g_template.c:            fd->fd_type = A_ARRAY;
g_template.c:            fd->fd_var = 1;
g_template.c:            fd->fd_un.fd_varsym = argv->a_w.w_symbol;
g_template.c:        else fielddesc_setfloat_const(fd, argv->a_w.w_float);
g_template.c:    /* getting and setting values via fielddescs -- note confusing names;
g_template.c:    if (f->fd_type == A_FLOAT)
g_template.c:        if (f->fd_var)
g_template.c:            return (template_getfloat(template, f->fd_un.fd_varsym, wp, loud));
g_template.c:        else return (f->fd_un.fd_float);
g_template.c:    if (f->fd_v2 == f->fd_v1)
g_template.c:    div = (f->fd_screen2 - f->fd_screen1)/(f->fd_v2 - f->fd_v1);
g_template.c:    coord = f->fd_screen1 + (val - f->fd_v1) * div;
g_template.c:    extreme = (f->fd_screen1 < f->fd_screen2 ?
g_template.c:        f->fd_screen1 : f->fd_screen2);
g_template.c:    extreme = (f->fd_screen1 > f->fd_screen2 ? 
g_template.c:        f->fd_screen1 : f->fd_screen2);
g_template.c:    if (f->fd_type == A_FLOAT)
g_template.c:        if (f->fd_var)
g_template.c:                f->fd_un.fd_varsym, wp, loud);
g_template.c:        else return (f->fd_un.fd_float);
g_template.c:    if (f->fd_type == A_SYMBOL)
g_template.c:        if (f->fd_var)
g_template.c:            return(template_getsymbol(template, f->fd_un.fd_varsym, wp, loud));
g_template.c:        else return (f->fd_un.fd_symbol);
g_template.c:    if (f->fd_screen2 == f->fd_screen1)
g_template.c:        t_float div = (f->fd_v2 - f->fd_v1)/(f->fd_screen2 - f->fd_screen1);
g_template.c:        val = f->fd_v1 + (coord - f->fd_screen1) * div;
g_template.c:        if (f->fd_quantum != 0)
g_template.c:            val = ((int)((val/f->fd_quantum) + 0.5)) *  f->fd_quantum;
g_template.c:        extreme = (f->fd_v1 < f->fd_v2 ?
g_template.c:            f->fd_v1 : f->fd_v2);
g_template.c:        extreme = (f->fd_v1 > f->fd_v2 ?
g_template.c:            f->fd_v1 : f->fd_v2);
g_template.c:    if (f->fd_type == A_FLOAT && f->fd_var)
g_template.c:                f->fd_un.fd_varsym, wp, val, loud);
g_template.c:/* ---------------- curves and polygons (joined segments) ---------------- */
g_template.c:    char *classname = classsym->s_name;
g_template.c:    x->x_canvas = canvas_getcurrent();
g_template.c:    fielddesc_setfloat_const(&x->x_vis, 1);
g_template.c:        if (!strcmp(firstarg->s_name, "-v") && argc > 1)
g_template.c:            fielddesc_setfloatarg(&x->x_vis, 1, argv+1);
g_template.c:            argc -= 2; argv += 2;
g_template.c:        else if (!strcmp(firstarg->s_name, "-x"))
g_template.c:            argc -= 1; argv += 1;
g_template.c:    x->x_flags = flags;
g_template.c:        fielddesc_setfloatarg(&x->x_fillcolor, argc--, argv++);
g_template.c:    else fielddesc_setfloat_const(&x->x_fillcolor, 0); 
g_template.c:    if (argc) fielddesc_setfloatarg(&x->x_outlinecolor, argc--, argv++);
g_template.c:    else fielddesc_setfloat_const(&x->x_outlinecolor, 0);
g_template.c:    if (argc) fielddesc_setfloatarg(&x->x_width, argc--, argv++);
g_template.c:    else fielddesc_setfloat_const(&x->x_width, 1);
g_template.c:    x->x_npoints = (nxy>>1);
g_template.c:    x->x_vec = (t_fielddesc *)t_getbytes(nxy * sizeof(t_fielddesc));
g_template.c:    for (i = 0, fd = x->x_vec; i < argc; i++, fd++, argv++)
g_template.c:    if (x->x_vis.fd_type != A_FLOAT || x->x_vis.fd_var)
g_template.c:    viswas = (x->x_vis.fd_un.fd_float != 0);
g_template.c:    canvas_redrawallfortemplatecanvas(x->x_canvas, 2);
g_template.c:    fielddesc_setfloat_const(&x->x_vis, (f != 0));
g_template.c:    canvas_redrawallfortemplatecanvas(x->x_canvas, 1);
g_template.c:/* -------------------- widget behavior for curve ------------ */
g_template.c:    int i, n = x->x_npoints;
g_template.c:    t_fielddesc *f = x->x_vec;
g_template.c:    int x1 = 0x7fffffff, x2 = -0x7fffffff, y1 = 0x7fffffff, y2 = -0x7fffffff;
g_template.c:    if (!fielddesc_getfloat(&x->x_vis, template, data, 0) ||
g_template.c:        (x->x_flags & NOMOUSE))
g_template.c:        *xp2 = *yp2 = -0x7fffffff;
g_template.c:    for (i = 0, f = x->x_vec; i < n; i++, f += 2)
g_template.c:    int i, n = x->x_npoints;
g_template.c:    t_fielddesc *f = x->x_vec;
g_template.c:    if (vis && !fielddesc_getfloat(&x->x_vis, template, data, 0))
g_template.c:            int flags = x->x_flags, closed = (flags & CLOSED);
g_template.c:            t_float width = fielddesc_getfloat(&x->x_width, template, data, 1);
g_template.c:            for (i = 0, f = x->x_vec; i < n; i++, f += 2)
g_template.c:                fielddesc_getfloat(&x->x_outlinecolor, template, data, 1),
g_template.c:                    fielddesc_getfloat(&x->x_fillcolor, template, data, 1),
g_template.c:            sys_vgui("-width %f\\\n", width);
g_template.c:            if (flags & CLOSED) sys_vgui("-fill %s -outline %s\\\n",
g_template.c:            else sys_vgui("-fill %s\\\n", outline);
g_template.c:            if (flags & BEZ) sys_vgui("-smooth 1\\\n");
g_template.c:            sys_vgui("-tags curve%lx\n", data);
g_template.c:    t_fielddesc *f = x->x_vec + curve_motion_field;
g_template.c:    if (f->fd_var && (dx != 0))
g_template.c:    if ((f+1)->fd_var && (dy != 0))
g_template.c:    int i, n = x->x_npoints;
g_template.c:    int bestn = -1;
g_template.c:    if (!fielddesc_getfloat(&x->x_vis, template, data, 0))
g_template.c:    for (i = 0, f = x->x_vec; i < n; i++, f += 2)
g_template.c:        int xerr = xloc - xpix, yerr = yloc - ypix;
g_template.c:        if (!f->fd_var && !(f+1)->fd_var)
g_template.c:            xerr = -xerr;
g_template.c:            yerr = -yerr;
g_template.c:            - glist_pixelstox(glist, 0);
g_template.c:            - glist_pixelstoy(glist, 0);
g_template.c:    t_freebytes(x->x_vec, 2 * x->x_npoints * sizeof(*x->x_vec));
g_template.c:/* --------- plots for showing arrays --------------- */
g_template.c:    x->x_canvas = canvas_getcurrent();
g_template.c:    fielddesc_setfloat_var(&x->x_xpoints, gensym("x"));
g_template.c:    fielddesc_setfloat_var(&x->x_ypoints, gensym("y"));
g_template.c:    fielddesc_setfloat_var(&x->x_wpoints, gensym("w"));
g_template.c:    fielddesc_setfloat_const(&x->x_vis, 1);
g_template.c:    fielddesc_setfloat_const(&x->x_scalarvis, 1);
g_template.c:        if (!strcmp(firstarg->s_name, "curve") ||
g_template.c:            !strcmp(firstarg->s_name, "-c"))
g_template.c:            argc--, argv++;
g_template.c:        else if (!strcmp(firstarg->s_name, "-v") && argc > 1)
g_template.c:            fielddesc_setfloatarg(&x->x_vis, 1, argv+1);
g_template.c:            argc -= 2; argv += 2;
g_template.c:        else if (!strcmp(firstarg->s_name, "-vs") && argc > 1)
g_template.c:            fielddesc_setfloatarg(&x->x_scalarvis, 1, argv+1);
g_template.c:            argc -= 2; argv += 2;
g_template.c:        else if (!strcmp(firstarg->s_name, "-x") && argc > 1)
g_template.c:            fielddesc_setfloatarg(&x->x_xpoints, 1, argv+1);
g_template.c:            argc -= 2; argv += 2;
g_template.c:        else if (!strcmp(firstarg->s_name, "-y") && argc > 1)
g_template.c:            fielddesc_setfloatarg(&x->x_ypoints, 1, argv+1);
g_template.c:            argc -= 2; argv += 2;
g_template.c:        else if (!strcmp(firstarg->s_name, "-w") && argc > 1)
g_template.c:            fielddesc_setfloatarg(&x->x_wpoints, 1, argv+1);
g_template.c:            argc -= 2; argv += 2;
g_template.c:    if (argc) fielddesc_setarrayarg(&x->x_data, argc--, argv++);
g_template.c:    else fielddesc_setfloat_const(&x->x_data, 1);
g_template.c:    if (argc) fielddesc_setfloatarg(&x->x_outlinecolor, argc--, argv++);
g_template.c:    else fielddesc_setfloat_const(&x->x_outlinecolor, 0);
g_template.c:    if (argc) fielddesc_setfloatarg(&x->x_width, argc--, argv++);
g_template.c:    else fielddesc_setfloat_const(&x->x_width, 1);
g_template.c:    if (argc) fielddesc_setfloatarg(&x->x_xloc, argc--, argv++);
g_template.c:    else fielddesc_setfloat_const(&x->x_xloc, 1);
g_template.c:    if (argc) fielddesc_setfloatarg(&x->x_yloc, argc--, argv++);
g_template.c:    else fielddesc_setfloat_const(&x->x_yloc, 1);
g_template.c:    if (argc) fielddesc_setfloatarg(&x->x_xinc, argc--, argv++);
g_template.c:    else fielddesc_setfloat_const(&x->x_xinc, 1);
g_template.c:    if (argc) fielddesc_setfloatarg(&x->x_style, argc--, argv++);
g_template.c:    else fielddesc_setfloat_const(&x->x_style, defstyle);
g_template.c:    if (x->x_vis.fd_type != A_FLOAT || x->x_vis.fd_var)
g_template.c:    viswas = (x->x_vis.fd_un.fd_float != 0);
g_template.c:    canvas_redrawallfortemplatecanvas(x->x_canvas, 2);
g_template.c:    fielddesc_setfloat_const(&x->x_vis, (f != 0));
g_template.c:    canvas_redrawallfortemplatecanvas(x->x_canvas, 1);
g_template.c:/* -------------------- widget behavior for plot ------------ */
g_template.c:    if (x->x_data.fd_type != A_ARRAY || !x->x_data.fd_var)
g_template.c:        return (-1);
g_template.c:    if (!template_find_field(ownertemplate, x->x_data.fd_un.fd_varsym,
g_template.c:        error("plot: %s: no such field", x->x_data.fd_un.fd_varsym->s_name);
g_template.c:        return (-1);
g_template.c:        error("plot: %s: not an array", x->x_data.fd_un.fd_varsym->s_name);
g_template.c:        return (-1);
g_template.c:    *linewidthp = fielddesc_getfloat(&x->x_width, ownertemplate, data, 1);
g_template.c:    *xlocp = fielddesc_getfloat(&x->x_xloc, ownertemplate, data, 1);
g_template.c:    *xincp = fielddesc_getfloat(&x->x_xinc, ownertemplate, data, 1);
g_template.c:    *ylocp = fielddesc_getfloat(&x->x_yloc, ownertemplate, data, 1);
g_template.c:    *stylep = fielddesc_getfloat(&x->x_style, ownertemplate, data, 1);
g_template.c:    *visp = fielddesc_getfloat(&x->x_vis, ownertemplate, data, 1);
g_template.c:    *scalarvisp = fielddesc_getfloat(&x->x_scalarvis, ownertemplate, data, 1);
g_template.c:    *xfield = &x->x_xpoints;
g_template.c:    *yfield = &x->x_ypoints;
g_template.c:    *wfield = &x->x_wpoints;
g_template.c:        error("plot: %s: no such template", elemtemplatesym->s_name);
g_template.c:        return (-1);
g_template.c:        error("plot: %s: no canvas for this template", elemtemplatesym->s_name);
g_template.c:        return (-1);
g_template.c:    elemsize = elemtemplate->t_n * sizeof(t_word);
g_template.c:    if (yfielddesc && yfielddesc->fd_var)
g_template.c:        varname = yfielddesc->fd_un.fd_varsym;
g_template.c:            yonset = -1;
g_template.c:    if (xfielddesc && xfielddesc->fd_var)
g_template.c:        varname = xfielddesc->fd_un.fd_varsym;
g_template.c:            xonset = -1;
g_template.c:    if (wfielddesc && wfielddesc->fd_var)
g_template.c:        varname = wfielddesc->fd_un.fd_varsym;
g_template.c:            wonset = -1;
g_template.c:    int x1 = 0x7fffffff, y1 = 0x7fffffff, x2 = -0x7fffffff, y2 = -0x7fffffff;
g_template.c:        int incr = (array->a_n <= 2000 ? 1 : array->a_n / 1000);
g_template.c:        for (i = 0, xsum = 0; i < array->a_n; i += incr)
g_template.c:            array_getcoordinate(glist, (char *)(array->a_vec) + i * elemsize,
g_template.c:            if (ypix - wpix < y1)
g_template.c:                y1 = ypix - wpix;
g_template.c:                        *(t_float *)(((char *)(array->a_vec) + elemsize * i)
g_template.c:                    yval = *(t_float *)(((char *)(array->a_vec) + elemsize * i)
g_template.c:                for (y = elemtemplatecanvas->gl_list; y; y = y->g_next)
g_template.c:                    t_parentwidgetbehavior *wb = pd_getparentwidget(&y->g_pd);
g_template.c:                    (*wb->w_parentgetrectfn)(y, glist,
g_template.c:                        (t_word *)((char *)(array->a_vec) + elemsize * i),
g_template.c:    nelem = array->a_n;
g_template.c:    elem = (char *)array->a_vec;
g_template.c:            t_float minyval = 1e20, maxyval = -1e20;
g_template.c:                if (i == nelem-1 || inextx != ixpix)
g_template.c:-fill black -width 0  -tags [list plot%lx array]\n",
g_template.c:                    maxyval = -1e20;
g_template.c:            int lastpixel = -1, ndrawn = 0;
g_template.c:            numbertocolor(fielddesc_getfloat(&x->x_outlinecolor, template,
g_template.c:                                    yloc + yval) -
g_template.c:                lastpixel = -1;
g_template.c:                for (i = nelem-1; i >= 0; i--)
g_template.c:                    else xsum -= xinc, usexloc = xsum;
g_template.c:                            yval) -
g_template.c:                sys_vgui(" -width 1 -fill %s -outline %s\\\n",
g_template.c:                if (style == PLOTSTYLE_BEZ) sys_vgui("-smooth 1\\\n");
g_template.c:                sys_vgui("-tags [list plot%lx array]\n", data);
g_template.c:                sys_vgui("-width %f\\\n", linewidth);
g_template.c:                sys_vgui("-fill %s\\\n", outline);
g_template.c:                if (style == PLOTSTYLE_BEZ) sys_vgui("-smooth 1\\\n");
g_template.c:                sys_vgui("-tags [list plot%lx array]\n", data);
g_template.c:                for (y = elemtemplatecanvas->gl_list; y; y = y->g_next)
g_template.c:                    t_parentwidgetbehavior *wb = pd_getparentwidget(&y->g_pd);
g_template.c:                    (*wb->w_parentvisfn)(y, glist,
g_template.c:            /* un-draw the individual points */
g_template.c:                for (y = elemtemplatecanvas->gl_list; y; y = y->g_next)
g_template.c:                    t_parentwidgetbehavior *wb = pd_getparentwidget(&y->g_pd);
g_template.c:                    (*wb->w_parentvisfn)(y, glist,
g_template.c:/* ---------------- drawnumber: draw a number (or symbol) ---------------- */
g_template.c:    (drawnumber|drawsymbol) [-v <visible>] variable x y color label
g_template.c:    char *classname = classsym->s_name;
g_template.c:    x->x_flags = flags;
g_template.c:    fielddesc_setfloat_const(&x->x_vis, 1);
g_template.c:    x->x_canvas = canvas_getcurrent();
g_template.c:        if (!strcmp(firstarg->s_name, "-v") && argc > 1)
g_template.c:            fielddesc_setfloatarg(&x->x_vis, 1, argv+1);
g_template.c:            argc -= 2; argv += 2;
g_template.c:        if (argc) fielddesc_setsymbolarg(&x->x_value, argc--, argv++);
g_template.c:        else fielddesc_setsymbol_const(&x->x_value, &s_);
g_template.c:        if (argc) fielddesc_setfloatarg(&x->x_value, argc--, argv++);
g_template.c:        else fielddesc_setfloat_const(&x->x_value, 0);
g_template.c:    if (argc) fielddesc_setfloatarg(&x->x_xloc, argc--, argv++);
g_template.c:    else fielddesc_setfloat_const(&x->x_xloc, 0);
g_template.c:    if (argc) fielddesc_setfloatarg(&x->x_yloc, argc--, argv++);
g_template.c:    else fielddesc_setfloat_const(&x->x_yloc, 0);
g_template.c:    if (argc) fielddesc_setfloatarg(&x->x_color, argc--, argv++);
g_template.c:    else fielddesc_setfloat_const(&x->x_color, 1);
g_template.c:        x->x_label = atom_getsymbolarg(0, argc, argv);
g_template.c:    else x->x_label = &s_;
g_template.c:    if (x->x_vis.fd_type != A_FLOAT || x->x_vis.fd_var)
g_template.c:    viswas = (x->x_vis.fd_un.fd_float != 0);
g_template.c:    canvas_redrawallfortemplatecanvas(x->x_canvas, 2);
g_template.c:    fielddesc_setfloat_const(&x->x_vis, (f != 0));
g_template.c:    canvas_redrawallfortemplatecanvas(x->x_canvas, 1);
g_template.c:/* -------------------- widget behavior for drawnumber ------------ */
g_template.c:    strncpy(buf, x->x_label->s_name, DRAWNUMBER_BUFSIZE);
g_template.c:    buf[DRAWNUMBER_BUFSIZE - 1] = 0;
g_template.c:    atom_string(ap, buf + nchars, DRAWNUMBER_BUFSIZE - nchars);
g_template.c:    if (!fielddesc_getfloat(&x->x_vis, template, data, 0))
g_template.c:        *xp2 = *yp2 = -0x7fffffff;
g_template.c:        basex + fielddesc_getcoord(&x->x_xloc, template, data, 0));
g_template.c:        basey + fielddesc_getcoord(&x->x_yloc, template, data, 0));
g_template.c:    if (x->x_flags & DRAW_SYMBOL)
g_template.c:        SETSYMBOL(&at, fielddesc_getsymbol(&x->x_value, template, data, 0));
g_template.c:    else SETFLOAT(&at, fielddesc_getfloat(&x->x_value, template, data, 0));
g_template.c:    if (vis && !fielddesc_getfloat(&x->x_vis, template, data, 0))
g_template.c:            basex + fielddesc_getcoord(&x->x_xloc, template, data, 0));
g_template.c:            basey + fielddesc_getcoord(&x->x_yloc, template, data, 0));
g_template.c:        numbertocolor(fielddesc_getfloat(&x->x_color, template, data, 1),
g_template.c:        if (x->x_flags & DRAW_SYMBOL)
g_template.c:            SETSYMBOL(&at, fielddesc_getsymbol(&x->x_value, template, data, 0));
g_template.c:        else SETFLOAT(&at, fielddesc_getfloat(&x->x_value, template, data, 0));
g_template.c:        sys_vgui(".x%lx.c create text %d %d -anchor nw -fill %s -text {%s}",
g_template.c:        sys_vgui(" -font {{%s} -%d %s}", sys_font,
g_template.c:        sys_vgui(" -tags [list drawnumber%lx label]\n", data);
g_template.c:    t_fielddesc *f = &x->x_value;
g_template.c:    drawnumber_motion_ycumulative -= dy;
g_template.c:        f->fd_un.fd_varsym,
g_template.c:    t_fielddesc *f = &x->x_value;
g_template.c:            f->fd_un.fd_varsym, drawnumber_motion_wp, 1)->s_name,
g_template.c:        sbuf[MAXPDSTRING-1] = 0;
g_template.c:                sbuf[strlen(sbuf)-1] = 0;
g_template.c:            f->fd_un.fd_varsym, drawnumber_motion_wp, 1));
g_template.c:                sbuf[strlen(sbuf)-1] = 0;
g_template.c:            f->fd_un.fd_varsym, drawnumber_motion_wp, (t_float)newf, 1);
g_template.c:        && x->x_value.fd_var &&
g_template.c:            fielddesc_getfloat(&x->x_vis, template, data, 0))
g_template.c:                fielddesc_getfloat(&x->x_value, template, data, 0);
g_template.c:            drawnumber_motion_symbol = ((x->x_flags & DRAW_SYMBOL) != 0);
g_template.c:/* ---------------------- setup function ---------------------------- */
g_text.c:/* Copyright (c) 1997-1999 Miller Puckette.
g_text.c:/* the methods for calling the gui-objects from menu are implemented */
g_text.c:/* ----------------- the "text" object.  ------------------ */
g_text.c:    x->te_width = 0;                            /* don't know it yet. */
g_text.c:    x->te_type = T_TEXT;
g_text.c:    x->te_binbuf = binbuf_new();
g_text.c:        x->te_xpix = atom_getfloatarg(0, argc, argv);
g_text.c:        x->te_ypix = atom_getfloatarg(1, argc, argv);
g_text.c:        if (argc > 2) binbuf_restore(x->te_binbuf, argc-2, argv+2);
g_text.c:            binbuf_restore(x->te_binbuf, 1, &at);
g_text.c:        glist_add(gl, &x->te_g);
g_text.c:        x->te_xpix = xpix-1;
g_text.c:        x->te_ypix = ypix-1;
g_text.c:        binbuf_restore(x->te_binbuf, 1, &at);
g_text.c:        glist_add(gl, &x->te_g);
g_text.c:        glist_select(gl, &x->te_g);
g_text.c:            "put-me-down" click changes the text selection, which is quite
g_text.c:            /* gobj_activate(&x->te_g, gl, 1); */
g_text.c:/* ----------------- the "object" object.  ------------------ */
g_text.c:    x->te_binbuf = b;
g_text.c:    x->te_xpix = xpix;
g_text.c:    x->te_ypix = ypix;
g_text.c:    x->te_width = 0;
g_text.c:    x->te_type = T_OBJECT;
g_text.c:    glist_add(gl, &x->te_g);
g_text.c:        glist_select(gl, &x->te_g);
g_text.c:        gobj_activate(&x->te_g, gl, 1);
g_text.c:    if (pd_class(&x->ob_pd) == vinlet_class)
g_text.c:    if (pd_class(&x->ob_pd) == voutlet_class)
g_text.c:    int connectme = (x->gl_editor->e_selection &&
g_text.c:        !x->gl_editor->e_selection->sel_next && !sys_noautopatch);
g_text.c:        t_gobj *g, *selected = x->gl_editor->e_selection->sel_what;
g_text.c:        for (g = x->gl_list, nobj = 0; g; g = g->g_next, nobj++)
g_text.c:        for (g = x->gl_list, n2 = 0; g; g = g->g_next, n2++)
g_text.c:            else if (!g->g_next)
g_text.c:                indx = nobj-1;
g_text.c:        *xpixp -= 3;
g_text.c:        *ypixp -= 3;
g_text.c:        binbuf_restore(b, argc-2, argv+2);
g_text.c:        pd_vmess(&gl->gl_pd, gensym("editmode"), "i", 1);
g_text.c:    pd_vmess(&gl->gl_pd, gensym("editmode"), "i", 1);
g_text.c:    x->te_width = 0;                            /* don't know it yet. */
g_text.c:    x->te_type = T_OBJECT;
g_text.c:    x->te_binbuf = binbuf_new();
g_text.c:    x->te_xpix = atom_getfloatarg(0, argc, argv);
g_text.c:    x->te_ypix = atom_getfloatarg(1, argc, argv);
g_text.c:    if (argc > 2) binbuf_restore(x->te_binbuf, argc-2, argv+2);
g_text.c:    glist_add(gl, &x->te_g);
g_text.c:/* ---------------------- the "message" text item ------------------------ */
g_text.c:    outlet_bang(x->mr_outlet);
g_text.c:    outlet_float(x->mr_outlet, f);
g_text.c:    outlet_symbol(x->mr_outlet, s);
g_text.c:    outlet_list(x->mr_outlet, s, argc, argv);
g_text.c:    outlet_anything(x->mr_outlet, s, argc, argv);
g_text.c:    binbuf_eval(x->m_text.te_binbuf, &x->m_messresponder.mr_pd, 0, 0);
g_text.c:    binbuf_eval(x->m_text.te_binbuf, &x->m_messresponder.mr_pd, 1, &at);
g_text.c:    binbuf_eval(x->m_text.te_binbuf, &x->m_messresponder.mr_pd, 1, &at);
g_text.c:    binbuf_eval(x->m_text.te_binbuf, &x->m_messresponder.mr_pd, argc, argv);
g_text.c:    binbuf_clear(x->m_text.te_binbuf);
g_text.c:    binbuf_add(x->m_text.te_binbuf, argc, argv);
g_text.c:    glist_retext(x->m_glist, &x->m_text);
g_text.c:    binbuf_add(x->m_text.te_binbuf, argc, argv);
g_text.c:    glist_retext(x->m_glist, &x->m_text);
g_text.c:    binbuf_add(x->m_text.te_binbuf, argc, argv);
g_text.c:    binbuf_addsemi(x->m_text.te_binbuf);
g_text.c:    glist_retext(x->m_glist, &x->m_text);
g_text.c:    binbuf_add(x->m_text.te_binbuf, 1, &a);
g_text.c:    glist_retext(x->m_glist, &x->m_text);
g_text.c:    binbuf_add(x->m_text.te_binbuf, 1, &a);
g_text.c:    glist_retext(x->m_glist, &x->m_text);
g_text.c:    strncpy(buf+1, s->s_name, MAXPDSTRING-2);
g_text.c:    buf[MAXPDSTRING-1] = 0;
g_text.c:    binbuf_add(x->m_text.te_binbuf, 1, &a);
g_text.c:    glist_retext(x->m_glist, &x->m_text);
g_text.c:    if (glist_isvisible(x->m_glist))
g_text.c:        t_rtext *y = glist_findrtext(x->m_glist, &x->m_text);
g_text.c:        sys_vgui(".x%lx.c itemconfigure %sR -width 5\n", 
g_text.c:            glist_getcanvas(x->m_glist), rtext_gettag(y));
g_text.c:        clock_delay(x->m_clock, 120);
g_text.c:    if (glist_isvisible(x->m_glist))
g_text.c:        t_rtext *y = glist_findrtext(x->m_glist, &x->m_text);
g_text.c:        sys_vgui(".x%lx.c itemconfigure %sR -width 1\n",
g_text.c:            glist_getcanvas(x->m_glist), rtext_gettag(y));
g_text.c:    clock_free(x->m_clock);
g_text.c:    x->m_messresponder.mr_pd = messresponder_class;
g_text.c:    x->m_messresponder.mr_outlet = outlet_new(&x->m_text, &s_float);
g_text.c:    x->m_text.te_width = 0;                             /* don't know it yet. */
g_text.c:    x->m_text.te_type = T_MESSAGE;
g_text.c:    x->m_text.te_binbuf = binbuf_new();
g_text.c:    x->m_glist = gl;
g_text.c:    x->m_clock = clock_new(x, (t_method)message_tick);
g_text.c:        x->m_text.te_xpix = atom_getfloatarg(0, argc, argv);
g_text.c:        x->m_text.te_ypix = atom_getfloatarg(1, argc, argv);
g_text.c:        if (argc > 2) binbuf_restore(x->m_text.te_binbuf, argc-2, argv+2);
g_text.c:        glist_add(gl, &x->m_text.te_g);
g_text.c:        pd_vmess(&gl->gl_pd, gensym("editmode"), "i", 1);
g_text.c:        x->m_text.te_xpix = xpix;
g_text.c:        x->m_text.te_ypix = ypix;
g_text.c:        glist_add(gl, &x->m_text.te_g);
g_text.c:        glist_select(gl, &x->m_text.te_g);
g_text.c:        gobj_activate(&x->m_text.te_g, gl, 1);
g_text.c:/* ---------------------- the "atom" text item ------------------------ */
g_text.c:    t_symbol *a_symfrom;    /* "receive" name -- bind ourselvs to this */
g_text.c:    t_symbol *a_symto;      /* "send" name -- send to this on output */
g_text.c:    char a_wherelabel;      /* 0-3 for left, right, above, below */
g_text.c:    /* prepend "-" as necessary to avoid empty strings, so we can
g_text.c:    if (!*s->s_name)
g_text.c:        return (gensym("-"));
g_text.c:    else if (*s->s_name == '-')
g_text.c:        shmo[0] = '-';
g_text.c:        strncpy(shmo+1, s->s_name, 99);
g_text.c:    /* undo previous operation: strip leading "-" if found. */
g_text.c:    if (*s->s_name == '-')
g_text.c:        return (gensym(s->s_name+1));
g_text.c:    glist_retext(x->a_glist, &x->a_text);
g_text.c:    binbuf_clear(x->a_text.te_binbuf);
g_text.c:    binbuf_add(x->a_text.te_binbuf, 1, &x->a_atom);
g_text.c:    if (senditup && glist_isvisible(x->a_glist))
g_text.c:        sys_queuegui(x, x->a_glist, gatom_redraw);
g_text.c:    t_atom oldatom = x->a_atom;
g_text.c:    if (x->a_atom.a_type == A_FLOAT)
g_text.c:        x->a_atom.a_w.w_float = atom_getfloat(argv),
g_text.c:            changed = (x->a_atom.a_w.w_float != oldatom.a_w.w_float);
g_text.c:    else if (x->a_atom.a_type == A_SYMBOL)
g_text.c:        x->a_atom.a_w.w_symbol = atom_getsymbol(argv),
g_text.c:            changed = (x->a_atom.a_w.w_symbol != oldatom.a_w.w_symbol);
g_text.c:    x->a_buf[0] = 0;
g_text.c:    if (x->a_atom.a_type == A_FLOAT)
g_text.c:        if (x->a_text.te_outlet)
g_text.c:            outlet_float(x->a_text.te_outlet, x->a_atom.a_w.w_float);
g_text.c:        if (*x->a_expanded_to->s_name && x->a_expanded_to->s_thing)
g_text.c:            if (x->a_symto == x->a_symfrom)
g_text.c:                        x->a_symto->s_name);
g_text.c:            else pd_float(x->a_expanded_to->s_thing, x->a_atom.a_w.w_float);
g_text.c:    else if (x->a_atom.a_type == A_SYMBOL)
g_text.c:        if (x->a_text.te_outlet)
g_text.c:            outlet_symbol(x->a_text.te_outlet, x->a_atom.a_w.w_symbol);
g_text.c:        if (*x->a_symto->s_name && x->a_expanded_to->s_thing)
g_text.c:            if (x->a_symto == x->a_symfrom)
g_text.c:                        x->a_symto->s_name);
g_text.c:            else pd_symbol(x->a_expanded_to->s_thing, x->a_atom.a_w.w_symbol);
g_text.c:    if (x->a_draglo != 0 || x->a_draghi != 0)
g_text.c:        if (f < x->a_draglo)
g_text.c:            f = x->a_draglo;
g_text.c:        if (f > x->a_draghi)
g_text.c:            f = x->a_draghi;
g_text.c:    else if (argv->a_type == A_FLOAT)
g_text.c:        gatom_float(x, argv->a_w.w_float);
g_text.c:    else if (argv->a_type == A_SYMBOL)
g_text.c:        gatom_symbol(x, argv->a_w.w_symbol);
g_text.c:    if (x->a_atom.a_type == A_FLOAT)
g_text.c:        if (x->a_shift)
g_text.c:            double nval = x->a_atom.a_w.w_float - 0.01 * dy;
g_text.c:            if (trunc < nval + 0.0001 && trunc > nval - 0.0001) nval = trunc;
g_text.c:            double nval = x->a_atom.a_w.w_float - dy;
g_text.c:            if (trunc < nval + 0.0001 && trunc > nval - 0.0001) nval = trunc;
g_text.c:            if (trunc < nval + 0.001 && trunc > nval - 0.001) nval = trunc;
g_text.c:    int len = strlen(x->a_buf);
g_text.c:        if (x->a_buf[0])
g_text.c:        x->a_buf[len-1] = 0;
g_text.c:        if (x->a_atom.a_type == A_FLOAT)
g_text.c:            x->a_atom.a_w.w_float = atof(x->a_buf);
g_text.c:        else if (x->a_atom.a_type == A_SYMBOL)
g_text.c:            x->a_atom.a_w.w_symbol = gensym(x->a_buf);
g_text.c:        x->a_buf[0] = 0;
g_text.c:    else if (len < (ATOMBUFSIZE-1))
g_text.c:        if ((x->a_atom.a_type == A_SYMBOL) ||
g_text.c:            (c >= '0' && c <= '9' || c == '.' || c == '-'
g_text.c:            if((len+utf8len) < (ATOMBUFSIZE-1))
g_text.c:                    x->a_buf[len+j] = utf8[j];
g_text.c:                x->a_buf[len+utf8len] = 0;
g_text.c:    sprintf(sbuf, "%s...", x->a_buf);
g_text.c:    binbuf_clear(x->a_text.te_binbuf);
g_text.c:    binbuf_add(x->a_text.te_binbuf, 1, &at);
g_text.c:    glist_retext(x->a_glist, &x->a_text);
g_text.c:    if (x->a_text.te_width == 1)
g_text.c:        if (x->a_atom.a_type == A_FLOAT)
g_text.c:            gatom_float(x, (x->a_atom.a_w.w_float == 0));
g_text.c:            if (x->a_atom.a_type != A_FLOAT) return;
g_text.c:            if (x->a_atom.a_w.w_float != 0)
g_text.c:                x->a_toggle = x->a_atom.a_w.w_float;
g_text.c:            else gatom_float(x, x->a_toggle);
g_text.c:        x->a_shift = shift;
g_text.c:        x->a_buf[0] = 0;
g_text.c:        glist_grab(x->a_glist, &x->a_text.te_g, gatom_motion, gatom_key,
g_text.c:    gobj_vis(&x->a_text.te_g, x->a_glist, 0);
g_text.c:    if (!*symfrom->s_name && *x->a_symfrom->s_name)
g_text.c:        inlet_new(&x->a_text, &x->a_text.te_pd, 0, 0);
g_text.c:    else if (*symfrom->s_name && !*x->a_symfrom->s_name && x->a_text.te_inlet)
g_text.c:        canvas_deletelinesforio(x->a_glist, &x->a_text,
g_text.c:            x->a_text.te_inlet, 0);
g_text.c:        inlet_free(x->a_text.te_inlet);
g_text.c:    if (!*symto->s_name && *x->a_symto->s_name)
g_text.c:        outlet_new(&x->a_text, 0);
g_text.c:    else if (*symto->s_name && !*x->a_symto->s_name && x->a_text.te_outlet)
g_text.c:        canvas_deletelinesforio(x->a_glist, &x->a_text,
g_text.c:            0, x->a_text.te_outlet);
g_text.c:        outlet_free(x->a_text.te_outlet);
g_text.c:    x->a_draglo = draglo;
g_text.c:    x->a_draghi = draghi;
g_text.c:    x->a_text.te_width = width;
g_text.c:    x->a_wherelabel = ((int)wherelabel & 3);
g_text.c:    x->a_label = label;
g_text.c:    if (*x->a_symfrom->s_name)
g_text.c:        pd_unbind(&x->a_text.te_pd,
g_text.c:            canvas_realizedollar(x->a_glist, x->a_symfrom));
g_text.c:    x->a_symfrom = symfrom;
g_text.c:    if (*x->a_symfrom->s_name)
g_text.c:        pd_bind(&x->a_text.te_pd,
g_text.c:            canvas_realizedollar(x->a_glist, x->a_symfrom));
g_text.c:    x->a_symto = symto;
g_text.c:    x->a_expanded_to = canvas_realizedollar(x->a_glist, x->a_symto);
g_text.c:    gobj_vis(&x->a_text.te_g, x->a_glist, 1);
g_text.c:    canvas_dirty(x->a_glist, 1);
g_text.c:    /* glist_retext(x->a_glist, &x->a_text); */
g_text.c:    /* ---------------- gatom-specific widget functions --------------- */
g_text.c:    text_getrect(&x->a_text.te_g, glist, &x1, &y1, &x2, &y2);
g_text.c:    width = x2 - x1;
g_text.c:    height = y2 - y1;
g_text.c:    if (x->a_wherelabel == ATOM_LABELLEFT)
g_text.c:        *xp = x1 - 3 -
g_text.c:            strlen(canvas_realizedollar(x->a_glist, x->a_label)->s_name) *
g_text.c:    else if (x->a_wherelabel == ATOM_LABELRIGHT)
g_text.c:    else if (x->a_wherelabel == ATOM_LABELUP)
g_text.c:        *xp = x1 - 1;
g_text.c:        *yp = y1 - 1 - sys_fontheight(glist_getfont(glist));;
g_text.c:        *xp = x1 - 1;
g_text.c:    if (*x->a_label->s_name)
g_text.c:                canvas_realizedollar(x->a_glist, x->a_label)->s_name,
g_text.c:    x->a_text.te_width = 0;                        /* don't know it yet. */
g_text.c:    x->a_text.te_type = T_ATOM;
g_text.c:    x->a_text.te_binbuf = binbuf_new();
g_text.c:    x->a_glist = gl;
g_text.c:    x->a_atom.a_type = type;
g_text.c:    x->a_toggle = 1;
g_text.c:    x->a_draglo = 0;
g_text.c:    x->a_draghi = 0;
g_text.c:    x->a_wherelabel = 0;
g_text.c:    x->a_label = &s_;
g_text.c:    x->a_symfrom = &s_;
g_text.c:    x->a_symto = x->a_expanded_to = &s_;
g_text.c:        x->a_atom.a_w.w_float = 0;
g_text.c:        x->a_text.te_width = 5;
g_text.c:        x->a_atom.a_w.w_symbol = &s_symbol;
g_text.c:        x->a_text.te_width = 10;
g_text.c:    binbuf_add(x->a_text.te_binbuf, 1, &at);
g_text.c:        /* create from file. x, y, width, low-range, high-range, flags,
g_text.c:            label, receive-name, send-name */
g_text.c:        x->a_text.te_xpix = atom_getfloatarg(0, argc, argv);
g_text.c:        x->a_text.te_ypix = atom_getfloatarg(1, argc, argv);
g_text.c:        x->a_text.te_width = atom_getintarg(2, argc, argv);
g_text.c:        if (x->a_text.te_width < 0 || x->a_text.te_width > 500)
g_text.c:            x->a_text.te_width = 4;
g_text.c:        x->a_draglo = atom_getfloatarg(3, argc, argv);
g_text.c:        x->a_draghi = atom_getfloatarg(4, argc, argv);
g_text.c:        x->a_wherelabel = (((int)atom_getfloatarg(5, argc, argv)) & 3);
g_text.c:        x->a_label = gatom_unescapit(atom_getsymbolarg(6, argc, argv));
g_text.c:        x->a_symfrom = gatom_unescapit(atom_getsymbolarg(7, argc, argv));
g_text.c:        if (*x->a_symfrom->s_name)
g_text.c:            pd_bind(&x->a_text.te_pd,
g_text.c:                canvas_realizedollar(x->a_glist, x->a_symfrom));
g_text.c:        x->a_symto = gatom_unescapit(atom_getsymbolarg(8, argc, argv));
g_text.c:        x->a_expanded_to = canvas_realizedollar(x->a_glist, x->a_symto);
g_text.c:        if (x->a_symto == &s_)
g_text.c:            outlet_new(&x->a_text,
g_text.c:                x->a_atom.a_type == A_FLOAT ? &s_float: &s_symbol);
g_text.c:        if (x->a_symfrom == &s_)
g_text.c:            inlet_new(&x->a_text, &x->a_text.te_pd, 0, 0);
g_text.c:        glist_add(gl, &x->a_text.te_g);
g_text.c:        outlet_new(&x->a_text,
g_text.c:            x->a_atom.a_type == A_FLOAT ? &s_float: &s_symbol);
g_text.c:        inlet_new(&x->a_text, &x->a_text.te_pd, 0, 0);
g_text.c:        pd_vmess(&gl->gl_pd, gensym("editmode"), "i", 1);
g_text.c:        x->a_text.te_xpix = xpix;
g_text.c:        x->a_text.te_ypix = ypix;
g_text.c:        glist_add(gl, &x->a_text.te_g);
g_text.c:        glist_select(gl, &x->a_text.te_g);
g_text.c:    if (*x->a_symfrom->s_name)
g_text.c:        pd_unbind(&x->a_text.te_pd,
g_text.c:            canvas_realizedollar(x->a_glist, x->a_symfrom));
g_text.c:        x->a_text.te_width, x->a_draglo, x->a_draghi,
g_text.c:            x->a_wherelabel, gatom_escapit(x->a_label)->s_name,
g_text.c:                gatom_escapit(x->a_symfrom)->s_name,
g_text.c:                    gatom_escapit(x->a_symto)->s_name);
g_text.c:    gfxstub_new(&x->a_text.te_pd, x, buf);
g_text.c:/* -------------------- widget behavior for text objects ------------ */
g_text.c:    int width, height, iscomment = (x->te_type == T_TEXT);
g_text.c:    if (x->te_type == T_ATOM && x->te_width > 0)
g_text.c:        width = (x->te_width > 0 ? x->te_width : 6) * fontwidth + 2;
g_text.c:    else if (glist->gl_editor && glist->gl_editor->e_rtext)
g_text.c:        height = rtext_height(y) - (iscomment << 1);
g_text.c:    x->te_xpix += dx;
g_text.c:    x->te_ypix += dy;
g_text.c:    if (glist_isvisible(glist) && gobj_shouldvis(&x->te_g, glist))
g_text.c:        sys_vgui(".x%lx.c itemconfigure %sR -fill %s\n", glist, 
g_text.c:    if (z->g_pd != gatom_class) rtext_activate(y, state);
g_text.c:        if (gobj_shouldvis(&x->te_g, glist))
g_text.c:            if (x->te_type == T_ATOM)
g_text.c:        if (gobj_shouldvis(&x->te_g, glist))
g_text.c:    if (x->te_type == T_OBJECT)
g_text.c:        if (zgetfn(&x->te_pd, clicksym))
g_text.c:                pd_vmess(&x->te_pd, clicksym, "fffff",
g_text.c:    else if (x->te_type == T_ATOM)
g_text.c:    else if (x->te_type == T_MESSAGE)
g_text.c:    if (x->te_type == T_OBJECT)
g_text.c:        if (zgetfn(&x->te_pd, gensym("saveto")) &&
g_text.c:            !((pd_class(&x->te_pd) == canvas_class) && 
g_text.c:            mess1(&x->te_pd, gensym("saveto"), b);
g_text.c:                (int)x->te_xpix, (int)x->te_ypix);
g_text.c:                (int)x->te_xpix, (int)x->te_ypix);
g_text.c:        binbuf_addbinbuf(b, x->te_binbuf);
g_text.c:    else if (x->te_type == T_MESSAGE)
g_text.c:            (int)x->te_xpix, (int)x->te_ypix);
g_text.c:        binbuf_addbinbuf(b, x->te_binbuf);
g_text.c:    else if (x->te_type == T_ATOM)
g_text.c:        t_atomtype t = ((t_gatom *)x)->a_atom.a_type;
g_text.c:        t_symbol *label = gatom_escapit(((t_gatom *)x)->a_label);
g_text.c:        t_symbol *symfrom = gatom_escapit(((t_gatom *)x)->a_symfrom);
g_text.c:        t_symbol *symto = gatom_escapit(((t_gatom *)x)->a_symto);
g_text.c:            (int)x->te_xpix, (int)x->te_ypix, (int)x->te_width,
g_text.c:            (double)((t_gatom *)x)->a_draglo,
g_text.c:            (double)((t_gatom *)x)->a_draghi,
g_text.c:            (double)((t_gatom *)x)->a_wherelabel,
g_text.c:            (int)x->te_xpix, (int)x->te_ypix);
g_text.c:        binbuf_addbinbuf(b, x->te_binbuf);
g_text.c:/* -------------------- the "text" class  ------------ */
g_text.c:    int n = obj_noutlets(ob), nplus = (n == 1 ? 1 : n-1), i;
g_text.c:    int width = x2 - x1;
g_text.c:        int onset = x1 + (width - IOWIDTH) * i / nplus;
g_text.c:-tags [list %so%d outlet]\n",
g_text.c:                onset, y2 - 1,
g_text.c:                onset, y2 - 1,
g_text.c:    nplus = (n == 1 ? 1 : n-1);
g_text.c:        int onset = x1 + (width - IOWIDTH) * i / nplus;
g_text.c:-tags [list %si%d inlet]\n",
g_text.c:    text_getrect(&x->te_g, glist, &x1, &y1, &x2, &y2);
g_text.c:    width = x2 - x1;
g_text.c:    height = y2 - y1;
g_text.c:    if (x->te_type == T_OBJECT)
g_text.c:        char *pattern = ((pd_class(&x->te_pd) == text_class) ? "-" : "\"\"");
g_text.c: %d %d %d %d %d %d %d %d %d %d -dash %s -tags [list %sR obj]\n",
g_text.c:            sys_vgui(".x%lx.c itemconfigure %sR -dash %s\n",
g_text.c:    else if (x->te_type == T_MESSAGE)
g_text.c: %d %d %d %d %d %d %d %d %d %d %d %d %d %d -tags [list %sR msg]\n",
g_text.c:                x1, y1,  x2+4, y1,  x2, y1+4,  x2, y2-4,  x2+4, y2,
g_text.c:                x1, y1,  x2+4, y1,  x2, y1+4,  x2, y2-4,  x2+4, y2,
g_text.c:    else if (x->te_type == T_ATOM)
g_text.c: %d %d %d %d %d %d %d %d %d %d %d %d -tags [list %sR atom]\n",
g_text.c:                x1, y1,  x2-4, y1,  x2, y1+4,  x2, y2,  x1, y2,  x1, y1,
g_text.c:                x1, y1,  x2-4, y1,  x2, y1+4,  x2, y2,  x1, y2,  x1, y1);
g_text.c:    if (ob = pd_checkobject(&x->te_pd))
g_text.c:    if (x->te_type == T_TEXT) return;
g_text.c:    if (x->te_type == T_OBJECT)
g_text.c:        natom1 = binbuf_getnatom(x->te_binbuf);
g_text.c:        vec1 = binbuf_getvec(x->te_binbuf);
g_text.c:            && !strcmp(vec1[0].a_w.w_symbol->s_name, "pd") &&
g_text.c:            && !strcmp(vec2[0].a_w.w_symbol->s_name, "pd"))
g_text.c:            typedmess(&x->te_pd, gensym("rename"), natom2-1, vec2+1);
g_text.c:            binbuf_free(x->te_binbuf);
g_text.c:            x->te_binbuf = b;
g_text.c:            int xwas = x->te_xpix, ywas = x->te_ypix;
g_text.c:            glist_delete(glist, &x->te_g);
g_text.c:            && !strcmp(vec2[0].a_w.w_symbol->s_name, "pd"))
g_text.c:    else binbuf_text(x->te_binbuf, buf, bufsize);
g_toggle.c:/* Copyright (c) 1997-1999 Miller Puckette.
g_toggle.c:/* g_7_guis.c written by Thomas Musil (c) IEM KUG Graz Austria 2000-2001 */
g_toggle.c:/* --------------- tgl     gui-toggle ------------------------- */
g_toggle.c:        sys_vgui(".x%lx.c itemconfigure %lxX1 -fill #%6.6x\n", canvas, x,
g_toggle.c:                 (x->x_on!=0.0)?x->x_gui.x_fcol:x->x_gui.x_bcol);
g_toggle.c:        sys_vgui(".x%lx.c itemconfigure %lxX2 -fill #%6.6x\n", canvas, x,
g_toggle.c:                 (x->x_on!=0.0)?x->x_gui.x_fcol:x->x_gui.x_bcol);
g_toggle.c:    int w=1, xx=text_xpix(&x->x_gui.x_obj, glist), yy=text_ypix(&x->x_gui.x_obj, glist);
g_toggle.c:    if(x->x_gui.x_w >= 30)
g_toggle.c:    if(x->x_gui.x_w >= 60)
g_toggle.c:    sys_vgui(".x%lx.c create rectangle %d %d %d %d -fill #%6.6x -tags %lxBASE\n",
g_toggle.c:             canvas, xx, yy, xx + x->x_gui.x_w, yy + x->x_gui.x_h,
g_toggle.c:             x->x_gui.x_bcol, x);
g_toggle.c:    sys_vgui(".x%lx.c create line %d %d %d %d -width %d -fill #%6.6x -tags %lxX1\n",
g_toggle.c:             canvas, xx+w+1, yy+w+1, xx + x->x_gui.x_w-w, yy + x->x_gui.x_h-w, w,
g_toggle.c:             (x->x_on!=0.0)?x->x_gui.x_fcol:x->x_gui.x_bcol, x);
g_toggle.c:    sys_vgui(".x%lx.c create line %d %d %d %d -width %d -fill #%6.6x -tags %lxX2\n",
g_toggle.c:             canvas, xx+w+1, yy + x->x_gui.x_h-w-1, xx + x->x_gui.x_w-w, yy+w, w,
g_toggle.c:             (x->x_on!=0.0)?x->x_gui.x_fcol:x->x_gui.x_bcol, x);
g_toggle.c:    sys_vgui(".x%lx.c create text %d %d -text {%s} -anchor w \
g_toggle.c:             -font {{%s} -%d %s} -fill #%6.6x -tags [list %lxLABEL label text]\n",
g_toggle.c:             canvas, xx+x->x_gui.x_ldx,
g_toggle.c:             yy+x->x_gui.x_ldy,
g_toggle.c:             strcmp(x->x_gui.x_lab->s_name, "empty")?x->x_gui.x_lab->s_name:"",
g_toggle.c:             x->x_gui.x_font, x->x_gui.x_fontsize, sys_fontweight,
g_toggle.c:             x->x_gui.x_lcol, x);
g_toggle.c:    if(!x->x_gui.x_fsf.x_snd_able)
g_toggle.c:        sys_vgui(".x%lx.c create rectangle %d %d %d %d -tags [list %lxOUT%d outlet]\n",
g_toggle.c:             canvas, xx, yy + x->x_gui.x_h-1, xx + IOWIDTH, yy + x->x_gui.x_h, x, 0);
g_toggle.c:    if(!x->x_gui.x_fsf.x_rcv_able)
g_toggle.c:        sys_vgui(".x%lx.c create rectangle %d %d %d %d -tags [list %lxIN%d inlet]\n",
g_toggle.c:    int w=1, xx=text_xpix(&x->x_gui.x_obj, glist), yy=text_ypix(&x->x_gui.x_obj, glist);
g_toggle.c:    if(x->x_gui.x_w >= 30)
g_toggle.c:    if(x->x_gui.x_w >= 60)
g_toggle.c:             canvas, x, xx, yy, xx + x->x_gui.x_w, yy + x->x_gui.x_h);
g_toggle.c:    sys_vgui(".x%lx.c itemconfigure %lxX1 -width %d\n", canvas, x, w);
g_toggle.c:             canvas, x, xx+w+1, yy+w+1, xx + x->x_gui.x_w-w, yy + x->x_gui.x_h-w);
g_toggle.c:    sys_vgui(".x%lx.c itemconfigure %lxX2 -width %d\n", canvas, x, w);
g_toggle.c:             canvas, x, xx+w+1, yy + x->x_gui.x_h-w-1, xx + x->x_gui.x_w-w, yy+w);
g_toggle.c:             canvas, x, xx+x->x_gui.x_ldx, yy+x->x_gui.x_ldy);
g_toggle.c:    if(!x->x_gui.x_fsf.x_snd_able)
g_toggle.c:             canvas, x, 0, xx, yy + x->x_gui.x_h-1, xx + IOWIDTH, yy + x->x_gui.x_h);
g_toggle.c:    if(!x->x_gui.x_fsf.x_rcv_able)
g_toggle.c:    if(!x->x_gui.x_fsf.x_snd_able)
g_toggle.c:    if(!x->x_gui.x_fsf.x_rcv_able)
g_toggle.c:    sys_vgui(".x%lx.c itemconfigure %lxLABEL -font {{%s} -%d %s} -fill #%6.6x -text {%s} \n",
g_toggle.c:             canvas, x, x->x_gui.x_font, x->x_gui.x_fontsize, sys_fontweight,
g_toggle.c:             x->x_gui.x_fsf.x_selected?IEM_GUI_COLOR_SELECTED:x->x_gui.x_lcol,
g_toggle.c:             strcmp(x->x_gui.x_lab->s_name, "empty")?x->x_gui.x_lab->s_name:"");
g_toggle.c:    sys_vgui(".x%lx.c itemconfigure %lxBASE -fill #%6.6x\n", canvas, x,
g_toggle.c:             x->x_gui.x_bcol);
g_toggle.c:    sys_vgui(".x%lx.c itemconfigure %lxX1 -fill #%6.6x\n", canvas, x,
g_toggle.c:             x->x_on?x->x_gui.x_fcol:x->x_gui.x_bcol);
g_toggle.c:    sys_vgui(".x%lx.c itemconfigure %lxX2 -fill #%6.6x\n", canvas, x,
g_toggle.c:             x->x_on?x->x_gui.x_fcol:x->x_gui.x_bcol);
g_toggle.c:    int xpos=text_xpix(&x->x_gui.x_obj, glist);
g_toggle.c:    int ypos=text_ypix(&x->x_gui.x_obj, glist);
g_toggle.c:    if((old_snd_rcv_flags & IEM_GUI_OLD_SND_FLAG) && !x->x_gui.x_fsf.x_snd_able)
g_toggle.c:        sys_vgui(".x%lx.c create rectangle %d %d %d %d -tags %lxOUT%d\n",
g_toggle.c:             ypos + x->x_gui.x_h-1, xpos + IOWIDTH,
g_toggle.c:             ypos + x->x_gui.x_h, x, 0);
g_toggle.c:    if(!(old_snd_rcv_flags & IEM_GUI_OLD_SND_FLAG) && x->x_gui.x_fsf.x_snd_able)
g_toggle.c:    if((old_snd_rcv_flags & IEM_GUI_OLD_RCV_FLAG) && !x->x_gui.x_fsf.x_rcv_able)
g_toggle.c:        sys_vgui(".x%lx.c create rectangle %d %d %d %d -tags %lxIN%d\n",
g_toggle.c:    if(!(old_snd_rcv_flags & IEM_GUI_OLD_RCV_FLAG) && x->x_gui.x_fsf.x_rcv_able)
g_toggle.c:    if(x->x_gui.x_fsf.x_selected)
g_toggle.c:        sys_vgui(".x%lx.c itemconfigure %lxBASE -outline #%6.6x\n", canvas, x, IEM_GUI_COLOR_SELECTED);
g_toggle.c:        sys_vgui(".x%lx.c itemconfigure %lxLABEL -fill #%6.6x\n", canvas, x, IEM_GUI_COLOR_SELECTED);
g_toggle.c:        sys_vgui(".x%lx.c itemconfigure %lxBASE -outline #%6.6x\n", canvas, x, IEM_GUI_COLOR_NORMAL);
g_toggle.c:        sys_vgui(".x%lx.c itemconfigure %lxLABEL -fill #%6.6x\n", canvas, x, x->x_gui.x_lcol);
g_toggle.c:        toggle_draw_io(x, glist, mode - IEM_GUI_DRAW_MODE_IO);
g_toggle.c:/* ------------------------ tgl widgetbehaviour----------------------------- */
g_toggle.c:    *xp1 = text_xpix(&x->x_gui.x_obj, glist);
g_toggle.c:    *yp1 = text_ypix(&x->x_gui.x_obj, glist);
g_toggle.c:    *xp2 = *xp1 + x->x_gui.x_w;
g_toggle.c:    *yp2 = *yp1 + x->x_gui.x_h;
g_toggle.c:    iemgui_save(&x->x_gui, srl, bflcol);
g_toggle.c:                (int)x->x_gui.x_obj.te_xpix,
g_toggle.c:                (int)x->x_gui.x_obj.te_ypix,
g_toggle.c:                gensym("tgl"), x->x_gui.x_w,
g_toggle.c:                iem_symargstoint(&x->x_gui.x_isa),
g_toggle.c:                x->x_gui.x_ldx, x->x_gui.x_ldy,
g_toggle.c:                iem_fstyletoint(&x->x_gui.x_fsf), x->x_gui.x_fontsize,
g_toggle.c:                bflcol[0], bflcol[1], bflcol[2], x->x_on, x->x_nonzero);
g_toggle.c:    iemgui_properties(&x->x_gui, srl);
g_toggle.c:            ----------dimensions(pix):----------- %d %d size: 0 0 empty \
g_toggle.c:            -----------non-zero-value:----------- %g value: 0.0 empty %g \
g_toggle.c:            -1 lin log %d %d empty %d \
g_toggle.c:            x->x_gui.x_w, IEM_GUI_MINSIZE,
g_toggle.c:            x->x_nonzero, 1.0,/*non_zero-schedule*/
g_toggle.c:            x->x_gui.x_isa.x_loadinit, -1, -1,/*no multi*/
g_toggle.c:            srl[0]->s_name, srl[1]->s_name,
g_toggle.c:            srl[2]->s_name, x->x_gui.x_ldx, x->x_gui.x_ldy,
g_toggle.c:            x->x_gui.x_fsf.x_font_style, x->x_gui.x_fontsize,
g_toggle.c:            0xffffff & x->x_gui.x_bcol, 0xffffff & x->x_gui.x_fcol, 0xffffff & x->x_gui.x_lcol);
g_toggle.c:    gfxstub_new(&x->x_gui.x_obj.ob_pd, x, buf);
g_toggle.c:    x->x_on = (x->x_on==0.0)?x->x_nonzero:0.0;
g_toggle.c:    (*x->x_gui.x_draw)(x, x->x_gui.x_glist, IEM_GUI_DRAW_MODE_UPDATE);
g_toggle.c:    outlet_float(x->x_gui.x_obj.ob_outlet, x->x_on);
g_toggle.c:    if(x->x_gui.x_fsf.x_snd_able && x->x_gui.x_snd->s_thing)
g_toggle.c:        pd_float(x->x_gui.x_snd->s_thing, x->x_on);
g_toggle.c:    x->x_nonzero = nonzero;
g_toggle.c:    if(x->x_on != 0.0)
g_toggle.c:        x->x_on = x->x_nonzero;
g_toggle.c:    sr_flags = iemgui_dialog(&x->x_gui, srl, argc, argv);
g_toggle.c:    x->x_gui.x_w = iemgui_clip_size(a);
g_toggle.c:    x->x_gui.x_h = x->x_gui.x_w;
g_toggle.c:    (*x->x_gui.x_draw)(x, x->x_gui.x_glist, IEM_GUI_DRAW_MODE_CONFIG);
g_toggle.c:    (*x->x_gui.x_draw)(x, x->x_gui.x_glist, IEM_GUI_DRAW_MODE_IO + sr_flags);
g_toggle.c:    (*x->x_gui.x_draw)(x, x->x_gui.x_glist, IEM_GUI_DRAW_MODE_MOVE);
g_toggle.c:    canvas_fixlinesfor(x->x_gui.x_glist, (t_text*)x);
g_toggle.c:    int old = (x->x_on != 0);
g_toggle.c:    x->x_on = f;
g_toggle.c:        x->x_nonzero = f;
g_toggle.c:    if ((x->x_on != 0) != old)
g_toggle.c:        (*x->x_gui.x_draw)(x, x->x_gui.x_glist, IEM_GUI_DRAW_MODE_UPDATE);
g_toggle.c:    if(x->x_gui.x_fsf.x_put_in2out)
g_toggle.c:        outlet_float(x->x_gui.x_obj.ob_outlet, x->x_on);
g_toggle.c:        if(x->x_gui.x_fsf.x_snd_able && x->x_gui.x_snd->s_thing)
g_toggle.c:            pd_float(x->x_gui.x_snd->s_thing, x->x_on);
g_toggle.c:    outlet_float(x->x_gui.x_obj.ob_outlet, x->x_on);
g_toggle.c:    if(x->x_gui.x_fsf.x_snd_able && x->x_gui.x_snd->s_thing)
g_toggle.c:        pd_float(x->x_gui.x_snd->s_thing, x->x_on);
g_toggle.c:    if(!sys_noloadbang && x->x_gui.x_isa.x_loadinit)
g_toggle.c:        toggle_fout(x, (t_float)x->x_on);
g_toggle.c:    x->x_gui.x_w = iemgui_clip_size((int)atom_getintarg(0, ac, av));
g_toggle.c:    x->x_gui.x_h = x->x_gui.x_w;
g_toggle.c:    iemgui_size((void *)x, &x->x_gui);
g_toggle.c:{iemgui_delta((void *)x, &x->x_gui, s, ac, av);}
g_toggle.c:{iemgui_pos((void *)x, &x->x_gui, s, ac, av);}
g_toggle.c:{iemgui_color((void *)x, &x->x_gui, s, ac, av);}
g_toggle.c:{iemgui_send(x, &x->x_gui, s);}
g_toggle.c:{iemgui_receive(x, &x->x_gui, s);}
g_toggle.c:{iemgui_label((void *)x, &x->x_gui, s);}
g_toggle.c:{iemgui_label_font((void *)x, &x->x_gui, s, ac, av);}
g_toggle.c:{iemgui_label_pos((void *)x, &x->x_gui, s, ac, av);}
g_toggle.c:    x->x_gui.x_isa.x_loadinit = (f==0.0)?0:1;
g_toggle.c:        x->x_nonzero = f;
g_toggle.c:    int bflcol[]={-262144, -1, -1};
g_toggle.c:    iem_inttosymargs(&x->x_gui.x_isa, 0);
g_toggle.c:    iem_inttofstyle(&x->x_gui.x_fsf, 0);
g_toggle.c:        iem_inttosymargs(&x->x_gui.x_isa, atom_getintarg(1, argc, argv));
g_toggle.c:        iemgui_new_getnames(&x->x_gui, 2, argv);
g_toggle.c:        iem_inttofstyle(&x->x_gui.x_fsf, atom_getintarg(7, argc, argv));
g_toggle.c:    else iemgui_new_getnames(&x->x_gui, 2, 0);
g_toggle.c:    x->x_gui.x_draw = (t_iemfunptr)toggle_draw;
g_toggle.c:    x->x_gui.x_fsf.x_snd_able = 1;
g_toggle.c:    x->x_gui.x_fsf.x_rcv_able = 1;
g_toggle.c:    x->x_gui.x_glist = (t_glist *)canvas_getcurrent();
g_toggle.c:    if (!strcmp(x->x_gui.x_snd->s_name, "empty"))
g_toggle.c:        x->x_gui.x_fsf.x_snd_able = 0;
g_toggle.c:    if (!strcmp(x->x_gui.x_rcv->s_name, "empty"))
g_toggle.c:        x->x_gui.x_fsf.x_rcv_able = 0;
g_toggle.c:    if(x->x_gui.x_fsf.x_font_style == 1) strcpy(x->x_gui.x_font, "helvetica");
g_toggle.c:    else if(x->x_gui.x_fsf.x_font_style == 2) strcpy(x->x_gui.x_font, "times");
g_toggle.c:    else { x->x_gui.x_fsf.x_font_style = 0;
g_toggle.c:        strcpy(x->x_gui.x_font, sys_font); }
g_toggle.c:    x->x_nonzero = (nonzero!=0.0)?nonzero:1.0;
g_toggle.c:    if(x->x_gui.x_isa.x_loadinit)
g_toggle.c:        x->x_on = (on!=0.0)?nonzero:0.0;
g_toggle.c:        x->x_on = 0.0;
g_toggle.c:    if (x->x_gui.x_fsf.x_rcv_able)
g_toggle.c:        pd_bind(&x->x_gui.x_obj.ob_pd, x->x_gui.x_rcv);
g_toggle.c:    x->x_gui.x_ldx = ldx;
g_toggle.c:    x->x_gui.x_ldy = ldy;
g_toggle.c:    x->x_gui.x_fontsize = fs;
g_toggle.c:    x->x_gui.x_w = iemgui_clip_size(a);
g_toggle.c:    x->x_gui.x_h = x->x_gui.x_w;
g_toggle.c:    iemgui_all_colfromload(&x->x_gui, bflcol);
g_toggle.c:    iemgui_verify_snd_ne_rcv(&x->x_gui);
g_toggle.c:    outlet_new(&x->x_gui.x_obj, &s_float);
g_toggle.c:    if(x->x_gui.x_fsf.x_rcv_able)
g_toggle.c:        pd_unbind(&x->x_gui.x_obj.ob_pd, x->x_gui.x_rcv);
g_traversal.c:/* Copyright (c) 1997-1999 Miller Puckette.
g_traversal.c:pointer - point to an object belonging to a template
g_traversal.c:get -     get numeric fields
g_traversal.c:set -     change numeric fields
g_traversal.c:element - get an array element
g_traversal.c:getsize - get the size of an array
g_traversal.c:setsize - change the size of an array
g_traversal.c:append -  add an element to a list
g_traversal.c:sublist - get a pointer into a list which is an element of another scalar
g_traversal.c:/* ------------- gstubs and gpointers - safe pointing --------------- */
g_traversal.c:        gs->gs_which = GP_GLIST;
g_traversal.c:        gs->gs_un.gs_glist = gl;
g_traversal.c:        gs->gs_which = GP_ARRAY;
g_traversal.c:        gs->gs_un.gs_array = a;
g_traversal.c:    gs->gs_refcount = 0;
g_traversal.c:    int refcount = --gs->gs_refcount;
g_traversal.c:    if ((!refcount) && gs->gs_which == GP_NONE)
g_traversal.c:    gs->gs_which = GP_NONE;
g_traversal.c:    if (gs->gs_refcount < 0) bug("gstub_cutoff");
g_traversal.c:    if (!gs->gs_refcount) t_freebytes(gs, sizeof (*gs));
g_traversal.c:    t_gstub *gs = gp->gp_stub;
g_traversal.c:    if (gs->gs_which == GP_ARRAY)
g_traversal.c:        if (gs->gs_un.gs_array->a_valid != gp->gp_valid) return (0);
g_traversal.c:    else if (gs->gs_which == GP_GLIST)
g_traversal.c:        if (!headok && !gp->gp_un.gp_scalar) return (0);
g_traversal.c:        else if (gs->gs_un.gs_glist->gl_valid != gp->gp_valid) return (0);
g_traversal.c:    t_gstub *gs = gp->gp_stub;
g_traversal.c:    if (gs->gs_which == GP_GLIST)
g_traversal.c:        t_scalar *sc = gp->gp_un.gp_scalar;
g_traversal.c:            return (sc->sc_template);
g_traversal.c:        t_array *a = gs->gs_un.gs_array;
g_traversal.c:        return (a->a_templatesym);
g_traversal.c:    if (gpto->gp_stub)
g_traversal.c:        gpto->gp_stub->gs_refcount++;
g_traversal.c:    if (gs = gp->gp_stub)
g_traversal.c:        gp->gp_stub = 0;
g_traversal.c:    if (gs = gp->gp_stub) gstub_dis(gs);
g_traversal.c:    gp->gp_stub = gs = glist->gl_stub;
g_traversal.c:    gp->gp_valid = glist->gl_valid;
g_traversal.c:    gp->gp_un.gp_scalar = x;
g_traversal.c:    gs->gs_refcount++;
g_traversal.c:    if (gs = gp->gp_stub) gstub_dis(gs);
g_traversal.c:    gp->gp_stub = gs = array->a_stub;
g_traversal.c:    gp->gp_valid = array->a_valid;
g_traversal.c:    gp->gp_un.gp_w = w;
g_traversal.c:    gs->gs_refcount++;
g_traversal.c:    gp->gp_stub = 0;
g_traversal.c:    gp->gp_valid = 0;
g_traversal.c:    gp->gp_un.gp_scalar = 0;
g_traversal.c:/* ---------------------- pointers ----------------------------- */
g_traversal.c:    gpointer_init(&x->x_gp);
g_traversal.c:    x->x_typedout = to = (t_typedout *)getbytes(argc * sizeof (*to));
g_traversal.c:    x->x_ntypedout = n = argc;
g_traversal.c:    for (; n--; to++)
g_traversal.c:        to->to_outlet = outlet_new(&x->x_obj, &s_pointer);
g_traversal.c:        to->to_type = canvas_makebindsym(atom_getsymbol(argv++));
g_traversal.c:    x->x_otherout = outlet_new(&x->x_obj, &s_pointer);
g_traversal.c:    x->x_bangout = outlet_new(&x->x_obj, &s_bang);
g_traversal.c:    pointerinlet_new(&x->x_obj, &x->x_gp);
g_traversal.c:    if (glist) gpointer_setglist(&x->x_gp, glist, 0);
g_traversal.c:    else pd_error(x, "pointer: list '%s' not found", s->s_name);
g_traversal.c:    t_gpointer *gp = &x->x_gp;
g_traversal.c:    t_gstub *gs = gp->gp_stub;
g_traversal.c:    if (gs->gs_which != GP_GLIST)
g_traversal.c:    glist = gs->gs_un.gs_glist;
g_traversal.c:    if (glist->gl_valid != gp->gp_valid)
g_traversal.c:            "ptrobj_vnext: next-selected only works for a visible window");
g_traversal.c:    gobj = &gp->gp_un.gp_scalar->sc_gobj;
g_traversal.c:    if (!gobj) gobj = glist->gl_list;
g_traversal.c:    else gobj = gobj->g_next;
g_traversal.c:    while (gobj && ((pd_class(&gobj->g_pd) != scalar_class) ||
g_traversal.c:            gobj = gobj->g_next;
g_traversal.c:        t_symbol *templatesym = sc->sc_template;
g_traversal.c:        gp->gp_un.gp_scalar = sc; 
g_traversal.c:        for (n = x->x_ntypedout, to = x->x_typedout; n--; to++)
g_traversal.c:            if (to->to_type == templatesym)
g_traversal.c:                outlet_pointer(to->to_outlet, &x->x_gp);
g_traversal.c:        outlet_pointer(x->x_otherout, &x->x_gp);
g_traversal.c:        outlet_bang(x->x_bangout);
g_traversal.c:    if (!gpointer_check(&x->x_gp, 1))
g_traversal.c:    gs = x->x_gp.gp_stub;
g_traversal.c:    if (gs->gs_which == GP_GLIST)
g_traversal.c:        glist = gs->gs_un.gs_glist;  
g_traversal.c:        t_array *owner_array = gs->gs_un.gs_array;
g_traversal.c:        while (owner_array->a_gp.gp_stub->gs_which == GP_ARRAY)
g_traversal.c:            owner_array = owner_array->a_gp.gp_stub->gs_un.gs_array;
g_traversal.c:        glist = owner_array->a_gp.gp_stub->gs_un.gs_glist;  
g_traversal.c:    if (argc && argv->a_type == A_SYMBOL)
g_traversal.c:        pd_typedmess(canvas, argv->a_w.w_symbol, argc-1, argv+1);
g_traversal.c:    else pd_error(x, "send-window: no message?");
g_traversal.c:    if (!gpointer_check(&x->x_gp, 1))
g_traversal.c:    templatesym = gpointer_gettemplatesym(&x->x_gp);
g_traversal.c:    for (n = x->x_ntypedout, to = x->x_typedout; n--; to++)
g_traversal.c:        if (to->to_type == templatesym)
g_traversal.c:            outlet_pointer(to->to_outlet, &x->x_gp);
g_traversal.c:    outlet_pointer(x->x_otherout, &x->x_gp);
g_traversal.c:    gpointer_unset(&x->x_gp);
g_traversal.c:    gpointer_copy(gp, &x->x_gp);
g_traversal.c:    if (!gpointer_check(&x->x_gp, 1))
g_traversal.c:    gs = x->x_gp.gp_stub;
g_traversal.c:    if (gs->gs_which != GP_GLIST)
g_traversal.c:    glist = gs->gs_un.gs_glist;  
g_traversal.c:    gpointer_setglist(&x->x_gp, glist, 0);
g_traversal.c:    freebytes(x->x_typedout, x->x_ntypedout * sizeof (*x->x_typedout));
g_traversal.c:    gpointer_unset(&x->x_gp);
g_traversal.c:        gensym("send-window"), A_GIMME, 0); 
g_traversal.c:/* ---------------------- get ----------------------------- */
g_traversal.c:    x->x_templatesym = canvas_makebindsym(atom_getsymbolarg(0, argc, argv));
g_traversal.c:    if (argc) argc--, argv++;
g_traversal.c:    x->x_variables
g_traversal.c:        = (t_getvariable *)getbytes(argc * sizeof (*x->x_variables));
g_traversal.c:    x->x_nout = argc;
g_traversal.c:    for (i = 0, sp = x->x_variables; i < argc; i++, sp++)
g_traversal.c:        sp->gv_sym = atom_getsymbolarg(i, argc, argv);
g_traversal.c:        sp->gv_outlet = outlet_new(&x->x_obj, 0);
g_traversal.c:    int nitems = x->x_nout, i;
g_traversal.c:    t_symbol *templatesym = x->x_templatesym;
g_traversal.c:    t_gstub *gs = gp->gp_stub;
g_traversal.c:        pd_error(x, "get: couldn't find template %s", templatesym->s_name);
g_traversal.c:    if (gs->gs_which == GP_ARRAY) vec = gp->gp_un.gp_w;
g_traversal.c:    else vec = gp->gp_un.gp_scalar->sc_vec;
g_traversal.c:    for (i = nitems - 1, vp = x->x_variables + i; i >= 0; i--, vp--)
g_traversal.c:        if (template_find_field(template, vp->gv_sym, &onset, &type, &arraytype))
g_traversal.c:                outlet_float(vp->gv_outlet,
g_traversal.c:                outlet_symbol(vp->gv_outlet,
g_traversal.c:                    template->t_sym->s_name, vp->gv_sym->s_name);
g_traversal.c:            template->t_sym->s_name, vp->gv_sym->s_name);
g_traversal.c:    freebytes(x->x_variables, x->x_nout * sizeof (*x->x_variables));
g_traversal.c:/* ---------------------- set ----------------------------- */
g_traversal.c:        !strcmp(argv[0].a_w.w_symbol->s_name, "-symbol"))
g_traversal.c:        x->x_issymbol = 1;
g_traversal.c:        argc--;
g_traversal.c:    else x->x_issymbol = 0;
g_traversal.c:    x->x_templatesym = canvas_makebindsym(atom_getsymbolarg(0, argc, argv));
g_traversal.c:    if (argc) argc--, argv++;
g_traversal.c:    x->x_variables
g_traversal.c:        = (t_setvariable *)getbytes(argc * sizeof (*x->x_variables));
g_traversal.c:    x->x_nin = argc;
g_traversal.c:        for (i = 0, sp = x->x_variables; i < argc; i++, sp++)
g_traversal.c:            sp->gv_sym = atom_getsymbolarg(i, argc, argv);
g_traversal.c:            if (x->x_issymbol)
g_traversal.c:                sp->gv_w.w_symbol = &s_;
g_traversal.c:            else sp->gv_w.w_float = 0;
g_traversal.c:                if (x->x_issymbol)
g_traversal.c:                    symbolinlet_new(&x->x_obj, &sp->gv_w.w_symbol);
g_traversal.c:                else floatinlet_new(&x->x_obj, &sp->gv_w.w_float);
g_traversal.c:    pointerinlet_new(&x->x_obj, &x->x_gp);
g_traversal.c:    gpointer_init(&x->x_gp);
g_traversal.c:    int nitems = x->x_nin, i;
g_traversal.c:    t_symbol *templatesym = x->x_templatesym;
g_traversal.c:    t_gpointer *gp = &x->x_gp;
g_traversal.c:    t_gstub *gs = gp->gp_stub;
g_traversal.c:        pd_error(x, "set: couldn't find template %s", templatesym->s_name);
g_traversal.c:    if (gpointer_gettemplatesym(gp) != x->x_templatesym)
g_traversal.c:            x->x_templatesym->s_name, gpointer_gettemplatesym(gp)->s_name);
g_traversal.c:    if (gs->gs_which == GP_ARRAY)
g_traversal.c:        vec = gp->gp_un.gp_w;
g_traversal.c:    else vec = gp->gp_un.gp_scalar->sc_vec;
g_traversal.c:    if (x->x_issymbol)
g_traversal.c:        for (i = 0, vp = x->x_variables; i < nitems; i++, vp++)
g_traversal.c:            template_setsymbol(template, vp->gv_sym, vec, vp->gv_w.w_symbol, 1);
g_traversal.c:    else for (i = 0, vp = x->x_variables; i < nitems; i++, vp++)
g_traversal.c:        template_setfloat(template, vp->gv_sym, vec, vp->gv_w.w_float, 1);
g_traversal.c:    if (gs->gs_which == GP_GLIST)
g_traversal.c:        scalar_redraw(gp->gp_un.gp_scalar, gs->gs_un.gs_glist);  
g_traversal.c:        t_array *owner_array = gs->gs_un.gs_array;
g_traversal.c:        while (owner_array->a_gp.gp_stub->gs_which == GP_ARRAY)
g_traversal.c:            owner_array = owner_array->a_gp.gp_stub->gs_un.gs_array;
g_traversal.c:        scalar_redraw(owner_array->a_gp.gp_un.gp_scalar,
g_traversal.c:            owner_array->a_gp.gp_stub->gs_un.gs_glist);  
g_traversal.c:    if (x->x_nin && !x->x_issymbol)
g_traversal.c:        x->x_variables[0].gv_w.w_float = f;
g_traversal.c:    if (x->x_nin && x->x_issymbol)
g_traversal.c:        x->x_variables[0].gv_w.w_symbol = s;
g_traversal.c:    freebytes(x->x_variables, x->x_nin * sizeof (*x->x_variables));
g_traversal.c:    gpointer_unset(&x->x_gp);
g_traversal.c:/* ---------------------- elem ----------------------------- */
g_traversal.c:    x->x_templatesym = canvas_makebindsym(templatesym);
g_traversal.c:    x->x_fieldsym = fieldsym;
g_traversal.c:    gpointer_init(&x->x_gp);
g_traversal.c:    gpointer_init(&x->x_gparent);
g_traversal.c:    pointerinlet_new(&x->x_obj, &x->x_gparent);
g_traversal.c:    outlet_new(&x->x_obj, &s_pointer);
g_traversal.c:    t_symbol *templatesym = x->x_templatesym, *fieldsym = x->x_fieldsym,
g_traversal.c:    t_gpointer *gparent = &x->x_gparent;
g_traversal.c:    if (gpointer_gettemplatesym(gparent) != x->x_templatesym)
g_traversal.c:            x->x_templatesym->s_name, gpointer_gettemplatesym(gparent)->s_name);
g_traversal.c:    if (gparent->gp_stub->gs_which == GP_ARRAY) w = gparent->gp_un.gp_w;
g_traversal.c:    else w = gparent->gp_un.gp_scalar->sc_vec;
g_traversal.c:        pd_error(x, "element: couldn't find template %s", templatesym->s_name);
g_traversal.c:        pd_error(x, "element: couldn't find array field %s", fieldsym->s_name);
g_traversal.c:        pd_error(x, "element: field %s not of type array", fieldsym->s_name);
g_traversal.c:            elemtemplatesym->s_name);
g_traversal.c:    elemsize = elemtemplate->t_n * sizeof(t_word);
g_traversal.c:    nitems = array->a_n;
g_traversal.c:    if (indx >= nitems) indx = nitems-1;
g_traversal.c:    gpointer_setarray(&x->x_gp, array, 
g_traversal.c:        (t_word *)((char *)(array->a_vec) + indx * elemsize));
g_traversal.c:    outlet_pointer(x->x_obj.ob_outlet, &x->x_gp);
g_traversal.c:    gpointer_unset(&x->x_gp);
g_traversal.c:    gpointer_unset(&x->x_gparent);
g_traversal.c:/* ---------------------- getsize ----------------------------- */
g_traversal.c:    x->x_templatesym = canvas_makebindsym(templatesym);
g_traversal.c:    x->x_fieldsym = fieldsym;
g_traversal.c:    outlet_new(&x->x_obj, &s_float);
g_traversal.c:    t_symbol *templatesym = x->x_templatesym, *fieldsym = x->x_fieldsym,
g_traversal.c:    t_gstub *gs = gp->gp_stub;
g_traversal.c:        pd_error(x, "getsize: couldn't find template %s", templatesym->s_name);
g_traversal.c:        pd_error(x, "getsize: couldn't find array field %s", fieldsym->s_name);
g_traversal.c:        pd_error(x, "getsize: field %s not of type array", fieldsym->s_name);
g_traversal.c:    if (gpointer_gettemplatesym(gp) != x->x_templatesym)
g_traversal.c:            x->x_templatesym->s_name, gpointer_gettemplatesym(gp)->s_name);
g_traversal.c:    if (gs->gs_which == GP_ARRAY) w = gp->gp_un.gp_w;
g_traversal.c:    else w = gp->gp_un.gp_scalar->sc_vec;
g_traversal.c:    outlet_float(x->x_obj.ob_outlet, (t_float)(array->a_n));
g_traversal.c:/* ---------------------- setsize ----------------------------- */
g_traversal.c:    x->x_templatesym = canvas_makebindsym(templatesym);
g_traversal.c:    x->x_fieldsym = fieldsym;
g_traversal.c:    gpointer_init(&x->x_gp);
g_traversal.c:    pointerinlet_new(&x->x_obj, &x->x_gp);
g_traversal.c:    t_symbol *templatesym = x->x_templatesym, *fieldsym = x->x_fieldsym,
g_traversal.c:    t_gpointer *gp = &x->x_gp;
g_traversal.c:    t_gstub *gs = gp->gp_stub;
g_traversal.c:    if (!gpointer_check(&x->x_gp, 0))
g_traversal.c:    if (gpointer_gettemplatesym(&x->x_gp) != x->x_templatesym)
g_traversal.c:            x->x_templatesym->s_name,
g_traversal.c:                gpointer_gettemplatesym(&x->x_gp)->s_name);
g_traversal.c:    if (gs->gs_which == GP_ARRAY) w = gp->gp_un.gp_w;
g_traversal.c:    else w = gp->gp_un.gp_scalar->sc_vec;
g_traversal.c:        pd_error(x,"setsize: couldn't find template %s", templatesym->s_name);
g_traversal.c:        pd_error(x,"setsize: couldn't find array field %s", fieldsym->s_name);
g_traversal.c:        pd_error(x,"setsize: field %s not of type array", fieldsym->s_name);
g_traversal.c:            elemtemplatesym->s_name);
g_traversal.c:    elemsize = elemtemplate->t_n * sizeof(t_word);
g_traversal.c:    if (elemsize != array->a_elemsize) bug("setsize_gpointer");
g_traversal.c:    nitems = array->a_n;
g_traversal.c:    if (gs->gs_which == GP_GLIST)
g_traversal.c:        if (glist_isvisible(gs->gs_un.gs_glist))
g_traversal.c:            gobj_vis((t_gobj *)(gp->gp_un.gp_scalar), gs->gs_un.gs_glist, 0);  
g_traversal.c:        t_array *owner_array = gs->gs_un.gs_array;
g_traversal.c:        while (owner_array->a_gp.gp_stub->gs_which == GP_ARRAY)
g_traversal.c:            owner_array = owner_array->a_gp.gp_stub->gs_un.gs_array;
g_traversal.c:        if (glist_isvisible(owner_array->a_gp.gp_stub->gs_un.gs_glist))
g_traversal.c:            gobj_vis((t_gobj *)(owner_array->a_gp.gp_un.gp_scalar),
g_traversal.c:                owner_array->a_gp.gp_stub->gs_un.gs_glist, 0);  
g_traversal.c:    array->a_vec = (char *)resizebytes(array->a_vec,
g_traversal.c:    array->a_n = newsize;
g_traversal.c:        char *newelem = ((char *)array->a_vec) + nitems * elemsize;
g_traversal.c:        int i = 0, nnew = newsize - nitems;
g_traversal.c:        while (nnew--)
g_traversal.c:    if (gs->gs_which == GP_GLIST)
g_traversal.c:        if (glist_isvisible(gs->gs_un.gs_glist))
g_traversal.c:            gobj_vis((t_gobj *)(gp->gp_un.gp_scalar), gs->gs_un.gs_glist, 1);  
g_traversal.c:        t_array *owner_array = gs->gs_un.gs_array;
g_traversal.c:        while (owner_array->a_gp.gp_stub->gs_which == GP_ARRAY)
g_traversal.c:            owner_array = owner_array->a_gp.gp_stub->gs_un.gs_array;
g_traversal.c:        if (glist_isvisible(owner_array->a_gp.gp_stub->gs_un.gs_glist))
g_traversal.c:            gobj_vis((t_gobj *)(owner_array->a_gp.gp_un.gp_scalar),
g_traversal.c:                owner_array->a_gp.gp_stub->gs_un.gs_glist, 1);  
g_traversal.c:    gpointer_unset(&x->x_gp);
g_traversal.c:/* ---------------------- append ----------------------------- */
g_traversal.c:    x->x_templatesym = canvas_makebindsym(atom_getsymbolarg(0, argc, argv));
g_traversal.c:    if (argc) argc--, argv++;
g_traversal.c:    x->x_variables
g_traversal.c:        = (t_appendvariable *)getbytes(argc * sizeof (*x->x_variables));
g_traversal.c:    x->x_nin = argc;
g_traversal.c:        for (i = 0, sp = x->x_variables; i < argc; i++, sp++)
g_traversal.c:            sp->gv_sym = atom_getsymbolarg(i, argc, argv);
g_traversal.c:            sp->gv_f = 0;
g_traversal.c:            if (i) floatinlet_new(&x->x_obj, &sp->gv_f);
g_traversal.c:    pointerinlet_new(&x->x_obj, &x->x_gp);
g_traversal.c:    outlet_new(&x->x_obj, &s_pointer);
g_traversal.c:    gpointer_init(&x->x_gp);
g_traversal.c:    int nitems = x->x_nin, i;
g_traversal.c:    t_symbol *templatesym = x->x_templatesym;
g_traversal.c:    t_gpointer *gp = &x->x_gp;
g_traversal.c:    t_gstub *gs = gp->gp_stub;
g_traversal.c:        pd_error(x, "append: couldn't find template %s", templatesym->s_name);
g_traversal.c:    if (gs->gs_which != GP_GLIST)
g_traversal.c:    glist = gs->gs_un.gs_glist;
g_traversal.c:    if (glist->gl_valid != gp->gp_valid)
g_traversal.c:    x->x_variables[0].gv_f = f;
g_traversal.c:        pd_error(x, "%s: couldn't create scalar", templatesym->s_name);
g_traversal.c:    oldsc = gp->gp_un.gp_scalar;
g_traversal.c:        sc->sc_gobj.g_next = oldsc->sc_gobj.g_next;
g_traversal.c:        oldsc->sc_gobj.g_next = &sc->sc_gobj;
g_traversal.c:        sc->sc_gobj.g_next = glist->gl_list;
g_traversal.c:        glist->gl_list = &sc->sc_gobj;
g_traversal.c:    gp->gp_un.gp_scalar = sc;
g_traversal.c:    vec = sc->sc_vec;
g_traversal.c:    for (i = 0, vp = x->x_variables; i < nitems; i++, vp++)
g_traversal.c:        template_setfloat(template, vp->gv_sym, vec, vp->gv_f, 1);
g_traversal.c:        gobj_vis(&sc->sc_gobj, glist, 1);
g_traversal.c:    outlet_pointer(x->x_obj.ob_outlet, gp);
g_traversal.c:    freebytes(x->x_variables, x->x_nin * sizeof (*x->x_variables));
g_traversal.c:    gpointer_unset(&x->x_gp);
g_traversal.c:/* ---------------------- sublist ----------------------------- */
g_traversal.c:    x->x_templatesym = canvas_makebindsym(templatesym);
g_traversal.c:    x->x_fieldsym = fieldsym;
g_traversal.c:    gpointer_init(&x->x_gp);
g_traversal.c:    outlet_new(&x->x_obj, &s_pointer);
g_traversal.c:    t_symbol *templatesym = x->x_templatesym, *dummy;
g_traversal.c:    t_gstub *gs = gp->gp_stub;
g_traversal.c:        pd_error(x, "sublist: couldn't find template %s", templatesym->s_name);
g_traversal.c:    if (!template_find_field(template, x->x_fieldsym,
g_traversal.c:        pd_error(x, "sublist: couldn't find field %s", x->x_fieldsym->s_name);
g_traversal.c:        pd_error(x, "sublist: field %s not of type list", x->x_fieldsym->s_name);
g_traversal.c:    if (gs->gs_which == GP_ARRAY) w = gp->gp_un.gp_w;
g_traversal.c:    else w = gp->gp_un.gp_scalar->sc_vec;
g_traversal.c:    gpointer_setglist(&x->x_gp, *(t_glist **)(((char *)w) + onset), 0);
g_traversal.c:    outlet_pointer(x->x_obj.ob_outlet, &x->x_gp);
g_traversal.c:    gpointer_unset(&x->x_gp);
g_traversal.c:/* ----------------- setup function ------------------- */
g_vdial.c:/* Copyright (c) 1997-1999 Miller Puckette.
g_vdial.c:/* vdial.c written by Thomas Musil (c) IEM KUG Graz Austria 2000-2001 */
g_vdial.c:/*------------------ global variables -------------------------*/
g_vdial.c:/*------------------ global functions -------------------------*/
g_vdial.c:/* ------------- vdl     gui-vertical radio button ---------------------- */
g_vdial.c:        sys_vgui(".x%lx.c itemconfigure %lxBUT%d -fill #%6.6x -outline #%6.6x\n",
g_vdial.c:                 canvas, x, x->x_drawn,
g_vdial.c:                 x->x_gui.x_bcol, x->x_gui.x_bcol);
g_vdial.c:        sys_vgui(".x%lx.c itemconfigure %lxBUT%d -fill #%6.6x -outline #%6.6x\n",
g_vdial.c:                 canvas, x, x->x_on,
g_vdial.c:                 x->x_gui.x_fcol, x->x_gui.x_fcol);
g_vdial.c:        x->x_drawn = x->x_on;
g_vdial.c:    int n=x->x_number, i, dy=x->x_gui.x_h, s4=dy/4;
g_vdial.c:    int yy11b=text_ypix(&x->x_gui.x_obj, glist); 
g_vdial.c:    int yy21=yy11+s4, yy22=yy12-s4;
g_vdial.c:    int xx11=text_xpix(&x->x_gui.x_obj, glist), xx12=xx11+dy;
g_vdial.c:    int xx21=xx11+s4, xx22=xx12-s4;
g_vdial.c:        sys_vgui(".x%lx.c create rectangle %d %d %d %d -fill #%6.6x -tags %lxBASE%d\n",
g_vdial.c:                 x->x_gui.x_bcol, x, i);
g_vdial.c:        sys_vgui(".x%lx.c create rectangle %d %d %d %d -fill #%6.6x -outline #%6.6x -tags %lxBUT%d\n",
g_vdial.c:                 (x->x_on==i)?x->x_gui.x_fcol:x->x_gui.x_bcol,
g_vdial.c:                 (x->x_on==i)?x->x_gui.x_fcol:x->x_gui.x_bcol, x, i);
g_vdial.c:        x->x_drawn = x->x_on;
g_vdial.c:    sys_vgui(".x%lx.c create text %d %d -text {%s} -anchor w \
g_vdial.c:             -font {{%s} -%d %s} -fill #%6.6x -tags [list %lxLABEL label text]\n",
g_vdial.c:             canvas, xx11+x->x_gui.x_ldx, yy11b+x->x_gui.x_ldy,
g_vdial.c:             strcmp(x->x_gui.x_lab->s_name, "empty")?x->x_gui.x_lab->s_name:"",
g_vdial.c:             x->x_gui.x_font, x->x_gui.x_fontsize, sys_fontweight,
g_vdial.c:             x->x_gui.x_lcol, x);
g_vdial.c:    if(!x->x_gui.x_fsf.x_snd_able)
g_vdial.c:        sys_vgui(".x%lx.c create rectangle %d %d %d %d -tags [list %lxOUT%d outlet]\n",
g_vdial.c:             canvas, xx11, yy11-1, xx11 + IOWIDTH, yy11, x, 0);
g_vdial.c:    if(!x->x_gui.x_fsf.x_rcv_able)
g_vdial.c:        sys_vgui(".x%lx.c create rectangle %d %d %d %d -tags [list %lxIN%d inlet]\n",
g_vdial.c:    int n=x->x_number, i, dy=x->x_gui.x_h, s4=dy/4;
g_vdial.c:    int yy11b=text_ypix(&x->x_gui.x_obj, glist);
g_vdial.c:    int yy21=yy11+s4, yy22=yy12-s4;
g_vdial.c:    int xx11=text_xpix(&x->x_gui.x_obj, glist), xx12=xx11+dy;
g_vdial.c:    int xx21=xx11+s4, xx22=xx12-s4;
g_vdial.c:             canvas, x, xx11+x->x_gui.x_ldx, yy11b+x->x_gui.x_ldy);
g_vdial.c:    if(!x->x_gui.x_fsf.x_snd_able)
g_vdial.c:             canvas, x, 0, xx11, yy11-1, xx11 + IOWIDTH, yy11);
g_vdial.c:    if(!x->x_gui.x_fsf.x_rcv_able)
g_vdial.c:    int n=x->x_number, i;
g_vdial.c:    if(!x->x_gui.x_fsf.x_snd_able)
g_vdial.c:    if(!x->x_gui.x_fsf.x_rcv_able)
g_vdial.c:    int n=x->x_number, i;
g_vdial.c:    sys_vgui(".x%lx.c itemconfigure %lxLABEL -font {{%s} -%d %s} -fill #%6.6x -text {%s} \n",
g_vdial.c:             canvas, x, x->x_gui.x_font, x->x_gui.x_fontsize, sys_fontweight, 
g_vdial.c:             x->x_gui.x_fsf.x_selected?IEM_GUI_COLOR_SELECTED:x->x_gui.x_lcol,
g_vdial.c:             strcmp(x->x_gui.x_lab->s_name, "empty")?x->x_gui.x_lab->s_name:"");
g_vdial.c:        sys_vgui(".x%lx.c itemconfigure %lxBASE%d -fill #%6.6x\n", canvas, x, i,
g_vdial.c:                 x->x_gui.x_bcol);
g_vdial.c:        sys_vgui(".x%lx.c itemconfigure %lxBUT%d -fill #%6.6x -outline #%6.6x\n", canvas, x, i,
g_vdial.c:                 (x->x_on==i)?x->x_gui.x_fcol:x->x_gui.x_bcol,
g_vdial.c:                 (x->x_on==i)?x->x_gui.x_fcol:x->x_gui.x_bcol);
g_vdial.c:    int xpos=text_xpix(&x->x_gui.x_obj, glist);
g_vdial.c:    int ypos=text_ypix(&x->x_gui.x_obj, glist);
g_vdial.c:    if((old_snd_rcv_flags & IEM_GUI_OLD_SND_FLAG) && !x->x_gui.x_fsf.x_snd_able)
g_vdial.c:        sys_vgui(".x%lx.c create rectangle %d %d %d %d -tags %lxOUT%d\n",
g_vdial.c:                 ypos+(x->x_number*x->x_gui.x_h)-1,
g_vdial.c:                 ypos+(x->x_number*x->x_gui.x_h), x, 0);
g_vdial.c:    if(!(old_snd_rcv_flags & IEM_GUI_OLD_SND_FLAG) && x->x_gui.x_fsf.x_snd_able)
g_vdial.c:    if((old_snd_rcv_flags & IEM_GUI_OLD_RCV_FLAG) && !x->x_gui.x_fsf.x_rcv_able)
g_vdial.c:        sys_vgui(".x%lx.c create rectangle %d %d %d %d -tags %lxIN%d\n",
g_vdial.c:    if(!(old_snd_rcv_flags & IEM_GUI_OLD_RCV_FLAG) && x->x_gui.x_fsf.x_rcv_able)
g_vdial.c:    int n=x->x_number, i;
g_vdial.c:    if(x->x_gui.x_fsf.x_selected)
g_vdial.c:            sys_vgui(".x%lx.c itemconfigure %lxBASE%d -outline #%6.6x\n", canvas, x, i,
g_vdial.c:        sys_vgui(".x%lx.c itemconfigure %lxLABEL -fill #%6.6x\n", canvas, x, IEM_GUI_COLOR_SELECTED);
g_vdial.c:            sys_vgui(".x%lx.c itemconfigure %lxBASE%d -outline #%6.6x\n", canvas, x, i,
g_vdial.c:        sys_vgui(".x%lx.c itemconfigure %lxLABEL -fill #%6.6x\n", canvas, x,
g_vdial.c:                 x->x_gui.x_lcol);
g_vdial.c:        vradio_draw_io(x, glist, mode - IEM_GUI_DRAW_MODE_IO);
g_vdial.c:/* ------------------------ vdl widgetbehaviour----------------------------- */
g_vdial.c:    *xp1 = text_xpix(&x->x_gui.x_obj, glist);
g_vdial.c:    *yp1 = text_ypix(&x->x_gui.x_obj, glist);
g_vdial.c:    *xp2 = *xp1 + x->x_gui.x_w;
g_vdial.c:    *yp2 = *yp1 + x->x_gui.x_h*x->x_number;
g_vdial.c:    iemgui_save(&x->x_gui, srl, bflcol);
g_vdial.c:                (int)x->x_gui.x_obj.te_xpix,
g_vdial.c:                (int)x->x_gui.x_obj.te_ypix,
g_vdial.c:                (pd_class(&x->x_gui.x_obj.ob_pd) == vradio_old_class ?
g_vdial.c:                x->x_gui.x_w,
g_vdial.c:                x->x_change, iem_symargstoint(&x->x_gui.x_isa), x->x_number,
g_vdial.c:                x->x_gui.x_ldx, x->x_gui.x_ldy,
g_vdial.c:                iem_fstyletoint(&x->x_gui.x_fsf), x->x_gui.x_fontsize,
g_vdial.c:                bflcol[0], bflcol[1], bflcol[2], x->x_on);
g_vdial.c:    int hchange=-1;
g_vdial.c:    iemgui_properties(&x->x_gui, srl);
g_vdial.c:    if(pd_class(&x->x_gui.x_obj.ob_pd) == vradio_old_class)
g_vdial.c:        hchange = x->x_change;
g_vdial.c:            ----------dimensions(pix):----------- %d %d size: 0 0 empty \
g_vdial.c:            %d new-only new&old %d %d number: %d \
g_vdial.c:            x->x_gui.x_w, IEM_GUI_MINSIZE,
g_vdial.c:            hchange, x->x_gui.x_isa.x_loadinit, -1, x->x_number,
g_vdial.c:            srl[0]->s_name, srl[1]->s_name,
g_vdial.c:            srl[2]->s_name, x->x_gui.x_ldx, x->x_gui.x_ldy,
g_vdial.c:            x->x_gui.x_fsf.x_font_style, x->x_gui.x_fontsize,
g_vdial.c:            0xffffff & x->x_gui.x_bcol, 0xffffff & x->x_gui.x_fcol, 0xffffff & x->x_gui.x_lcol);
g_vdial.c:    gfxstub_new(&x->x_gui.x_obj.ob_pd, x, buf);
g_vdial.c:    x->x_change = chg;
g_vdial.c:    sr_flags = iemgui_dialog(&x->x_gui, srl, argc, argv);
g_vdial.c:    x->x_gui.x_w = iemgui_clip_size(a);
g_vdial.c:    x->x_gui.x_h = x->x_gui.x_w;
g_vdial.c:    if(x->x_number != num)
g_vdial.c:        (*x->x_gui.x_draw)(x, x->x_gui.x_glist, IEM_GUI_DRAW_MODE_ERASE);
g_vdial.c:        x->x_number = num;
g_vdial.c:        if(x->x_on >= x->x_number)
g_vdial.c:            x->x_on = x->x_number - 1;
g_vdial.c:            x->x_on_old = x->x_on;
g_vdial.c:        (*x->x_gui.x_draw)(x, x->x_gui.x_glist, IEM_GUI_DRAW_MODE_NEW);
g_vdial.c:        (*x->x_gui.x_draw)(x, x->x_gui.x_glist, IEM_GUI_DRAW_MODE_CONFIG);
g_vdial.c:        (*x->x_gui.x_draw)(x, x->x_gui.x_glist, IEM_GUI_DRAW_MODE_IO + sr_flags);
g_vdial.c:        (*x->x_gui.x_draw)(x, x->x_gui.x_glist, IEM_GUI_DRAW_MODE_MOVE);
g_vdial.c:        canvas_fixlinesfor(x->x_gui.x_glist, (t_text*)x);
g_vdial.c:    if(i >= x->x_number)
g_vdial.c:        i = x->x_number-1;
g_vdial.c:    if(x->x_on != x->x_on_old)
g_vdial.c:        old = x->x_on_old;
g_vdial.c:        x->x_on_old = x->x_on;
g_vdial.c:        x->x_on = i;
g_vdial.c:        (*x->x_gui.x_draw)(x, x->x_gui.x_glist, IEM_GUI_DRAW_MODE_UPDATE);
g_vdial.c:        x->x_on_old = old;
g_vdial.c:        x->x_on = i;
g_vdial.c:        (*x->x_gui.x_draw)(x, x->x_gui.x_glist, IEM_GUI_DRAW_MODE_UPDATE);
g_vdial.c:    if (pd_class(&x->x_gui.x_obj.ob_pd) == vradio_old_class)
g_vdial.c:        if((x->x_change)&&(x->x_on != x->x_on_old))
g_vdial.c:            SETFLOAT(x->x_at, (t_float)x->x_on_old);
g_vdial.c:            SETFLOAT(x->x_at+1, 0.0);
g_vdial.c:            outlet_list(x->x_gui.x_obj.ob_outlet, &s_list, 2, x->x_at);
g_vdial.c:            if(x->x_gui.x_fsf.x_snd_able && x->x_gui.x_snd->s_thing)
g_vdial.c:                pd_list(x->x_gui.x_snd->s_thing, &s_list, 2, x->x_at);
g_vdial.c:        x->x_on_old = x->x_on;
g_vdial.c:        SETFLOAT(x->x_at, (t_float)x->x_on);
g_vdial.c:        SETFLOAT(x->x_at+1, 1.0);
g_vdial.c:        outlet_list(x->x_gui.x_obj.ob_outlet, &s_list, 2, x->x_at);
g_vdial.c:        if(x->x_gui.x_fsf.x_snd_able && x->x_gui.x_snd->s_thing)
g_vdial.c:            pd_list(x->x_gui.x_snd->s_thing, &s_list, 2, x->x_at);
g_vdial.c:        outlet_float(x->x_gui.x_obj.ob_outlet, x->x_on);
g_vdial.c:        if(x->x_gui.x_fsf.x_snd_able && x->x_gui.x_snd->s_thing)
g_vdial.c:            pd_float(x->x_gui.x_snd->s_thing, x->x_on);
g_vdial.c:    if(i >= x->x_number)
g_vdial.c:        i = x->x_number-1;
g_vdial.c:    if (pd_class(&x->x_gui.x_obj.ob_pd) == vradio_old_class)
g_vdial.c:        if((x->x_change)&&(i != x->x_on_old))
g_vdial.c:            SETFLOAT(x->x_at, (t_float)x->x_on_old);
g_vdial.c:            SETFLOAT(x->x_at+1, 0.0);
g_vdial.c:            outlet_list(x->x_gui.x_obj.ob_outlet, &s_list, 2, x->x_at);
g_vdial.c:            if(x->x_gui.x_fsf.x_snd_able && x->x_gui.x_snd->s_thing)
g_vdial.c:                pd_list(x->x_gui.x_snd->s_thing, &s_list, 2, x->x_at);
g_vdial.c:        if(x->x_on != x->x_on_old)
g_vdial.c:            x->x_on_old = x->x_on;
g_vdial.c:        x->x_on = i;
g_vdial.c:        (*x->x_gui.x_draw)(x, x->x_gui.x_glist, IEM_GUI_DRAW_MODE_UPDATE);
g_vdial.c:        x->x_on_old = x->x_on;
g_vdial.c:        SETFLOAT(x->x_at, (t_float)x->x_on);
g_vdial.c:        SETFLOAT(x->x_at+1, 1.0);
g_vdial.c:        outlet_list(x->x_gui.x_obj.ob_outlet, &s_list, 2, x->x_at);
g_vdial.c:        if(x->x_gui.x_fsf.x_snd_able && x->x_gui.x_snd->s_thing)
g_vdial.c:            pd_list(x->x_gui.x_snd->s_thing, &s_list, 2, x->x_at);
g_vdial.c:        x->x_on_old = x->x_on;
g_vdial.c:        x->x_on = i;
g_vdial.c:        (*x->x_gui.x_draw)(x, x->x_gui.x_glist, IEM_GUI_DRAW_MODE_UPDATE);
g_vdial.c:        outlet_float(x->x_gui.x_obj.ob_outlet, x->x_on);
g_vdial.c:        if (x->x_gui.x_fsf.x_snd_able && x->x_gui.x_snd->s_thing)
g_vdial.c:            pd_float(x->x_gui.x_snd->s_thing, x->x_on);
g_vdial.c:    if(i >= x->x_number)
g_vdial.c:        i = x->x_number-1;
g_vdial.c:    if (pd_class(&x->x_gui.x_obj.ob_pd) == vradio_old_class)
g_vdial.c:        if((x->x_change)&&(i != x->x_on_old))
g_vdial.c:            if(x->x_gui.x_fsf.x_put_in2out)
g_vdial.c:                SETFLOAT(x->x_at, (t_float)x->x_on_old);
g_vdial.c:                SETFLOAT(x->x_at+1, 0.0);
g_vdial.c:                outlet_list(x->x_gui.x_obj.ob_outlet, &s_list, 2, x->x_at);
g_vdial.c:                if(x->x_gui.x_fsf.x_snd_able && x->x_gui.x_snd->s_thing)
g_vdial.c:                    pd_list(x->x_gui.x_snd->s_thing, &s_list, 2, x->x_at);
g_vdial.c:        if(x->x_on != x->x_on_old)
g_vdial.c:            x->x_on_old = x->x_on;
g_vdial.c:        x->x_on = i;
g_vdial.c:        (*x->x_gui.x_draw)(x, x->x_gui.x_glist, IEM_GUI_DRAW_MODE_UPDATE);
g_vdial.c:        x->x_on_old = x->x_on;
g_vdial.c:        if(x->x_gui.x_fsf.x_put_in2out)
g_vdial.c:            SETFLOAT(x->x_at, (t_float)x->x_on);
g_vdial.c:            SETFLOAT(x->x_at+1, 1.0);
g_vdial.c:            outlet_list(x->x_gui.x_obj.ob_outlet, &s_list, 2, x->x_at);
g_vdial.c:            if(x->x_gui.x_fsf.x_snd_able && x->x_gui.x_snd->s_thing)
g_vdial.c:                pd_list(x->x_gui.x_snd->s_thing, &s_list, 2, x->x_at);
g_vdial.c:        x->x_on_old = x->x_on;
g_vdial.c:        x->x_on = i;
g_vdial.c:        (*x->x_gui.x_draw)(x, x->x_gui.x_glist, IEM_GUI_DRAW_MODE_UPDATE);
g_vdial.c:        if (x->x_gui.x_fsf.x_put_in2out)
g_vdial.c:            outlet_float(x->x_gui.x_obj.ob_outlet, x->x_on);
g_vdial.c:            if(x->x_gui.x_fsf.x_snd_able && x->x_gui.x_snd->s_thing)
g_vdial.c:                pd_float(x->x_gui.x_snd->s_thing, x->x_on);
g_vdial.c:    int yy =  (int)ypos - text_ypix(&x->x_gui.x_obj, x->x_gui.x_glist);
g_vdial.c:    vradio_fout(x, (t_float)(yy / x->x_gui.x_h));
g_vdial.c:    if(!sys_noloadbang && x->x_gui.x_isa.x_loadinit)
g_vdial.c:    if(n != x->x_number)
g_vdial.c:        (*x->x_gui.x_draw)(x, x->x_gui.x_glist, IEM_GUI_DRAW_MODE_ERASE);
g_vdial.c:        x->x_number = n;
g_vdial.c:        if(x->x_on >= x->x_number)
g_vdial.c:            x->x_on = x->x_number - 1;
g_vdial.c:        x->x_on_old = x->x_on;
g_vdial.c:        (*x->x_gui.x_draw)(x, x->x_gui.x_glist, IEM_GUI_DRAW_MODE_NEW);
g_vdial.c:    x->x_gui.x_w = iemgui_clip_size((int)atom_getintarg(0, ac, av));
g_vdial.c:    x->x_gui.x_h = x->x_gui.x_w;
g_vdial.c:    iemgui_size((void *)x, &x->x_gui);
g_vdial.c:{iemgui_delta((void *)x, &x->x_gui, s, ac, av);}
g_vdial.c:{iemgui_pos((void *)x, &x->x_gui, s, ac, av);}
g_vdial.c:{iemgui_color((void *)x, &x->x_gui, s, ac, av);}
g_vdial.c:{iemgui_send(x, &x->x_gui, s);}
g_vdial.c:{iemgui_receive(x, &x->x_gui, s);}
g_vdial.c:{iemgui_label((void *)x, &x->x_gui, s);}
g_vdial.c:{iemgui_label_pos((void *)x, &x->x_gui, s, ac, av);}
g_vdial.c:{iemgui_label_font((void *)x, &x->x_gui, s, ac, av);}
g_vdial.c:    x->x_gui.x_isa.x_loadinit = (f==0.0)?0:1;
g_vdial.c:{x->x_change = 1;}
g_vdial.c:{x->x_change = 0;}
g_vdial.c:    int bflcol[]={-262144, -1, -1};
g_vdial.c:    int ldx=0, ldy=-8, chg=1, num=8;
g_vdial.c:        iem_inttosymargs(&x->x_gui.x_isa, atom_getintarg(2, argc, argv));
g_vdial.c:        iemgui_new_getnames(&x->x_gui, 4, argv);
g_vdial.c:        iem_inttofstyle(&x->x_gui.x_fsf, atom_getintarg(9, argc, argv));
g_vdial.c:    else iemgui_new_getnames(&x->x_gui, 4, 0);
g_vdial.c:    x->x_gui.x_draw = (t_iemfunptr)vradio_draw;
g_vdial.c:    x->x_gui.x_fsf.x_snd_able = 1;
g_vdial.c:    x->x_gui.x_fsf.x_rcv_able = 1;
g_vdial.c:    x->x_gui.x_glist = (t_glist *)canvas_getcurrent();
g_vdial.c:    if (!strcmp(x->x_gui.x_snd->s_name, "empty"))
g_vdial.c:        x->x_gui.x_fsf.x_snd_able = 0;
g_vdial.c:    if (!strcmp(x->x_gui.x_rcv->s_name, "empty"))
g_vdial.c:        x->x_gui.x_fsf.x_rcv_able = 0;
g_vdial.c:    if(x->x_gui.x_fsf.x_font_style == 1) strcpy(x->x_gui.x_font, "helvetica");
g_vdial.c:    else if(x->x_gui.x_fsf.x_font_style == 2) strcpy(x->x_gui.x_font, "times");
g_vdial.c:    else { x->x_gui.x_fsf.x_font_style = 0;
g_vdial.c:        strcpy(x->x_gui.x_font, sys_font); }
g_vdial.c:    x->x_number = num;
g_vdial.c:    if(on >= x->x_number)
g_vdial.c:        on = x->x_number - 1;
g_vdial.c:    if(x->x_gui.x_isa.x_loadinit)
g_vdial.c:        x->x_on = on;
g_vdial.c:        x->x_on = 0;
g_vdial.c:    x->x_on_old = x->x_on;
g_vdial.c:    x->x_change = (chg==0)?0:1;
g_vdial.c:    if (x->x_gui.x_fsf.x_rcv_able)
g_vdial.c:        pd_bind(&x->x_gui.x_obj.ob_pd, x->x_gui.x_rcv);
g_vdial.c:    x->x_gui.x_ldx = ldx;
g_vdial.c:    x->x_gui.x_ldy = ldy;
g_vdial.c:    x->x_gui.x_fontsize = fs;
g_vdial.c:    x->x_gui.x_w = iemgui_clip_size(a);
g_vdial.c:    x->x_gui.x_h = x->x_gui.x_w;
g_vdial.c:    iemgui_verify_snd_ne_rcv(&x->x_gui);
g_vdial.c:    iemgui_all_colfromload(&x->x_gui, bflcol);
g_vdial.c:    outlet_new(&x->x_gui.x_obj, &s_list);
g_vdial.c:    if(x->x_gui.x_fsf.x_rcv_able)
g_vdial.c:        pd_unbind(&x->x_gui.x_obj.ob_pd, x->x_gui.x_rcv);
g_vdial.c:        /* obsolete version (0.34-0.35) */
g_vslider.c:/* Copyright (c) 1997-1999 Miller Puckette.
g_vslider.c:/* g_7_guis.c written by Thomas Musil (c) IEM KUG Graz Austria 2000-2001 */
g_vslider.c:/* ------------ vsl gui-vertical  slider ----------------------- */
g_vslider.c:        int r = text_ypix(&x->x_gui.x_obj, glist) + x->x_gui.x_h - (x->x_val + 50)/100;
g_vslider.c:        int xpos=text_xpix(&x->x_gui.x_obj, glist);
g_vslider.c:                 xpos + x->x_gui.x_w, r);
g_vslider.c:    int xpos=text_xpix(&x->x_gui.x_obj, glist);
g_vslider.c:    int ypos=text_ypix(&x->x_gui.x_obj, glist);
g_vslider.c:    int r = ypos + x->x_gui.x_h - (x->x_val + 50)/100;
g_vslider.c:    sys_vgui(".x%lx.c create rectangle %d %d %d %d -fill #%6.6x -tags %lxBASE\n",
g_vslider.c:             canvas, xpos, ypos-2,
g_vslider.c:             xpos + x->x_gui.x_w, ypos + x->x_gui.x_h+3,
g_vslider.c:             x->x_gui.x_bcol, x);
g_vslider.c:    sys_vgui(".x%lx.c create line %d %d %d %d -width 3 -fill #%6.6x -tags %lxKNOB\n",
g_vslider.c:             xpos + x->x_gui.x_w, r, x->x_gui.x_fcol, x);
g_vslider.c:    sys_vgui(".x%lx.c create text %d %d -text {%s} -anchor w \
g_vslider.c:             -font {{%s} -%d %s} -fill #%6.6x -tags [list %lxLABEL label text]\n",
g_vslider.c:             canvas, xpos+x->x_gui.x_ldx, ypos+x->x_gui.x_ldy,
g_vslider.c:             strcmp(x->x_gui.x_lab->s_name, "empty")?x->x_gui.x_lab->s_name:"",
g_vslider.c:             x->x_gui.x_font, x->x_gui.x_fontsize, sys_fontweight, 
g_vslider.c:             x->x_gui.x_lcol, x);
g_vslider.c:    if(!x->x_gui.x_fsf.x_snd_able)
g_vslider.c:        sys_vgui(".x%lx.c create rectangle %d %d %d %d -tags [list %lxOUT%d outlet]\n",
g_vslider.c:             xpos, ypos + x->x_gui.x_h+2,
g_vslider.c:             xpos+7, ypos + x->x_gui.x_h+3,
g_vslider.c:    if(!x->x_gui.x_fsf.x_rcv_able)
g_vslider.c:        sys_vgui(".x%lx.c create rectangle %d %d %d %d -tags [list %lxIN%d inlet]\n",
g_vslider.c:             xpos, ypos-2,
g_vslider.c:             xpos+7, ypos-1,
g_vslider.c:    int xpos=text_xpix(&x->x_gui.x_obj, glist);
g_vslider.c:    int ypos=text_ypix(&x->x_gui.x_obj, glist);
g_vslider.c:    int r = ypos + x->x_gui.x_h - (x->x_val + 50)/100;
g_vslider.c:             xpos, ypos-2,
g_vslider.c:             xpos + x->x_gui.x_w, ypos + x->x_gui.x_h+3);
g_vslider.c:             xpos + x->x_gui.x_w, r);
g_vslider.c:             canvas, x, xpos+x->x_gui.x_ldx, ypos+x->x_gui.x_ldy);
g_vslider.c:    if(!x->x_gui.x_fsf.x_snd_able)
g_vslider.c:             xpos, ypos + x->x_gui.x_h+2,
g_vslider.c:             xpos+7, ypos + x->x_gui.x_h+3);
g_vslider.c:    if(!x->x_gui.x_fsf.x_rcv_able)
g_vslider.c:             xpos, ypos-2,
g_vslider.c:             xpos+7, ypos-1);
g_vslider.c:    if(!x->x_gui.x_fsf.x_snd_able)
g_vslider.c:    if(!x->x_gui.x_fsf.x_rcv_able)
g_vslider.c:    sys_vgui(".x%lx.c itemconfigure %lxLABEL -font {{%s} -%d %s} -fill #%6.6x -text {%s} \n",
g_vslider.c:             canvas, x, x->x_gui.x_font, x->x_gui.x_fontsize, sys_fontweight, 
g_vslider.c:             x->x_gui.x_fsf.x_selected?IEM_GUI_COLOR_SELECTED:x->x_gui.x_lcol,
g_vslider.c:             strcmp(x->x_gui.x_lab->s_name, "empty")?x->x_gui.x_lab->s_name:"");
g_vslider.c:    sys_vgui(".x%lx.c itemconfigure %lxKNOB -fill #%6.6x\n", canvas,
g_vslider.c:             x, x->x_gui.x_fcol);
g_vslider.c:    sys_vgui(".x%lx.c itemconfigure %lxBASE -fill #%6.6x\n", canvas,
g_vslider.c:             x, x->x_gui.x_bcol);
g_vslider.c:    int xpos=text_xpix(&x->x_gui.x_obj, glist);
g_vslider.c:    int ypos=text_ypix(&x->x_gui.x_obj, glist);
g_vslider.c:    if((old_snd_rcv_flags & IEM_GUI_OLD_SND_FLAG) && !x->x_gui.x_fsf.x_snd_able)
g_vslider.c:        sys_vgui(".x%lx.c create rectangle %d %d %d %d -tags %lxOUT%d\n",
g_vslider.c:             xpos, ypos + x->x_gui.x_h+2,
g_vslider.c:             xpos+7, ypos + x->x_gui.x_h+3,
g_vslider.c:    if(!(old_snd_rcv_flags & IEM_GUI_OLD_SND_FLAG) && x->x_gui.x_fsf.x_snd_able)
g_vslider.c:    if((old_snd_rcv_flags & IEM_GUI_OLD_RCV_FLAG) && !x->x_gui.x_fsf.x_rcv_able)
g_vslider.c:        sys_vgui(".x%lx.c create rectangle %d %d %d %d -tags %lxIN%d\n",
g_vslider.c:             xpos, ypos-2,
g_vslider.c:             xpos+7, ypos-1,
g_vslider.c:    if(!(old_snd_rcv_flags & IEM_GUI_OLD_RCV_FLAG) && x->x_gui.x_fsf.x_rcv_able)
g_vslider.c:    if(x->x_gui.x_fsf.x_selected)
g_vslider.c:        sys_vgui(".x%lx.c itemconfigure %lxBASE -outline #%6.6x\n", canvas, x, IEM_GUI_COLOR_SELECTED);
g_vslider.c:        sys_vgui(".x%lx.c itemconfigure %lxLABEL -fill #%6.6x\n", canvas, x, IEM_GUI_COLOR_SELECTED);
g_vslider.c:        sys_vgui(".x%lx.c itemconfigure %lxBASE -outline #%6.6x\n", canvas, x, IEM_GUI_COLOR_NORMAL);
g_vslider.c:        sys_vgui(".x%lx.c itemconfigure %lxLABEL -fill #%6.6x\n", canvas, x, x->x_gui.x_lcol);
g_vslider.c:        vslider_draw_io(x, glist, mode - IEM_GUI_DRAW_MODE_IO);
g_vslider.c:/* ------------------------ vsl widgetbehaviour----------------------------- */
g_vslider.c:    *xp1 = text_xpix(&x->x_gui.x_obj, glist);
g_vslider.c:    *yp1 = text_ypix(&x->x_gui.x_obj, glist) - 2;
g_vslider.c:    *xp2 = *xp1 + x->x_gui.x_w;
g_vslider.c:    *yp2 = *yp1 + x->x_gui.x_h + 5;
g_vslider.c:    iemgui_save(&x->x_gui, srl, bflcol);
g_vslider.c:                (int)x->x_gui.x_obj.te_xpix, (int)x->x_gui.x_obj.te_ypix,
g_vslider.c:                gensym("vsl"), x->x_gui.x_w, x->x_gui.x_h,
g_vslider.c:                (t_float)x->x_min, (t_float)x->x_max,
g_vslider.c:                x->x_lin0_log1, iem_symargstoint(&x->x_gui.x_isa),
g_vslider.c:                x->x_gui.x_ldx, x->x_gui.x_ldy,
g_vslider.c:                iem_fstyletoint(&x->x_gui.x_fsf), x->x_gui.x_fontsize,
g_vslider.c:                x->x_val, x->x_steady);
g_vslider.c:    x->x_gui.x_h = h;
g_vslider.c:    if(x->x_val > (x->x_gui.x_h*100 - 100))
g_vslider.c:        x->x_pos = x->x_gui.x_h*100 - 100;
g_vslider.c:        x->x_val = x->x_pos;
g_vslider.c:    if(x->x_lin0_log1)
g_vslider.c:        x->x_k = log(x->x_max/x->x_min)/(double)(x->x_gui.x_h - 1);
g_vslider.c:        x->x_k = (x->x_max - x->x_min)/(double)(x->x_gui.x_h - 1);
g_vslider.c:    if(x->x_lin0_log1)
g_vslider.c:    x->x_min = min;
g_vslider.c:    x->x_max = max;
g_vslider.c:    if(x->x_min > x->x_max)                /* bugfix */
g_vslider.c:        x->x_gui.x_isa.x_reverse = 1;
g_vslider.c:        x->x_gui.x_isa.x_reverse = 0;
g_vslider.c:    if(x->x_lin0_log1)
g_vslider.c:        x->x_k = log(x->x_max/x->x_min)/(double)(x->x_gui.x_h - 1);
g_vslider.c:        x->x_k = (x->x_max - x->x_min)/(double)(x->x_gui.x_h - 1);
g_vslider.c:    iemgui_properties(&x->x_gui, srl);
g_vslider.c:            --------dimensions(pix)(pix):-------- %d %d width: %d %d height: \
g_vslider.c:            -----------output-range:----------- %g bottom: %g top: %d \
g_vslider.c:            x->x_gui.x_w, IEM_GUI_MINSIZE, x->x_gui.x_h, IEM_SL_MINSIZE,
g_vslider.c:            x->x_min, x->x_max, 0,/*no_schedule*/
g_vslider.c:            x->x_lin0_log1, x->x_gui.x_isa.x_loadinit, x->x_steady, -1,/*no multi, but iem-characteristic*/
g_vslider.c:            srl[0]->s_name, srl[1]->s_name,
g_vslider.c:            srl[2]->s_name, x->x_gui.x_ldx, x->x_gui.x_ldy,
g_vslider.c:            x->x_gui.x_fsf.x_font_style, x->x_gui.x_fontsize,
g_vslider.c:            0xffffff & x->x_gui.x_bcol, 0xffffff & x->x_gui.x_fcol, 0xffffff & x->x_gui.x_lcol);
g_vslider.c:    gfxstub_new(&x->x_gui.x_obj.ob_pd, x, buf);
g_vslider.c:    if(x->x_lin0_log1)
g_vslider.c:        out = x->x_min*exp(x->x_k*(double)(x->x_val)*0.01);
g_vslider.c:        out = (double)(x->x_val)*0.01*x->x_k + x->x_min;
g_vslider.c:    if((out < 1.0e-10)&&(out > -1.0e-10))
g_vslider.c:    outlet_float(x->x_gui.x_obj.ob_outlet, out);
g_vslider.c:    if(x->x_gui.x_fsf.x_snd_able && x->x_gui.x_snd->s_thing)
g_vslider.c:        pd_float(x->x_gui.x_snd->s_thing, out);
g_vslider.c:    x->x_lin0_log1 = lilo;
g_vslider.c:        x->x_steady = 1;
g_vslider.c:        x->x_steady = 0;
g_vslider.c:    sr_flags = iemgui_dialog(&x->x_gui, srl, argc, argv);
g_vslider.c:    x->x_gui.x_w = iemgui_clip_size(w);
g_vslider.c:    (*x->x_gui.x_draw)(x, x->x_gui.x_glist, IEM_GUI_DRAW_MODE_CONFIG);
g_vslider.c:    (*x->x_gui.x_draw)(x, x->x_gui.x_glist, IEM_GUI_DRAW_MODE_IO + sr_flags);
g_vslider.c:    (*x->x_gui.x_draw)(x, x->x_gui.x_glist, IEM_GUI_DRAW_MODE_MOVE);
g_vslider.c:    canvas_fixlinesfor(x->x_gui.x_glist, (t_text*)x);
g_vslider.c:    int old = x->x_val;
g_vslider.c:    if(x->x_gui.x_fsf.x_finemoved)
g_vslider.c:        x->x_pos -= (int)dy;
g_vslider.c:        x->x_pos -= 100*(int)dy;
g_vslider.c:    x->x_val = x->x_pos;
g_vslider.c:    if(x->x_val > (100*x->x_gui.x_h - 100))
g_vslider.c:        x->x_val = 100*x->x_gui.x_h - 100;
g_vslider.c:        x->x_pos += 50;
g_vslider.c:        x->x_pos -= x->x_pos%100;
g_vslider.c:    if(x->x_val < 0)
g_vslider.c:        x->x_val = 0;
g_vslider.c:        x->x_pos -= 50;
g_vslider.c:        x->x_pos -= x->x_pos%100;
g_vslider.c:    if(old != x->x_val)
g_vslider.c:        (*x->x_gui.x_draw)(x, x->x_gui.x_glist, IEM_GUI_DRAW_MODE_UPDATE);
g_vslider.c:    if(!x->x_steady)
g_vslider.c:        x->x_val = (int)(100.0 * (x->x_gui.x_h + text_ypix(&x->x_gui.x_obj, x->x_gui.x_glist) - ypos));
g_vslider.c:    if(x->x_val > (100*x->x_gui.x_h - 100))
g_vslider.c:        x->x_val = 100*x->x_gui.x_h - 100;
g_vslider.c:    if(x->x_val < 0)
g_vslider.c:        x->x_val = 0;
g_vslider.c:    x->x_pos = x->x_val;
g_vslider.c:    (*x->x_gui.x_draw)(x, x->x_gui.x_glist, IEM_GUI_DRAW_MODE_UPDATE);
g_vslider.c:    glist_grab(x->x_gui.x_glist, &x->x_gui.x_obj.te_g,
g_vslider.c:            x->x_gui.x_fsf.x_finemoved = 1;
g_vslider.c:            x->x_gui.x_fsf.x_finemoved = 0;
g_vslider.c:    int old = x->x_val;
g_vslider.c:    if(x->x_gui.x_isa.x_reverse)    /* bugfix */
g_vslider.c:        if(f > x->x_min)
g_vslider.c:            f = x->x_min;
g_vslider.c:        if(f < x->x_max)
g_vslider.c:            f = x->x_max;
g_vslider.c:        if(f > x->x_max)
g_vslider.c:            f = x->x_max;
g_vslider.c:        if(f < x->x_min)
g_vslider.c:            f = x->x_min;
g_vslider.c:    if(x->x_lin0_log1)
g_vslider.c:        g = log(f/x->x_min)/x->x_k;
g_vslider.c:        g = (f - x->x_min) / x->x_k;
g_vslider.c:    x->x_val = (int)(100.0*g + 0.49999);
g_vslider.c:    x->x_pos = x->x_val;
g_vslider.c:    if(x->x_val != old)
g_vslider.c:        (*x->x_gui.x_draw)(x, x->x_gui.x_glist, IEM_GUI_DRAW_MODE_UPDATE);
g_vslider.c:    if(x->x_gui.x_fsf.x_put_in2out)
g_vslider.c:    x->x_gui.x_w = iemgui_clip_size((int)atom_getintarg(0, ac, av));
g_vslider.c:    iemgui_size((void *)x, &x->x_gui);
g_vslider.c:{iemgui_delta((void *)x, &x->x_gui, s, ac, av);}
g_vslider.c:{iemgui_pos((void *)x, &x->x_gui, s, ac, av);}
g_vslider.c:{iemgui_color((void *)x, &x->x_gui, s, ac, av);}
g_vslider.c:{iemgui_send(x, &x->x_gui, s);}
g_vslider.c:{iemgui_receive(x, &x->x_gui, s);}
g_vslider.c:{iemgui_label((void *)x, &x->x_gui, s);}
g_vslider.c:{iemgui_label_pos((void *)x, &x->x_gui, s, ac, av);}
g_vslider.c:{iemgui_label_font((void *)x, &x->x_gui, s, ac, av);}
g_vslider.c:    x->x_lin0_log1 = 1;
g_vslider.c:    vslider_check_minmax(x, x->x_min, x->x_max);
g_vslider.c:    x->x_lin0_log1 = 0;
g_vslider.c:    x->x_k = (x->x_max - x->x_min)/(double)(x->x_gui.x_h - 1);
g_vslider.c:    x->x_gui.x_isa.x_loadinit = (f==0.0)?0:1;
g_vslider.c:    x->x_steady = (f==0.0)?0:1;
g_vslider.c:    if(!sys_noloadbang && x->x_gui.x_isa.x_loadinit)
g_vslider.c:        (*x->x_gui.x_draw)(x, x->x_gui.x_glist, IEM_GUI_DRAW_MODE_UPDATE);
g_vslider.c:    int bflcol[]={-262144, -1, -1};
g_vslider.c:    int lilo=0, f=0, ldx=0, ldy=-9;
g_vslider.c:    double min=0.0, max=(double)(IEM_SL_DEFAULTSIZE-1);
g_vslider.c:    iem_inttosymargs(&x->x_gui.x_isa, 0);
g_vslider.c:    iem_inttofstyle(&x->x_gui.x_fsf, 0);
g_vslider.c:        iem_inttosymargs(&x->x_gui.x_isa, atom_getintarg(5, argc, argv));
g_vslider.c:        iemgui_new_getnames(&x->x_gui, 6, argv);
g_vslider.c:        iem_inttofstyle(&x->x_gui.x_fsf, atom_getintarg(11, argc, argv));
g_vslider.c:    else iemgui_new_getnames(&x->x_gui, 6, 0);
g_vslider.c:    x->x_gui.x_draw = (t_iemfunptr)vslider_draw;
g_vslider.c:    x->x_gui.x_fsf.x_snd_able = 1;
g_vslider.c:    x->x_gui.x_fsf.x_rcv_able = 1;
g_vslider.c:    x->x_gui.x_glist = (t_glist *)canvas_getcurrent();
g_vslider.c:    if(x->x_gui.x_isa.x_loadinit)
g_vslider.c:        x->x_val = v;
g_vslider.c:        x->x_val = 0;
g_vslider.c:    x->x_pos = x->x_val;
g_vslider.c:    x->x_lin0_log1 = lilo;
g_vslider.c:    x->x_steady = steady;
g_vslider.c:    if(!strcmp(x->x_gui.x_snd->s_name, "empty")) x->x_gui.x_fsf.x_snd_able = 0;
g_vslider.c:    if(!strcmp(x->x_gui.x_rcv->s_name, "empty")) x->x_gui.x_fsf.x_rcv_able = 0;
g_vslider.c:    if(x->x_gui.x_fsf.x_font_style == 1) strcpy(x->x_gui.x_font, "helvetica");
g_vslider.c:    else if(x->x_gui.x_fsf.x_font_style == 2) strcpy(x->x_gui.x_font, "times");
g_vslider.c:    else { x->x_gui.x_fsf.x_font_style = 0;
g_vslider.c:        strcpy(x->x_gui.x_font, sys_font); }
g_vslider.c:    if(x->x_gui.x_fsf.x_rcv_able) pd_bind(&x->x_gui.x_obj.ob_pd, x->x_gui.x_rcv);
g_vslider.c:    x->x_gui.x_ldx = ldx;
g_vslider.c:    x->x_gui.x_ldy = ldy;
g_vslider.c:    x->x_gui.x_fontsize = fs;
g_vslider.c:    x->x_gui.x_w = iemgui_clip_size(w);
g_vslider.c:    iemgui_all_colfromload(&x->x_gui, bflcol);
g_vslider.c:    iemgui_verify_snd_ne_rcv(&x->x_gui);
g_vslider.c:    outlet_new(&x->x_gui.x_obj, &s_float);
g_vslider.c:    if(x->x_gui.x_fsf.x_rcv_able)
g_vslider.c:        pd_unbind(&x->x_gui.x_obj.ob_pd, x->x_gui.x_rcv);
g_vumeter.c:/* Copyright (c) 1997-1999 Miller Puckette.
g_vumeter.c:/* g_7_guis.c written by Thomas Musil (c) IEM KUG Graz Austria 2000-2001 */
g_vumeter.c:/* ----- vu  gui-peak- & rms- vu-meter-display ---------- */
g_vumeter.c:        int w4=x->x_gui.x_w/4, off=text_ypix(&x->x_gui.x_obj, glist)-1;
g_vumeter.c:        int xpos=text_xpix(&x->x_gui.x_obj, glist), quad1=xpos+w4+1, quad3=xpos+x->x_gui.x_w-w4-1;
g_vumeter.c:                 off + (x->x_led_size+1)*(IEM_VU_STEPS-x->x_rms));
g_vumeter.c:        int xpos=text_xpix(&x->x_gui.x_obj, glist);
g_vumeter.c:        int ypos=text_ypix(&x->x_gui.x_obj, glist);
g_vumeter.c:        if(x->x_peak)
g_vumeter.c:            int i=iemgui_vu_col[x->x_peak];
g_vumeter.c:            int j=ypos + (x->x_led_size+1)*(IEM_VU_STEPS+1-x->x_peak)
g_vumeter.c:                - (x->x_led_size+1)/2;
g_vumeter.c:                     xpos+x->x_gui.x_w+1, j);
g_vumeter.c:            sys_vgui(".x%lx.c itemconfigure %lxPLED -fill #%6.6x\n", canvas, x,
g_vumeter.c:            int mid=xpos+x->x_gui.x_w/2;
g_vumeter.c:            sys_vgui(".x%lx.c itemconfigure %lxPLED -fill #%6.6x\n",
g_vumeter.c:                     canvas, x, x->x_gui.x_bcol);
g_vumeter.c:    if (x->x_updaterms)
g_vumeter.c:        x->x_updaterms = 0;
g_vumeter.c:    if (x->x_updatepeak)
g_vumeter.c:        x->x_updatepeak = 0;
g_vumeter.c:    int xpos=text_xpix(&x->x_gui.x_obj, glist);
g_vumeter.c:    int ypos=text_ypix(&x->x_gui.x_obj, glist);
g_vumeter.c:    int w4=x->x_gui.x_w/4, mid=xpos+x->x_gui.x_w/2,
g_vumeter.c:    int quad3=xpos+x->x_gui.x_w-w4,
g_vumeter.c:        end=xpos+x->x_gui.x_w+4;
g_vumeter.c:    int k1=x->x_led_size+1, k2=IEM_VU_STEPS+1, k3=k1/2;
g_vumeter.c:    int led_col, yyy, i, k4=ypos-k3;
g_vumeter.c:    sys_vgui(".x%lx.c create rectangle %d %d %d %d -fill #%6.6x -tags %lxBASE\n",
g_vumeter.c:             canvas, xpos-1, ypos-2,
g_vumeter.c:             xpos+x->x_gui.x_w+1,
g_vumeter.c:             ypos+x->x_gui.x_h+2, x->x_gui.x_bcol, x);
g_vumeter.c:        yyy = k4 + k1*(k2-i);
g_vumeter.c:        sys_vgui(".x%lx.c create line %d %d %d %d -width %d -fill #%6.6x -tags %lxRLED%d\n",
g_vumeter.c:                 canvas, quad1, yyy, quad3, yyy, x->x_led_size, iemgui_color_hex[led_col], x, i);
g_vumeter.c:        if(((i+2)&3) && (x->x_scale))
g_vumeter.c:            sys_vgui(".x%lx.c create text %d %d -text {%s} -anchor w \
g_vumeter.c:                     -font {{%s} -%d %s} -fill #%6.6x -tags %lxSCALE%d\n",
g_vumeter.c:                     x->x_gui.x_font, x->x_gui.x_fontsize,
g_vumeter.c:                     sys_fontweight, x->x_gui.x_lcol, x, i);
g_vumeter.c:    if(x->x_scale)
g_vumeter.c:        yyy = k4 + k1*(k2-i);
g_vumeter.c:        sys_vgui(".x%lx.c create text %d %d -text {%s} -anchor w \
g_vumeter.c:                 -font {{%s} -%d %s} -fill #%6.6x -tags %lxSCALE%d\n",
g_vumeter.c:                 canvas, end, yyy+k3, iemgui_vu_scale_str[i], x->x_gui.x_font, 
g_vumeter.c:                 x->x_gui.x_fontsize, sys_fontweight,
g_vumeter.c:                 x->x_gui.x_lcol, x, i);
g_vumeter.c:    sys_vgui(".x%lx.c create rectangle %d %d %d %d -fill #%6.6x -outline #%6.6x -tags %lxRCOVER\n",
g_vumeter.c:             canvas, quad1, ypos-1, quad3-1,
g_vumeter.c:             ypos-1 + k1*IEM_VU_STEPS, x->x_gui.x_bcol, x->x_gui.x_bcol, x);
g_vumeter.c:    sys_vgui(".x%lx.c create line %d %d %d %d -width %d -fill #%6.6x -tags %lxPLED\n",
g_vumeter.c:             mid, ypos+10, x->x_led_size, x->x_gui.x_bcol, x);
g_vumeter.c:    sys_vgui(".x%lx.c create text %d %d -text {%s} -anchor w \
g_vumeter.c:             -font {{%s} -%d %s} -fill #%6.6x -tags [list %lxLABEL label text]\n",
g_vumeter.c:             canvas, xpos+x->x_gui.x_ldx, ypos+x->x_gui.x_ldy,
g_vumeter.c:             strcmp(x->x_gui.x_lab->s_name, "empty")?x->x_gui.x_lab->s_name:"",
g_vumeter.c:             x->x_gui.x_font, x->x_gui.x_fontsize, sys_fontweight,
g_vumeter.c:             x->x_gui.x_lcol, x);
g_vumeter.c:    if(!x->x_gui.x_fsf.x_snd_able)
g_vumeter.c:        sys_vgui(".x%lx.c create rectangle %d %d %d %d -tags [list %lxOUT%d outlet]\n",
g_vumeter.c:             xpos-1, ypos + x->x_gui.x_h+1,
g_vumeter.c:             xpos + IOWIDTH-1, ypos + x->x_gui.x_h+2,
g_vumeter.c:        sys_vgui(".x%lx.c create rectangle %d %d %d %d -tags [list %lxOUT%d outlet]x\n",
g_vumeter.c:             xpos+x->x_gui.x_w+1-IOWIDTH, ypos + x->x_gui.x_h+1,
g_vumeter.c:             xpos+x->x_gui.x_w+1, ypos + x->x_gui.x_h+2,
g_vumeter.c:    if(!x->x_gui.x_fsf.x_rcv_able)
g_vumeter.c:        sys_vgui(".x%lx.c create rectangle %d %d %d %d -tags [list %lxIN%d inlet]\n",
g_vumeter.c:             xpos-1, ypos-2,
g_vumeter.c:             xpos + IOWIDTH-1, ypos-1,
g_vumeter.c:        sys_vgui(".x%lx.c create rectangle %d %d %d %d -tags [list %lxIN%d inlet]\n",
g_vumeter.c:             xpos+x->x_gui.x_w+1-IOWIDTH, ypos-2,
g_vumeter.c:             xpos+x->x_gui.x_w+1, ypos-1,
g_vumeter.c:    x->x_updaterms = x->x_updatepeak = 1;
g_vumeter.c:    sys_queuegui(x, x->x_gui.x_glist, vu_draw_update);
g_vumeter.c:    int xpos=text_xpix(&x->x_gui.x_obj, glist);
g_vumeter.c:    int ypos=text_ypix(&x->x_gui.x_obj, glist);
g_vumeter.c:    int w4=x->x_gui.x_w/4, quad1=xpos+w4+1;
g_vumeter.c:    int quad3=xpos+x->x_gui.x_w-w4,
g_vumeter.c:        end=xpos+x->x_gui.x_w+4;
g_vumeter.c:    int k1=x->x_led_size+1, k2=IEM_VU_STEPS+1, k3=k1/2;
g_vumeter.c:    int yyy, i, k4=ypos-k3;
g_vumeter.c:             canvas, x, xpos-1, ypos-2,
g_vumeter.c:             xpos+x->x_gui.x_w+1,ypos+x->x_gui.x_h+2);
g_vumeter.c:        yyy = k4 + k1*(k2-i);
g_vumeter.c:        if(((i+2)&3) && (x->x_scale))
g_vumeter.c:    if(x->x_scale)
g_vumeter.c:        yyy = k4 + k1*(k2-i);
g_vumeter.c:    x->x_updaterms = x->x_updatepeak = 1;
g_vumeter.c:             canvas, x, xpos+x->x_gui.x_ldx,
g_vumeter.c:             ypos+x->x_gui.x_ldy);
g_vumeter.c:    if(!x->x_gui.x_fsf.x_snd_able)
g_vumeter.c:             xpos-1, ypos + x->x_gui.x_h+1,
g_vumeter.c:             xpos + IOWIDTH-1, ypos + x->x_gui.x_h+2);
g_vumeter.c:             xpos+x->x_gui.x_w+1-IOWIDTH, ypos + x->x_gui.x_h+1,
g_vumeter.c:                 xpos+x->x_gui.x_w+1, ypos + x->x_gui.x_h+2);
g_vumeter.c:    if(!x->x_gui.x_fsf.x_rcv_able)
g_vumeter.c:             xpos-1, ypos-2,
g_vumeter.c:             xpos + IOWIDTH-1, ypos-1);
g_vumeter.c:             xpos+x->x_gui.x_w+1-IOWIDTH, ypos-2,
g_vumeter.c:             xpos+x->x_gui.x_w+1, ypos-1);
g_vumeter.c:        if(((i+2)&3) && (x->x_scale))
g_vumeter.c:    if(x->x_scale)
g_vumeter.c:    if(!x->x_gui.x_fsf.x_snd_able)
g_vumeter.c:    if(!x->x_gui.x_fsf.x_rcv_able)
g_vumeter.c:    sys_vgui(".x%lx.c itemconfigure %lxBASE -fill #%6.6x\n", canvas, x, x->x_gui.x_bcol);
g_vumeter.c:        sys_vgui(".x%lx.c itemconfigure %lxRLED%d -width %d\n", canvas, x, i,
g_vumeter.c:                 x->x_led_size);
g_vumeter.c:        if(((i+2)&3) && (x->x_scale))
g_vumeter.c:            sys_vgui(".x%lx.c itemconfigure %lxSCALE%d -text {%s} -font {{%s} -%d %s} -fill #%6.6x\n",
g_vumeter.c:                     canvas, x, i, iemgui_vu_scale_str[i], x->x_gui.x_font, 
g_vumeter.c:                     x->x_gui.x_fontsize, sys_fontweight, 
g_vumeter.c:                     x->x_gui.x_fsf.x_selected?IEM_GUI_COLOR_SELECTED:x->x_gui.x_lcol);
g_vumeter.c:    if(x->x_scale)
g_vumeter.c:        sys_vgui(".x%lx.c itemconfigure %lxSCALE%d -text {%s} -font {{%s} -%d %s} -fill #%6.6x\n",
g_vumeter.c:                 canvas, x, i, iemgui_vu_scale_str[i], x->x_gui.x_font, 
g_vumeter.c:                 x->x_gui.x_fontsize, sys_fontweight,
g_vumeter.c:                 x->x_gui.x_fsf.x_selected?IEM_GUI_COLOR_SELECTED:x->x_gui.x_lcol);
g_vumeter.c:    sys_vgui(".x%lx.c itemconfigure %lxLABEL -font {{%s} -%d %s} -fill #%6.6x -text {%s} \n",
g_vumeter.c:             canvas, x, x->x_gui.x_font, x->x_gui.x_fontsize, sys_fontweight,
g_vumeter.c:             x->x_gui.x_fsf.x_selected?IEM_GUI_COLOR_SELECTED:x->x_gui.x_lcol,
g_vumeter.c:             strcmp(x->x_gui.x_lab->s_name, "empty")?x->x_gui.x_lab->s_name:"");
g_vumeter.c:    sys_vgui(".x%lx.c itemconfigure %lxRCOVER -fill #%6.6x -outline #%6.6x\n", canvas,
g_vumeter.c:             x, x->x_gui.x_bcol, x->x_gui.x_bcol);
g_vumeter.c:    sys_vgui(".x%lx.c itemconfigure %lxPLED -width %d\n", canvas, x,
g_vumeter.c:             x->x_led_size);
g_vumeter.c:    int xpos=text_xpix(&x->x_gui.x_obj, glist);
g_vumeter.c:    int ypos=text_ypix(&x->x_gui.x_obj, glist);
g_vumeter.c:    if((old_snd_rcv_flags & IEM_GUI_OLD_SND_FLAG) && !x->x_gui.x_fsf.x_snd_able)
g_vumeter.c:        sys_vgui(".x%lx.c create rectangle %d %d %d %d -tags %lxOUT%d\n",
g_vumeter.c:             xpos-1, ypos + x->x_gui.x_h+1,
g_vumeter.c:             xpos + IOWIDTH-1, ypos + x->x_gui.x_h+2,
g_vumeter.c:        sys_vgui(".x%lx.c create rectangle %d %d %d %d -tags %lxOUT%d\n",
g_vumeter.c:             xpos+x->x_gui.x_w+1-IOWIDTH, ypos + x->x_gui.x_h+1,
g_vumeter.c:             xpos+x->x_gui.x_w+1, ypos + x->x_gui.x_h+2,
g_vumeter.c:    if(!(old_snd_rcv_flags & IEM_GUI_OLD_SND_FLAG) && x->x_gui.x_fsf.x_snd_able)
g_vumeter.c:    if((old_snd_rcv_flags & IEM_GUI_OLD_RCV_FLAG) && !x->x_gui.x_fsf.x_rcv_able)
g_vumeter.c:        sys_vgui(".x%lx.c create rectangle %d %d %d %d -tags %lxIN%d\n",
g_vumeter.c:             xpos-1, ypos-2,
g_vumeter.c:             xpos + IOWIDTH-1, ypos-1,
g_vumeter.c:        sys_vgui(".x%lx.c create rectangle %d %d %d %d -tags %lxIN%d\n",
g_vumeter.c:             xpos+x->x_gui.x_w+1-IOWIDTH, ypos-2,
g_vumeter.c:             xpos+x->x_gui.x_w+1, ypos-1,
g_vumeter.c:    if(!(old_snd_rcv_flags & IEM_GUI_OLD_RCV_FLAG) && x->x_gui.x_fsf.x_rcv_able)
g_vumeter.c:    if(x->x_gui.x_fsf.x_selected)
g_vumeter.c:        sys_vgui(".x%lx.c itemconfigure %lxBASE -outline #%6.6x\n", canvas, x, IEM_GUI_COLOR_SELECTED);
g_vumeter.c:            if(((i+2)&3) && (x->x_scale))
g_vumeter.c:                sys_vgui(".x%lx.c itemconfigure %lxSCALE%d -fill #%6.6x\n",
g_vumeter.c:        if(x->x_scale)
g_vumeter.c:            sys_vgui(".x%lx.c itemconfigure %lxSCALE%d -fill #%6.6x\n",
g_vumeter.c:        sys_vgui(".x%lx.c itemconfigure %lxLABEL -fill #%6.6x\n", canvas, x, IEM_GUI_COLOR_SELECTED);
g_vumeter.c:        sys_vgui(".x%lx.c itemconfigure %lxBASE -outline #%6.6x\n", canvas, x, IEM_GUI_COLOR_NORMAL);
g_vumeter.c:            if(((i+2)&3) && (x->x_scale))
g_vumeter.c:                sys_vgui(".x%lx.c itemconfigure %lxSCALE%d -fill #%6.6x\n",
g_vumeter.c:                         canvas, x, i, x->x_gui.x_lcol);
g_vumeter.c:        if(x->x_scale)
g_vumeter.c:            sys_vgui(".x%lx.c itemconfigure %lxSCALE%d -fill #%6.6x\n",
g_vumeter.c:                     canvas, x, i, x->x_gui.x_lcol);
g_vumeter.c:        sys_vgui(".x%lx.c itemconfigure %lxLABEL -fill #%6.6x\n", canvas, x, x->x_gui.x_lcol);
g_vumeter.c:        vu_draw_io(x, glist, mode - IEM_GUI_DRAW_MODE_IO);
g_vumeter.c:/* ------------------------ vu widgetbehaviour----------------------------- */
g_vumeter.c:    *xp1 = text_xpix(&x->x_gui.x_obj, glist) - 1;
g_vumeter.c:    *yp1 = text_ypix(&x->x_gui.x_obj, glist) - 2;
g_vumeter.c:    *xp2 = *xp1 + x->x_gui.x_w + 2;
g_vumeter.c:    *yp2 = *yp1 + x->x_gui.x_h + 4;
g_vumeter.c:    iemgui_save(&x->x_gui, srl, bflcol);
g_vumeter.c:                (int)x->x_gui.x_obj.te_xpix, (int)x->x_gui.x_obj.te_ypix,
g_vumeter.c:                gensym("vu"), x->x_gui.x_w, x->x_gui.x_h,
g_vumeter.c:                x->x_gui.x_ldx, x->x_gui.x_ldy,
g_vumeter.c:                iem_fstyletoint(&x->x_gui.x_fsf), x->x_gui.x_fontsize,
g_vumeter.c:                bflcol[0], bflcol[2], x->x_scale,
g_vumeter.c:                iem_symargstoint(&x->x_gui.x_isa));
g_vumeter.c:    x->x_led_size = n-1;
g_vumeter.c:    x->x_gui.x_h = IEM_VU_STEPS * n;
g_vumeter.c:    if(x->x_scale && !scale)
g_vumeter.c:        t_canvas *canvas=glist_getcanvas(x->x_gui.x_glist);
g_vumeter.c:        x->x_scale = (int)scale;
g_vumeter.c:        if(glist_isvisible(x->x_gui.x_glist))
g_vumeter.c:    if(!x->x_scale && scale)
g_vumeter.c:        int w4=x->x_gui.x_w/4, end=text_xpix(&x->x_gui.x_obj, x->x_gui.x_glist)+x->x_gui.x_w+4;
g_vumeter.c:        int k1=x->x_led_size+1, k2=IEM_VU_STEPS+1, k3=k1/2;
g_vumeter.c:        int yyy, k4=text_ypix(&x->x_gui.x_obj, x->x_gui.x_glist)-k3;
g_vumeter.c:        t_canvas *canvas=glist_getcanvas(x->x_gui.x_glist);
g_vumeter.c:        x->x_scale = (int)scale;
g_vumeter.c:        if(glist_isvisible(x->x_gui.x_glist))
g_vumeter.c:                yyy = k4 + k1*(k2-i);
g_vumeter.c:                    sys_vgui(".x%lx.c create text %d %d -text {%s} -anchor w \
g_vumeter.c:                             -font {{%s} -%d %s} -fill #%6.6x -tags %lxSCALE%d\n",
g_vumeter.c:                             x->x_gui.x_font, x->x_gui.x_fontsize,
g_vumeter.c:                             sys_fontweight, x->x_gui.x_lcol, x, i);
g_vumeter.c:            yyy = k4 + k1*(k2-i);
g_vumeter.c:            sys_vgui(".x%lx.c create text %d %d -text {%s} -anchor w \
g_vumeter.c:                     -font {{%s} -%d %s} -fill #%6.6x -tags %lxSCALE%d\n",
g_vumeter.c:                     x->x_gui.x_font, x->x_gui.x_fontsize, sys_fontweight,
g_vumeter.c:                     sys_fontweight, x->x_gui.x_lcol, x, i);
g_vumeter.c:    iemgui_properties(&x->x_gui, srl);
g_vumeter.c:            --------dimensions(pix)(pix):-------- %d %d width: %d %d height: \
g_vumeter.c:            x->x_gui.x_w, IEM_GUI_MINSIZE, x->x_gui.x_h, IEM_VU_STEPS*IEM_VU_MINSIZE,
g_vumeter.c:            x->x_scale, -1, -1, -1,/*no linlog, no init, no multi*/
g_vumeter.c:            "nosndno", srl[1]->s_name,/*no send*/
g_vumeter.c:            srl[2]->s_name, x->x_gui.x_ldx, x->x_gui.x_ldy,
g_vumeter.c:            x->x_gui.x_fsf.x_font_style, x->x_gui.x_fontsize,
g_vumeter.c:            0xffffff & x->x_gui.x_bcol, -1/*no front-color*/, 0xffffff & x->x_gui.x_lcol);
g_vumeter.c:    gfxstub_new(&x->x_gui.x_obj.ob_pd, x, buf);
g_vumeter.c:    sr_flags = iemgui_dialog(&x->x_gui, srl, argc, argv);
g_vumeter.c:    x->x_gui.x_fsf.x_snd_able = 0;
g_vumeter.c:    x->x_gui.x_isa.x_loadinit = 0;
g_vumeter.c:    x->x_gui.x_w = iemgui_clip_size(w);
g_vumeter.c:    (*x->x_gui.x_draw)(x, x->x_gui.x_glist, IEM_GUI_DRAW_MODE_CONFIG);
g_vumeter.c:    (*x->x_gui.x_draw)(x, x->x_gui.x_glist, IEM_GUI_DRAW_MODE_IO + sr_flags);
g_vumeter.c:    (*x->x_gui.x_draw)(x, x->x_gui.x_glist, IEM_GUI_DRAW_MODE_MOVE);
g_vumeter.c:    canvas_fixlinesfor(x->x_gui.x_glist, (t_text*)x);
g_vumeter.c:    x->x_gui.x_w = iemgui_clip_size((int)atom_getintarg(0, ac, av));
g_vumeter.c:    if(glist_isvisible(x->x_gui.x_glist))
g_vumeter.c:        (*x->x_gui.x_draw)(x, x->x_gui.x_glist, IEM_GUI_DRAW_MODE_MOVE);
g_vumeter.c:        (*x->x_gui.x_draw)(x, x->x_gui.x_glist, IEM_GUI_DRAW_MODE_CONFIG);
g_vumeter.c:        canvas_fixlinesfor(x->x_gui.x_glist, (t_text*)x);
g_vumeter.c:{iemgui_delta((void *)x, &x->x_gui, s, ac, av);}
g_vumeter.c:{iemgui_pos((void *)x, &x->x_gui, s, ac, av);}
g_vumeter.c:{iemgui_color((void *)x, &x->x_gui, s, ac, av);}
g_vumeter.c:{iemgui_receive(x, &x->x_gui, s);}
g_vumeter.c:{iemgui_label((void *)x, &x->x_gui, s);}
g_vumeter.c:{iemgui_label_pos((void *)x, &x->x_gui, s, ac, av);}
g_vumeter.c:{iemgui_label_font((void *)x, &x->x_gui, s, ac, av);}
g_vumeter.c:    int old = x->x_rms;
g_vumeter.c:        x->x_rms = 0;
g_vumeter.c:        x->x_rms = IEM_VU_STEPS;
g_vumeter.c:        x->x_rms = iemgui_vu_db2i[i];
g_vumeter.c:    rms = 0.01*(t_float)(i - 10000);
g_vumeter.c:    x->x_fr = rms;
g_vumeter.c:    outlet_float(x->x_out_rms, rms);
g_vumeter.c:    x->x_updaterms = 1;
g_vumeter.c:    if(x->x_rms != old)
g_vumeter.c:        sys_queuegui(x, x->x_gui.x_glist, vu_draw_update);
g_vumeter.c:    int old = x->x_peak;
g_vumeter.c:        x->x_peak = 0;
g_vumeter.c:        x->x_peak = IEM_VU_STEPS;
g_vumeter.c:        x->x_peak = iemgui_vu_db2i[i];
g_vumeter.c:    peak = 0.01*(t_float)(i - 10000);
g_vumeter.c:    x->x_fp = peak;
g_vumeter.c:    x->x_updatepeak = 1;
g_vumeter.c:    if(x->x_peak != old)
g_vumeter.c:        sys_queuegui(x, x->x_gui.x_glist, vu_draw_update);
g_vumeter.c:    outlet_float(x->x_out_peak, peak);
g_vumeter.c:    outlet_float(x->x_out_peak, x->x_fp);
g_vumeter.c:    outlet_float(x->x_out_rms, x->x_fr);
g_vumeter.c:    x->x_updaterms = x->x_updatepeak = 1;
g_vumeter.c:    sys_queuegui(x, x->x_gui.x_glist, vu_draw_update);
g_vumeter.c:    int bflcol[]={-66577, -1, -1};
g_vumeter.c:    int ldx=-1, ldy=-8, f=0, fs=10, scale=1;
g_vumeter.c:    iem_inttosymargs(&x->x_gui.x_isa, 0);
g_vumeter.c:    iem_inttofstyle(&x->x_gui.x_fsf, 0);
g_vumeter.c:        iemgui_new_getnames(&x->x_gui, 1, argv);
g_vumeter.c:        iem_inttofstyle(&x->x_gui.x_fsf, atom_getintarg(6, argc, argv));
g_vumeter.c:    else iemgui_new_getnames(&x->x_gui, 1, 0);
g_vumeter.c:        iem_inttosymargs(&x->x_gui.x_isa, atom_getintarg(11, argc, argv));
g_vumeter.c:    x->x_gui.x_draw = (t_iemfunptr)vu_draw;
g_vumeter.c:    x->x_gui.x_fsf.x_snd_able = 0;
g_vumeter.c:    x->x_gui.x_fsf.x_rcv_able = 1;
g_vumeter.c:    x->x_gui.x_glist = (t_glist *)canvas_getcurrent();
g_vumeter.c:    if (!strcmp(x->x_gui.x_rcv->s_name, "empty"))
g_vumeter.c:        x->x_gui.x_fsf.x_rcv_able = 0;
g_vumeter.c:    if (x->x_gui.x_fsf.x_font_style == 1)
g_vumeter.c:        strcpy(x->x_gui.x_font, "helvetica");
g_vumeter.c:    else if(x->x_gui.x_fsf.x_font_style == 2)
g_vumeter.c:        strcpy(x->x_gui.x_font, "times");
g_vumeter.c:    else { x->x_gui.x_fsf.x_font_style = 0;
g_vumeter.c:        strcpy(x->x_gui.x_font, sys_font); }
g_vumeter.c:    if(x->x_gui.x_fsf.x_rcv_able)
g_vumeter.c:        pd_bind(&x->x_gui.x_obj.ob_pd, x->x_gui.x_rcv);
g_vumeter.c:    x->x_gui.x_ldx = ldx;
g_vumeter.c:    x->x_gui.x_ldy = ldy;
g_vumeter.c:    x->x_gui.x_fontsize = fs;
g_vumeter.c:    x->x_gui.x_w = iemgui_clip_size(w);
g_vumeter.c:    iemgui_all_colfromload(&x->x_gui, bflcol);
g_vumeter.c:    x->x_scale = scale;
g_vumeter.c:    x->x_peak = 0;
g_vumeter.c:    x->x_rms = 0;
g_vumeter.c:    x->x_fp = -101.0;
g_vumeter.c:    x->x_fr = -101.0;
g_vumeter.c:    iemgui_verify_snd_ne_rcv(&x->x_gui);
g_vumeter.c:    inlet_new(&x->x_gui.x_obj, &x->x_gui.x_obj.ob_pd, &s_float, gensym("ft1"));
g_vumeter.c:    x->x_out_rms = outlet_new(&x->x_gui.x_obj, &s_float);
g_vumeter.c:    x->x_out_peak = outlet_new(&x->x_gui.x_obj, &s_float);
g_vumeter.c:    if(x->x_gui.x_fsf.x_rcv_able)
g_vumeter.c:        pd_unbind(&x->x_gui.x_obj.ob_pd, x->x_gui.x_rcv);
Makefile.am:pd_CFLAGS = -DPD -DINSTALL_PREFIX=\"$(prefix)\"
Makefile.am:pd_CFLAGS += -DUSEAPI_ALSA
Makefile.am:LIBS += -framework CoreAudio -framework CoreMIDI \
Makefile.am:	-framework AudioUnit -framework AudioToolbox
Makefile.am:pd_CFLAGS += -DUSEAPI_JACK -DJACK_XRUN
Makefile.am:pd_LDFLAGS += -weak_framework Jackmp
Makefile.am:pd_CFLAGS += -DUSEAPI_OSS
Makefile.am:pd_CFLAGS += -DUSEAPI_PORTAUDIO  -I$(top_srcdir)/portaudio/include
Makefile.am:INCLUDES += -I$(top_srcdir)/portmidi/pm_common -I$(top_srcdir)/portmidi/porttime
Makefile.am:#  (without OS-specific checks)
Makefile.am:libpdbin_PROGRAMS = pd-watchdog pd
Makefile.am:# this flag has to have a single leading "-" for libtool, even though ld uses
Makefile.am:# --export-dynamic, and libtool sends -Wl,--export-dynamic to ld...
Makefile.am:pd_LDFLAGS += -export-dynamic
Makefile.am:LIBS += -framework Carbon
Makefile.am:pd_CFLAGS += -DMACOSX #kludge, should use auto macro __APPLE__
Makefile.am:bin_PROGRAMS += pd-watchdog
Makefile.am:LIBS += -lwsock32 -lwinmm -lole32
Makefile.am:pd_CFLAGS +=  -DUSEAPI_MMIO -DPD_INTERNAL
Makefile.am:# XP SP1.  WINVER isnt' fine-grained enough for that, so we use the
Makefile.am:# next minor version of Windows, 5.2.  That gives us -DWINVER=0x0502
Makefile.am:pd_CFLAGS += -DWISHAPP='"wish85.exe"' -DWINVER=0x0502
Makefile.am:bin_PROGRAMS += pd-watchdog
Makefile.am:	etags --append --language=none --regex="/proc[ \t]+\([^ \t]+\)/\1/" *.tcl
makefile.dependencies: /usr/include/gnu/stubs.h /usr/include/gnu/stubs-64.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stddef.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdarg.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdint.h \
makefile.dependencies: /usr/include/gnu/stubs.h /usr/include/gnu/stubs-64.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stddef.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdint.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdarg.h \
makefile.dependencies: /usr/include/gnu/stubs.h /usr/include/gnu/stubs-64.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stddef.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdint.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdarg.h \
makefile.dependencies: /usr/include/gnu/stubs.h /usr/include/gnu/stubs-64.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stddef.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdarg.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdint.h \
makefile.dependencies: /usr/include/gnu/stubs.h /usr/include/gnu/stubs-64.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stddef.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdarg.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdint.h \
makefile.dependencies: /usr/include/gnu/stubs.h /usr/include/gnu/stubs-64.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stddef.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdarg.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdint.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stddef.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdint.h \
makefile.dependencies: /usr/include/gnu/stubs-64.h /usr/include/bits/wchar.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdarg.h \
makefile.dependencies: /usr/include/gnu/stubs.h /usr/include/gnu/stubs-64.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stddef.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdarg.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdint.h \
makefile.dependencies: /usr/include/gnu/stubs-64.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stddef.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdarg.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdint.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stddef.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdint.h \
makefile.dependencies: /usr/include/gnu/stubs-64.h /usr/include/bits/wchar.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdarg.h \
makefile.dependencies: /usr/include/gnu/stubs-64.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stddef.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdarg.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdint.h \
makefile.dependencies: /usr/include/gnu/stubs.h /usr/include/gnu/stubs-64.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stddef.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdarg.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdint.h \
makefile.dependencies: /usr/include/gnu/stubs.h /usr/include/gnu/stubs-64.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stddef.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdarg.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdint.h \
makefile.dependencies: /usr/include/gnu/stubs.h /usr/include/gnu/stubs-64.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stddef.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdarg.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdint.h \
makefile.dependencies: /usr/include/gnu/stubs.h /usr/include/gnu/stubs-64.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stddef.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdarg.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdint.h \
makefile.dependencies: /usr/include/gnu/stubs.h /usr/include/gnu/stubs-64.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stddef.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdarg.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdint.h \
makefile.dependencies: /usr/include/gnu/stubs.h /usr/include/gnu/stubs-64.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stddef.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdarg.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdint.h \
makefile.dependencies: /usr/include/gnu/stubs.h /usr/include/gnu/stubs-64.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stddef.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdarg.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdint.h \
makefile.dependencies: /usr/include/gnu/stubs.h /usr/include/gnu/stubs-64.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stddef.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdarg.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdint.h \
makefile.dependencies: /usr/include/gnu/stubs.h /usr/include/gnu/stubs-64.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stddef.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdarg.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdint.h \
makefile.dependencies: /usr/include/gnu/stubs.h /usr/include/gnu/stubs-64.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stddef.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdarg.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdint.h \
makefile.dependencies: /usr/include/gnu/stubs.h /usr/include/gnu/stubs-64.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stddef.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdarg.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdint.h \
makefile.dependencies: /usr/include/gnu/stubs.h /usr/include/gnu/stubs-64.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stddef.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdint.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdarg.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stddef.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdint.h \
makefile.dependencies: /usr/include/gnu/stubs-64.h /usr/include/bits/wchar.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdarg.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stddef.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdint.h \
makefile.dependencies: /usr/include/gnu/stubs-64.h /usr/include/bits/wchar.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdarg.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stddef.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdint.h \
makefile.dependencies: /usr/include/gnu/stubs-64.h /usr/include/bits/wchar.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdarg.h \
makefile.dependencies: /usr/include/gnu/stubs.h /usr/include/gnu/stubs-64.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stddef.h \
makefile.dependencies: m_pd.h /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdint.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdarg.h \
makefile.dependencies: /usr/include/gnu/stubs.h /usr/include/gnu/stubs-64.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stddef.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdint.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdarg.h \
makefile.dependencies: /usr/include/asm-generic/errno.h /usr/include/asm-generic/errno-base.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stddef.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdint.h \
makefile.dependencies: /usr/include/gnu/stubs-64.h /usr/include/bits/wchar.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdarg.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stddef.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdint.h \
makefile.dependencies: /usr/include/gnu/stubs-64.h /usr/include/bits/wchar.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdarg.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stddef.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdint.h \
makefile.dependencies: /usr/include/gnu/stubs-64.h /usr/include/bits/wchar.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdarg.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stddef.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdint.h \
makefile.dependencies: /usr/include/gnu/stubs-64.h /usr/include/bits/wchar.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdarg.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/limits.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/syslimits.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stddef.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdint.h \
makefile.dependencies: /usr/include/gnu/stubs-64.h /usr/include/bits/wchar.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdarg.h \
makefile.dependencies: /usr/include/asm-generic/socket.h /usr/include/asm/sockios.h \
makefile.dependencies: /usr/include/asm-generic/sockios.h /usr/include/netinet/in.h \
makefile.dependencies: /usr/include/asm-generic/errno.h /usr/include/asm-generic/errno-base.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stddef.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdint.h \
makefile.dependencies: /usr/include/gnu/stubs-64.h /usr/include/bits/wchar.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdarg.h \
makefile.dependencies: /usr/include/asm-generic/errno.h /usr/include/asm-generic/errno-base.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stddef.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdint.h \
makefile.dependencies: /usr/include/gnu/stubs-64.h /usr/include/bits/wchar.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdarg.h \
makefile.dependencies: /usr/include/asm/errno.h /usr/include/asm-generic/errno.h \
makefile.dependencies: /usr/include/asm-generic/errno-base.h s_stuff.h
makefile.dependencies: /usr/include/gnu/stubs.h /usr/include/gnu/stubs-64.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stddef.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdint.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdarg.h \
makefile.dependencies: /usr/include/gnu/stubs.h /usr/include/gnu/stubs-64.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stddef.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdint.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdarg.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stddef.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdint.h \
makefile.dependencies: /usr/include/gnu/stubs-64.h /usr/include/bits/wchar.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdarg.h \
makefile.dependencies: /usr/include/asm/errno.h /usr/include/asm-generic/errno.h \
makefile.dependencies: /usr/include/asm-generic/errno-base.h
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stddef.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdint.h \
makefile.dependencies: /usr/include/gnu/stubs-64.h /usr/include/bits/wchar.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdarg.h \
makefile.dependencies: /usr/include/gnu/stubs.h /usr/include/gnu/stubs-64.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stddef.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdarg.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdint.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stddef.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdint.h \
makefile.dependencies: /usr/include/gnu/stubs-64.h /usr/include/bits/wchar.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdarg.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stddef.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdint.h \
makefile.dependencies: /usr/include/gnu/stubs-64.h /usr/include/bits/wchar.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdarg.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stddef.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdint.h \
makefile.dependencies: /usr/include/gnu/stubs-64.h /usr/include/bits/wchar.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdarg.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stddef.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdint.h \
makefile.dependencies: /usr/include/gnu/stubs-64.h /usr/include/bits/wchar.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdarg.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stddef.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdint.h \
makefile.dependencies: /usr/include/gnu/stubs-64.h /usr/include/bits/wchar.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdarg.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stddef.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdint.h \
makefile.dependencies: /usr/include/gnu/stubs-64.h /usr/include/bits/wchar.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdarg.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stddef.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdint.h \
makefile.dependencies: /usr/include/gnu/stubs-64.h /usr/include/bits/wchar.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdarg.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stddef.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdint.h \
makefile.dependencies: /usr/include/gnu/stubs-64.h /usr/include/bits/wchar.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdarg.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stddef.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdint.h \
makefile.dependencies: /usr/include/gnu/stubs-64.h /usr/include/bits/wchar.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdarg.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stddef.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdint.h \
makefile.dependencies: /usr/include/gnu/stubs-64.h /usr/include/bits/wchar.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdarg.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stddef.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdint.h \
makefile.dependencies: /usr/include/gnu/stubs-64.h /usr/include/bits/wchar.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdarg.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stddef.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdint.h \
makefile.dependencies: /usr/include/gnu/stubs-64.h /usr/include/bits/wchar.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdarg.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stddef.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdint.h \
makefile.dependencies: /usr/include/gnu/stubs-64.h /usr/include/bits/wchar.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdarg.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stddef.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdint.h \
makefile.dependencies: /usr/include/gnu/stubs-64.h /usr/include/bits/wchar.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdarg.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stddef.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdint.h \
makefile.dependencies: /usr/include/gnu/stubs-64.h /usr/include/bits/wchar.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdarg.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stddef.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdint.h \
makefile.dependencies: /usr/include/gnu/stubs-64.h /usr/include/bits/wchar.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdarg.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stddef.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdint.h \
makefile.dependencies: /usr/include/gnu/stubs-64.h /usr/include/bits/wchar.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdarg.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stddef.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdint.h \
makefile.dependencies: /usr/include/gnu/stubs-64.h /usr/include/bits/wchar.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdarg.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/limits.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/syslimits.h \
makefile.dependencies: /usr/include/asm/param.h /usr/include/asm-generic/param.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stddef.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdint.h \
makefile.dependencies: /usr/include/gnu/stubs-64.h /usr/include/bits/wchar.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdarg.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stddef.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdint.h \
makefile.dependencies: /usr/include/gnu/stubs-64.h /usr/include/bits/wchar.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdarg.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stddef.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdint.h \
makefile.dependencies: /usr/include/gnu/stubs-64.h /usr/include/bits/wchar.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdarg.h \
makefile.dependencies: /usr/include/asm/socket.h /usr/include/asm-generic/socket.h \
makefile.dependencies: /usr/include/asm/sockios.h /usr/include/asm-generic/sockios.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stddef.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdint.h \
makefile.dependencies: /usr/include/gnu/stubs-64.h /usr/include/bits/wchar.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdarg.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stddef.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdint.h \
makefile.dependencies: /usr/include/gnu/stubs-64.h /usr/include/bits/wchar.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdarg.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stddef.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdint.h \
makefile.dependencies: /usr/include/gnu/stubs-64.h /usr/include/bits/wchar.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdarg.h \
makefile.dependencies: /usr/include/gnu/stubs-64.h /usr/include/bits/posix_opt.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stddef.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdarg.h \
makefile.dependencies: /usr/include/asm-generic/errno.h /usr/include/asm-generic/errno-base.h \
makefile.dependencies: m_pd.h /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdint.h \
makefile.dependencies: /usr/include/gnu/stubs.h /usr/include/gnu/stubs-64.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stddef.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdarg.h \
makefile.dependencies: /usr/include/asm/errno.h /usr/include/asm-generic/errno.h \
makefile.dependencies: /usr/include/asm-generic/errno-base.h /usr/include/string.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdint.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stddef.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdint.h \
makefile.dependencies: /usr/include/gnu/stubs-64.h /usr/include/bits/wchar.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdarg.h \
makefile.dependencies: /usr/include/gnu/stubs-64.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stddef.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdarg.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdint.h \
makefile.dependencies: /usr/include/gnu/stubs-64.h /usr/include/bits/posix_opt.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stddef.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdarg.h \
makefile.dependencies: /usr/include/asm/errno.h /usr/include/asm-generic/errno.h \
makefile.dependencies: /usr/include/asm-generic/errno-base.h /usr/include/alsa/asoundef.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdint.h \
makefile.dependencies: /usr/include/asm-generic/ioctls.h /usr/include/linux/ioctl.h \
makefile.dependencies: /usr/include/asm/ioctl.h /usr/include/asm-generic/ioctl.h \
makefile.dependencies: /usr/include/bits/ioctl-types.h /usr/include/sys/ttydefaults.h \
makefile.dependencies: /usr/include/gnu/stubs-64.h /usr/include/bits/posix_opt.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stddef.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdarg.h \
makefile.dependencies: /usr/include/asm/errno.h /usr/include/asm-generic/errno.h \
makefile.dependencies: /usr/include/asm-generic/errno-base.h /usr/include/alsa/asoundef.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdint.h \
makefile.dependencies: /usr/include/asm-generic/ioctls.h /usr/include/linux/ioctl.h \
makefile.dependencies: /usr/include/asm/ioctl.h /usr/include/asm-generic/ioctl.h \
makefile.dependencies: /usr/include/bits/ioctl-types.h /usr/include/sys/ttydefaults.h \
makefile.dependencies: /usr/include/gnu/stubs.h /usr/include/gnu/stubs-64.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stddef.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdarg.h \
makefile.dependencies: /usr/include/asm/errno.h /usr/include/asm-generic/errno.h \
makefile.dependencies: /usr/include/asm-generic/errno-base.h /usr/include/alsa/asoundlib.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdint.h \
makefile.dependencies: /usr/include/gnu/stubs-64.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stddef.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdarg.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdint.h \
makefile.dependencies: /usr/include/asm-generic/ioctl.h /usr/include/endian.h \
makefile.dependencies: /usr/include/gnu/stubs-64.h /usr/include/bits/endian.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stddef.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdint.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdarg.h \
makefile.dependencies: /usr/include/asm-generic/errno.h /usr/include/asm-generic/errno-base.h \
makefile.dependencies: /usr/include/asm/ioctls.h /usr/include/asm-generic/ioctls.h \
makefile.dependencies: /usr/include/bits/ioctl-types.h /usr/include/sys/ttydefaults.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stddef.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdint.h \
makefile.dependencies: /usr/include/gnu/stubs-64.h /usr/include/bits/wchar.h \
makefile.dependencies: /usr/lib/gcc/x86_64-redhat-linux/4.7.2/include/stdarg.h \
makefile.gnu:# overridden when building Pd-extended builds. <hans@at.or.at>
makefile.gnu:CPPFLAGS = -DPD -DHAVE_LIBDL -DHAVE_UNISTD_H -DHAVE_ALLOCA_H \
makefile.gnu:    -DPDGUIDIR=\"tcl/\" \
makefile.gnu:    -D_LARGEFILE64_SOURCE -DINSTALL_PREFIX=\"$(prefix)\" \
makefile.gnu:    -Wall -W -Wstrict-prototypes \
makefile.gnu:    -Wno-unused -Wno-parentheses -Wno-switch
makefile.gnu:MORECFLAGS = -O6 -fno-strict-aliasing -ffast-math -funroll-loops \
makefile.gnu:    -fomit-frame-pointer 
makefile.gnu:LDFLAGS = -Wl,-export-dynamic
makefile.gnu:LIB =   -ldl -lm -lpthread
makefile.gnu:CPPFLAGS += -DUSEAPI_ALSA
makefile.gnu:LIB += -lasound
makefile.gnu:CPPFLAGS += -DUSEAPI_JACK
makefile.gnu:LIB += -ljack
makefile.gnu:CPPFLAGS += -DUSEAPI_OSS
makefile.gnu:CPPFLAGS += -DUSEAPI_PORTAUDIO
makefile.gnu:LIB += -lportaudio
makefile.gnu:	sed 's|^.define *PD_MAJOR_VERSION *\([0-9]*\).*|\1|' )
makefile.gnu:	sed 's|^.define *PD_MINOR_VERSION *\([0-9]*\).*|\1|' )
makefile.gnu:	sed 's|^.define *PD_BUGFIX_VERSION *\([0-9]*\).*|\1|' )
makefile.gnu:	PD_VERSION := $(PD_VERSION)-$(PD_TEST_VERSION)
makefile.gnu:#  ------------------ targets ------------------------------------
makefile.gnu:all: pd $(BIN_DIR)/pd-watchdog $(BIN_DIR)/pdsend $(BIN_DIR)/pdreceive externs
makefile.gnu:bin: pd $(BIN_DIR)/pd-watchdog $(BIN_DIR)/pdsend $(BIN_DIR)/pdreceive
makefile.gnu:	$(CC) $(CFLAGS) $(GFLAGS) $(INCLUDE) -c -o $(OBJ_DIR)/$*.o $*.c 
makefile.gnu:pd-watchdog: $(BIN_DIR)/pd-watchdog
makefile.gnu:$(BIN_DIR)/pd-watchdog: $(BIN_DIR) s_watchdog.c
makefile.gnu:	$(CC) $(CFLAGS) $(STRIPFLAG) -o $(BIN_DIR)/pd-watchdog s_watchdog.c
makefile.gnu:	$(CC) $(CFLAGS)  $(STRIPFLAG) -o $(BIN_DIR)/pdsend u_pdsend.c
makefile.gnu:	$(CC) $(CFLAGS)  $(STRIPFLAG) -o $(BIN_DIR)/pdreceive u_pdreceive.c
makefile.gnu:	cd ../obj;  $(CC) $(LDFLAGS) $(DBG_CFLAGS) -o $(PDEXEC) $(OBJ) $(LIB)
makefile.gnu:	make -C ../extra/bonk~    
makefile.gnu:	make -C ../extra/choice   
makefile.gnu:	make -C ../extra/expr~    
makefile.gnu:	make -C ../extra/fiddle~  
makefile.gnu:	make -C ../extra/loop~    
makefile.gnu:	make -C ../extra/lrshift~ 
makefile.gnu:	make -C ../extra/pique    
makefile.gnu:	make -C ../extra/sigmund~ 
makefile.gnu:	make -C ../extra/pd~      
makefile.gnu:	make -C ../extra/stdout   
makefile.gnu:BINARYMODE=-m755
makefile.gnu:	install -d $(DESTDIR)$(libpdbindir)
makefile.gnu:	install $(BIN_DIR)/pd-watchdog $(DESTDIR)$(libpdbindir)/pd-watchdog
makefile.gnu:	install -d $(DESTDIR)$(bindir)
makefile.gnu:	install -m755 $(BIN_DIR)/pdsend $(DESTDIR)$(bindir)/pdsend
makefile.gnu:	install -m755 $(BIN_DIR)/pdreceive $(DESTDIR)$(bindir)/pdreceive 
makefile.gnu:	install -d $(DESTDIR)$(libpdtcldir)
makefile.gnu:	for dir in $(shell ls -1 ../doc | grep -v CVS); do \
makefile.gnu:		install -d $(DESTDIR)$(pddocdir)/$$dir ; \
makefile.gnu:		install -m644 -p ../doc/$$dir/*.* $(DESTDIR)$(pddocdir)/$$dir ; \
makefile.gnu:	for dir in $(shell ls -1 ../doc/7.stuff | grep -v CVS); do \
makefile.gnu:		install -d $(DESTDIR)$(pddocdir)/7.stuff/$$dir ; \
makefile.gnu:		install -m644 -p ../doc/7.stuff/$$dir/*.* \
makefile.gnu:	cp -pr ../extra $(DESTDIR)$(libpddir)/
makefile.gnu:	rm -f $(DESTDIR)$(libpddir)/extra/*/*.o
makefile.gnu:	install -d $(DESTDIR)$(includedir)
makefile.gnu:	install -m644 m_pd.h $(DESTDIR)$(includedir)/m_pd.h
makefile.gnu:	install -d $(DESTDIR)$(mandir)/man1
makefile.gnu:local-clean:
makefile.gnu:	-rm -f ../obj/* $(BIN_DIR)/pd $(BIN_DIR)/pdsend \
makefile.gnu:	    $(BIN_DIR)/pdreceive $(BIN_DIR)/pd-watchdog m_stamp.c \
makefile.gnu:	-rm -f `find ../portaudio -name "*.o"` 
makefile.gnu:	-rm -f *~
makefile.gnu:	-(cd ../doc/6.externs; rm -f *.pd_linux)
makefile.gnu:	-rm -f makefile.dependencies
makefile.gnu:extra-clean:
makefile.gnu:	-rm -f `find ../extra/ -name "*.pd_*"`
makefile.gnu:	-rm -f tags
makefile.gnu:clean: extra-clean local-clean
makefile.gnu:	-rm -f config.cache config.log config.status makefile tags \
makefile.gnu:	-rmdir autom4te.cache
makefile.gnu:	-rm -rf autom4te-*.cache
makefile.gnu:	test -d $(OBJ_DIR) || mkdir -p $(OBJ_DIR)
makefile.gnu:	test -d $(BIN_DIR) || mkdir -p $(BIN_DIR)
makefile.gnu:	$(CC) $(CPPFLAGS) -M $(SRC) > makefile.dependencies
makefile.gnu:	rm -f -r $(DESTDIR)$(libpddir)
makefile.gnu:	rm -f $(DESTDIR)$(bindir)/pd
makefile.gnu:	rm -f $(DESTDIR)$(bindir)/pdsend
makefile.gnu:	rm -f $(DESTDIR)$(bindir)/pdreceive
makefile.gnu:	rm -f $(DESTDIR)$(includedir)/m_pd.h
makefile.gnu:	rm -f $(DESTDIR)$(mandir)/man1/pd.1.gz
makefile.gnu:	rm -f $(DESTDIR)$(mandir)/man1/pdsend.1.gz
makefile.gnu:	rm -f $(DESTDIR)$(mandir)/man1/pdreceive.1.gz
makefile.mac:# overridden when building Pd-extended builds. <hans@at.or.at>
makefile.mac:CPPFLAGS = -DPD -DINSTALL_PREFIX=\"$(prefix)\" \
makefile.mac:    -DHAVE_LIBDL -DMACOSX -DHAVE_UNISTD_H -I/usr/X11R6/include \
makefile.mac:    -I../portaudio/include -I../portaudio/src/common  \
makefile.mac:    -I../portaudio/src/os/mac_osx/ -I../portmidi/pm_common \
makefile.mac:    -I../portmidi/pm_mac -I../portmidi/porttime \
makefile.mac:    -DUSEAPI_PORTAUDIO -DPA_USE_COREAUDIO -DNEWBUFFER
makefile.mac:ARCH_CFLAGS = -isysroot /Developer/SDKs/MacOSX10.4u.sdk -arch i386 -arch ppc 
makefile.mac:WARN_CFLAGS = -Wall -W -Wstrict-prototypes -Wno-unused -Wno-parentheses \
makefile.mac:    -Wno-switch
makefile.mac:MORECFLAGS = -Wno-error -ffast-math -fno-strict-aliasing -O6
makefile.mac:LDFLAGS = -Wl -framework CoreAudio -framework AudioUnit \
makefile.mac:    -framework AudioToolbox -framework Carbon -framework CoreMIDI \
makefile.mac:    -arch i386 -arch ppc
makefile.mac:LIB =   -ldl -lm -lpthread
makefile.mac:	sed 's|^.define *PD_MAJOR_VERSION *\([0-9]*\).*|\1|' )
makefile.mac:	sed 's|^.define *PD_MINOR_VERSION *\([0-9]*\).*|\1|' )
makefile.mac:	sed 's|^.define *PD_BUGFIX_VERSION *\([0-9]*\).*|\1|' )
makefile.mac:	PD_VERSION := $(PD_VERSION)-$(PD_TEST_VERSION)
makefile.mac:#  ------------------ targets ------------------------------------
makefile.mac:all: pd $(BIN_DIR)/pd-watchdog gui $(BIN_DIR)/pdsend \
makefile.mac:bin: pd $(BIN_DIR)/pd-watchdog gui $(BIN_DIR)/pdsend \
makefile.mac:	$(CC) $(CFLAGS) $(INCLUDE) -c -o $(OBJ_DIR)/$*.o $*.c 
makefile.mac:pd-watchdog: $(BIN_DIR)/pd-watchdog
makefile.mac:	test -d $(BIN_DIR) || mkdir -p $(BIN_DIR)
makefile.mac:$(BIN_DIR)/pd-watchdog: s_watchdog.c $(BIN_DIR)
makefile.mac:	$(CC) $(CFLAGS) $(STRIPFLAG) -o $(BIN_DIR)/pd-watchdog s_watchdog.c
makefile.mac:	$(CC) $(CFLAGS)  $(STRIPFLAG) -o $(BIN_DIR)/pdsend u_pdsend.c
makefile.mac:	$(CC) $(CFLAGS)  $(STRIPFLAG) -o $(BIN_DIR)/pdreceive u_pdreceive.c
makefile.mac:	cd ../obj;  $(CC) $(LDFLAGS) $(DBG_CFLAGS) -o $(PDEXEC) $(OBJ) $(LIB)
makefile.mac:	make -C ../extra/bonk~    d_fat
makefile.mac:	make -C ../extra/choice   d_fat
makefile.mac:	make -C ../extra/expr~    d_fat
makefile.mac:	make -C ../extra/fiddle~  d_fat
makefile.mac:	make -C ../extra/loop~    d_fat
makefile.mac:	make -C ../extra/lrshift~ d_fat
makefile.mac:	make -C ../extra/pique    d_fat
makefile.mac:	make -C ../extra/sigmund~ d_fat
makefile.mac:	make -C ../extra/pd~      d_fat
makefile.mac:	make -C ../extra/stdout   d_fat
makefile.mac:BINARYMODE=-m755
makefile.mac:	install -d $(DESTDIR)$(libpdbindir)
makefile.mac:	-install $(BIN_DIR)/$(GUINAME) $(DESTDIR)$(libpdbindir)/$(GUINAME)
makefile.mac:	install $(BIN_DIR)/pd-watchdog $(DESTDIR)$(libpdbindir)/pd-watchdog
makefile.mac:	install -d $(DESTDIR)$(bindir)
makefile.mac:	install -m755 $(BIN_DIR)/pdsend $(DESTDIR)$(bindir)/pdsend
makefile.mac:	install -m755 $(BIN_DIR)/pdreceive $(DESTDIR)$(bindir)/pdreceive 
makefile.mac:	install -d $(DESTDIR)$(libpdtcldir)
makefile.mac:	for dir in $(shell ls -1 ../doc | grep -v CVS); do \
makefile.mac:		install -d $(DESTDIR)$(pddocdir)/$$dir ; \
makefile.mac:		install -m644 -p ../doc/$$dir/*.* $(DESTDIR)$(pddocdir)/$$dir ; \
makefile.mac:	for dir in $(shell ls -1 ../doc/7.stuff | grep -v CVS); do \
makefile.mac:		install -d $(DESTDIR)$(pddocdir)/7.stuff/$$dir ; \
makefile.mac:		install -m644 -p ../doc/7.stuff/$$dir/*.* \
makefile.mac:	cp -pr ../extra $(DESTDIR)$(libpddir)/
makefile.mac:	rm -f $(DESTDIR)$(libpddir)/extra/*/*.o
makefile.mac:	install -d $(DESTDIR)$(includedir)
makefile.mac:	install -m644 m_pd.h $(DESTDIR)$(includedir)/m_pd.h
makefile.mac:	install -d $(DESTDIR)$(mandir)/man1
makefile.mac:local-clean:
makefile.mac:	-rm -f ../obj/* $(BIN_DIR)/pd $(BIN_DIR)/pdsend \
makefile.mac:	    $(BIN_DIR)/pdreceive $(BIN_DIR)/pd-watchdog m_stamp.c \
makefile.mac:	-rm -f `find ../portaudio -name "*.o"` 
makefile.mac:	-rm -f *~
makefile.mac:	-(cd ../doc/6.externs; rm -f *.pd_linux)
makefile.mac:	-rm -f makefile.dependencies
makefile.mac:extra-clean:
makefile.mac:	-rm -f `find ../extra/ -name "*.pd_*"`
makefile.mac:	-rm -f tags
makefile.mac:clean: extra-clean local-clean
makefile.mac:	-rm -f config.cache config.log config.status makefile tags \
makefile.mac:	-rmdir autom4te.cache
makefile.mac:	-rm -rf autom4te-*.cache
makefile.mac:	$(CC) $(CPPFLAGS) -M $(SRC) > makefile.dependencies
makefile.mac:	rm -f -r $(DESTDIR)$(libpddir)
makefile.mac:	rm -f $(DESTDIR)$(bindir)/pd
makefile.mac:	rm -f $(DESTDIR)$(bindir)/pdsend
makefile.mac:	rm -f $(DESTDIR)$(bindir)/pdreceive
makefile.mac:	rm -f $(DESTDIR)$(includedir)/m_pd.h
makefile.mac:	rm -f $(DESTDIR)$(mandir)/man1/pd.1.gz
makefile.mac:	rm -f $(DESTDIR)$(mandir)/man1/pdsend.1.gz
makefile.mac:	rm -f $(DESTDIR)$(mandir)/man1/pdreceive.1.gz
makefile.mingw:# http://lists.puredata.info/pipermail/pd-dev/2004-10/002981.html
makefile.mingw:GFLAGS = -DINSTALL_PREFIX=\"$(prefix)\"
makefile.mingw:# overridden when building Pd-extended builds. <hans@at.or.at>
makefile.mingw:MORECFLAGS = -O3 -funroll-loops -fomit-frame-pointer 
makefile.mingw:ASIOINC = -I$(ASIODIR)/common -I$(ASIODIR)/host -I$(ASIODIR)/host/pc
makefile.mingw:INCPA = -I$(PADIR)/include -I$(PADIR)/src/common -I$(PADIR)/src/os/win \
makefile.mingw:INCLUDE = -I$(pd_src)/src 
makefile.mingw:GINCLUDE = -I/usr/local/include $(INCLUDE)
makefile.mingw:LIBS = -lm -lwsock32 -lwinmm -lole32 -lpthreadGC2
makefile.mingw:WARN_CFLAGS = -Wall -W -Wstrict-prototypes -Wno-unused \
makefile.mingw:    -Wno-unused-parameter -Wno-parentheses -Wno-switch
makefile.mingw:# XP SP1.  WINVER isnt' fine-grained enough for that, so we use the
makefile.mingw:ARCH_CFLAGS = -DPD -DPD_INTERNAL -DPA_USE_ASIO -DPA_USE_WMME -DWINVER=0x0502 \
makefile.mingw: 	-DUSEAPI_MMIO -DUSEAPI_PORTAUDIO -mms-bitfields -DWISHAPP='"wish85.exe"'
makefile.mingw:STRIP = strip --strip-unneeded -R .note -R .comment
makefile.mingw:PMINCLUDE = -I$(PMDIR)/pm_common -I$(PMDIR)/pm_win -I$(PMDIR)/porttime -DNEWBUFFER
makefile.mingw:	sed 's|^.define *PD_MAJOR_VERSION *\([0-9]*\).*|\1|' )
makefile.mingw:	sed 's|^.define *PD_MINOR_VERSION *\([0-9]*\).*|\1|' )
makefile.mingw:	sed 's|^.define *PD_BUGFIX_VERSION *\([0-9]*\).*|\1|' )
makefile.mingw:	PD_VERSION := $(PD_VERSION)-$(PD_TEST_VERSION)
makefile.mingw:#  ------------------ targets ------------------------------------
makefile.mingw:	$(CC) $(CFLAGS) $(GFLAGS) $(INCLUDE) -c -o $*.o $*.c 
makefile.mingw:	$(CC) $(CFLAGS) $(GFLAGS) $(GINCLUDE) -c -o $*.o $*.c 
makefile.mingw:	$(CC) $(CFLAGS) $(GFLAGS) $(INCLUDE) -c -o $*.o $*.c 
makefile.mingw:	$(CC) $(CFLAGS) $(GFLAGS) $(INCPA) -c -o $*.o $*.c 
makefile.mingw:	$(CXX) $(CFLAGS) $(INCPA) -c -o $*.o $*.cpp
makefile.mingw:	$(CC) $(CFLAGS) $(GFLAGS) $(PMINCLUDE) -c -o $*.o $*.c 
makefile.mingw:	$(CC) $(CFLAGS) $(GFLAGS) $(INCLUDE) -c -o $*.o $*.c 
makefile.mingw:	$(CC) $(CFLAGS) $(LDFLAGS) -o pdsend.exe u_pdsend.o $(LIBS)
makefile.mingw:	$(CC) $(CFLAGS) $(LDFLAGS) -o pdreceive.exe u_pdreceive.o $(LIBS)
makefile.mingw:	$(CC) $(LDFLAGS) -mwindows -o $(PDEXEC) s_entry.o pd.res $(LIBS) -L. -lpd
makefile.mingw:	$(STRIP) -s $(PDEXEC)
makefile.mingw:	$(CC) $(LDFLAGS) -o pd.com s_entry.o $(LIBS) -L. -lpd
makefile.mingw:	$(STRIP) -s pd.com
makefile.mingw:	$(CXX) -shared $(LDFLAGS) -o $(PDDLL) $(OBJC) $(LIBS) \
makefile.mingw:		-Wl,--export-all-symbols -Wl,--out-implib=pd.a; 
makefile.mingw:	windres pd.rc -O coff -o pd.res
makefile.mingw:#	$(DLLWRAP) --export-all-symbols --output-def vst.def \
makefile.mingw:#	--output-lib=vst.a --dllname=vstschedlib.dll s_audio_vst.o pd.a $(LIBS)
makefile.mingw:	make -C ../extra all
makefile.mingw:	install -d $(BIN_DIR)
makefile.mingw:	install -p *.tcl $(BIN_DIR)
makefile.mingw:	install -p $(PDDLL) $(BIN_DIR)
makefile.mingw:	install -p pd.ico $(BIN_DIR)
makefile.mingw:	install -p pd.com $(BIN_DIR)
makefile.mingw:	install -p $(PDEXEC) $(BIN_DIR)
makefile.mingw:#	make libpddir=$(libpddir) -C ../po install
makefile.mingw:#	make libpddir=$(libpddir) -C ../extra install
makefile.mingw:	install -d $(DESTDIR)$(bindir)
makefile.mingw:	install -p ../tcl/*.tcl $(DESTDIR)$(bindir)/
makefile.mingw:	install -p $(PDEXEC) $(DESTDIR)$(bindir)/$(PDEXEC)
makefile.mingw:	install -p pd.com $(DESTDIR)$(bindir)/pd.com
makefile.mingw:	install -p pd.dll $(DESTDIR)$(bindir)/pd.dll
makefile.mingw:	install -p pd.ico $(DESTDIR)$(bindir)/pd.ico
makefile.mingw:	install -p pdsend.exe $(DESTDIR)$(bindir)/pdsend.exe
makefile.mingw:	install -p pdreceive.exe $(DESTDIR)$(bindir)/pdreceive.exe
makefile.mingw:	for dir in $(shell ls -1 ../doc | grep -v CVS); do \
makefile.mingw:		install -d $(DESTDIR)$(pddocdir)/$$dir ; \
makefile.mingw:		install -p ../doc/$$dir/*.* $(DESTDIR)$(pddocdir)/$$dir ; \
makefile.mingw:	for dir in $(shell ls -1 ../doc/7.stuff | grep -v CVS); do \
makefile.mingw:		install -d $(DESTDIR)$(pddocdir)/7.stuff/$$dir ; \
makefile.mingw:		install -p ../doc/7.stuff/$$dir/*.* $(DESTDIR)$(pddocdir)/7.stuff/$$dir ; \
makefile.mingw:	install -d $(DESTDIR)$(libpddir)/extra
makefile.mingw:#	install -p $(pd_src)/extra/*/*.dll $(DESTDIR)$(libpddir)/extra
makefile.mingw:	install -p $(pd_src)/extra/*.pd $(DESTDIR)$(libpddir)/extra
makefile.mingw:	install -d $(DESTDIR)$(pddocdir)/5.reference
makefile.mingw:	install -p ../extra/*/*.pd $(DESTDIR)$(pddocdir)/5.reference
makefile.mingw:	install -p ../extra/*-help.pd $(DESTDIR)$(pddocdir)/5.reference
makefile.mingw:	install -d $(DESTDIR)$(includedir)
makefile.mingw:	install -p m_pd.h $(DESTDIR)$(includedir)/m_pd.h
makefile.mingw:	install -p s_stuff.h $(DESTDIR)$(includedir)/s_stuff.h
makefile.mingw:	-rm -f -- $(BIN_DIR)/*.*
makefile.mingw:	-rm -f -- *.o *.a *.def
makefile.mingw:	-rm -f -- pd*.exe pd*.dll pd.com
makefile.mingw:	-rm -f -- $(OBJ) $(GOBJ) $(SROBJ) $(PAOBJ) $(ASIOOBJ) $(PMOBJ)
makefile.mingw:	-rm -f -- $(pd_src)/extra/*/*.dll $(pd_src)/extra/*/*.o
makefile.mingw:	-rm -f makefile.dependencies
makefile.mingw:	rm -rf -- config.cache config.log config.status makefile tags \
makefile.mingw:	     autom4te-*.cache
makefile.mingw:	$(CC) $(INCLUDE) $(INCPA) $(CFLAGS) -M $(SRC) $(PASRC) $(HEADERS) \
makefile.mingw:	-rm $(prefix)/bin/pd*.exe
makefile.mingw:	-rm $(prefix)/bin/pd*.com
makefile.mingw:	-rm $(prefix)/bin/pd*.dll
makefile.mingw:	-rm $(prefix)/bin/*.tcl
makefile.msvc:# Makefile for PD using Microsoft Visual C/C++ (MSVC) -- note defines
makefile.msvc:PDINCLUDE = -I.\\ -I..\\Tcl\\include -I$(VC9)\\Include \
makefile.msvc: -I$(VCSDK)\\Include
makefile.msvc:	-DPA_LITTLE_ENDIAN -DUSEAPI_MMIO -DUSEAPI_PORTAUDIO -D__i386__ -DPA19 \
makefile.msvc:        -D_CRT_SECURE_NO_WARNINGS
makefile.msvc:INCPA = -I$(PADIR)\\include -I$(PADIR)\\src\\common -I$(PADIR)\\src\\os\\win \
makefile.msvc:    -I..\\lib\\asio
makefile.msvc:INCPM = -I$(PMDIR)\\pm_common -I$(PMDIR)\\pm_win -I$(PMDIR)\\porttime -DNEWBUFFER
makefile.msvc:	$(MSCC) /c -DCOMMANDVERSION s_entry_com.c 
makefile.msvc:	-DWINVER=0x400 -DKSAUDIO_SPEAKER_DIRECTOUT \
m_atom.c:/* Copyright (c) 1997-1999 Miller Puckette.
m_atom.c:    if (a->a_type == A_FLOAT) return (a->a_w.w_float);
m_atom.c:    if (a->a_type == A_SYMBOL) return (a->a_w.w_symbol);
m_atom.c:    if (a->a_type == A_SYMBOL) return (a->a_w.w_symbol);
m_atom.c:    else if (a->a_type == A_FLOAT)
m_atom.c:        sprintf(buf, "%g", a->a_w.w_float);
m_atom.c:    if (argv->a_type == A_FLOAT) return (argv->a_w.w_float);
m_atom.c:    if (argv->a_type == A_SYMBOL) return (argv->a_w.w_symbol);
m_atom.c:    switch(a->a_type)
m_atom.c:        sprintf(tbuf, "%g", a->a_w.w_float);
m_atom.c:        if (strlen(tbuf) < bufsize-1) strcpy(buf, tbuf);
m_atom.c:        else if (a->a_w.w_float < 0) strcpy(buf, "-");
m_atom.c:        for (sp = a->a_w.w_symbol->s_name, len = 0, quote = 0; *sp; sp++, len++)
m_atom.c:            char *bp = buf, *ep = buf + (bufsize-2);
m_atom.c:            sp = a->a_w.w_symbol->s_name;
m_atom.c:            /* post("quote %s -> %s", a->a_w.w_symbol->s_name, buf); */
m_atom.c:            if (len < bufsize-1) strcpy(buf, a->a_w.w_symbol->s_name);
m_atom.c:                strncpy(buf, a->a_w.w_symbol->s_name, bufsize - 2);
m_atom.c:                strcpy(buf + (bufsize - 2), "*");
m_atom.c:        sprintf(buf, "$%d", a->a_w.w_index);
m_atom.c:        strncpy(buf, a->a_w.w_symbol->s_name, bufsize);
m_atom.c:        buf[bufsize-1] = 0;
m_binbuf.c:/* Copyright (c) 1997-1999 Miller Puckette.
m_binbuf.c:    x->b_n = 0;
m_binbuf.c:    x->b_vec = t_getbytes(0);
m_binbuf.c:    t_freebytes(x->b_vec, x->b_n * sizeof(*x->b_vec));
m_binbuf.c:    x->b_n = y->b_n;
m_binbuf.c:    x->b_vec = t_getbytes(x->b_n * sizeof(*x->b_vec));
m_binbuf.c:    memcpy(x->b_vec, y->b_vec, x->b_n * sizeof(*x->b_vec));
m_binbuf.c:    x->b_vec = t_resizebytes(x->b_vec, x->b_n * sizeof(*x->b_vec), 0);
m_binbuf.c:    x->b_n = 0;
m_binbuf.c:    t_freebytes(x->b_vec, x->b_n * sizeof(*x->b_vec));
m_binbuf.c:    x->b_vec = t_getbytes(nalloc * sizeof(*x->b_vec));
m_binbuf.c:    ap = x->b_vec;
m_binbuf.c:    x->b_n = 0;
m_binbuf.c:                        dot = (c == '.'), minus = (c == '-'),
m_binbuf.c:                        else floatstate = -1;
m_binbuf.c:                        else floatstate = -1;
m_binbuf.c:                        else if (!digit) floatstate = -1;
m_binbuf.c:                        else floatstate = -1;
m_binbuf.c:                        else floatstate = -1;
m_binbuf.c:                        else if (!digit) floatstate = -1;
m_binbuf.c:                        else floatstate = -1;
m_binbuf.c:                        else floatstate = -1;
m_binbuf.c:                        if (!digit) floatstate = -1;
m_binbuf.c:            x->b_vec = t_resizebytes(x->b_vec, nalloc * sizeof(*x->b_vec),
m_binbuf.c:                nalloc * (2*sizeof(*x->b_vec)));
m_binbuf.c:            ap = x->b_vec + natom;
m_binbuf.c:    x->b_vec = t_resizebytes(x->b_vec, nalloc * sizeof(*x->b_vec),
m_binbuf.c:        natom * sizeof(*x->b_vec));
m_binbuf.c:    x->b_n = natom;
m_binbuf.c:    for (ap = x->b_vec, indx = x->b_n; indx--; ap++)
m_binbuf.c:        if ((ap->a_type == A_SEMI || ap->a_type == A_COMMA) &&
m_binbuf.c:                length && buf[length-1] == ' ') length--;
m_binbuf.c:        if (ap->a_type == A_SEMI) buf[length-1] = '\n';
m_binbuf.c:        else buf[length-1] = ' ';
m_binbuf.c:    if (length && buf[length-1] == ' ')
m_binbuf.c:        if (newbuf = t_resizebytes(buf, length, length-1))
m_binbuf.c:            length--;
m_binbuf.c:/* LATER improve the out-of-space behavior below.  Also fix this so that
m_binbuf.c:    int newsize = x->b_n + argc, i;
m_binbuf.c:    if (ap = t_resizebytes(x->b_vec, x->b_n * sizeof(*x->b_vec),
m_binbuf.c:        newsize * sizeof(*x->b_vec)))
m_binbuf.c:            x->b_vec = ap;
m_binbuf.c:    for (ap = x->b_vec + x->b_n, i = argc; i--; ap++)
m_binbuf.c:    x->b_n = newsize;
m_binbuf.c:    binbuf_add(z, y->b_n, y->b_vec);
m_binbuf.c:    for (i = 0, ap = z->b_vec; i < z->b_n; i++, ap++)
m_binbuf.c:        switch (ap->a_type)
m_binbuf.c:            sprintf(tbuf, "$%d", ap->a_w.w_index);
m_binbuf.c:            if (!strcmp(ap->a_w.w_symbol->s_name, ";"))
m_binbuf.c:            else if (!strcmp(ap->a_w.w_symbol->s_name, ","))
m_binbuf.c:    binbuf_add(x, z->b_n, z->b_vec);
m_binbuf.c:    int newsize = x->b_n + argc, i;
m_binbuf.c:    if (ap = t_resizebytes(x->b_vec, x->b_n * sizeof(*x->b_vec),
m_binbuf.c:        newsize * sizeof(*x->b_vec)))
m_binbuf.c:            x->b_vec = ap;
m_binbuf.c:    for (ap = x->b_vec + x->b_n, i = argc; i--; ap++)
m_binbuf.c:        if (argv->a_type == A_SYMBOL)
m_binbuf.c:            char *str = argv->a_w.w_symbol->s_name, *str2;
m_binbuf.c:                    sscanf(argv->a_w.w_symbol->s_name + 1, "%d", &dollar);
m_binbuf.c:    x->b_n = newsize;
m_binbuf.c:    for (i = 0; i < x->b_n; i++)
m_binbuf.c:        postatom(1, x->b_vec + i);
m_binbuf.c:        if (x->b_vec[i].a_type == A_SEMI)
m_binbuf.c:    return (x->b_n);
m_binbuf.c:    return (x->b_vec);
m_binbuf.c: * (e.g. if the org.symbol is "$1-bla", then s will point to "1-bla")
m_binbuf.c: * (e.g. org.symbol="hu-$1mu", s="1mu")
m_binbuf.c: * if some error occured, "-1" is returned
m_binbuf.c: * e.g. "$1-bla" with list "10 20 30"
m_binbuf.c: * s="1-bla"
m_binbuf.c: * return value = 1; (s+1=="-bla")
m_binbuf.c:  if (cs==s) { /* invalid $-expansion (like "$bla") */
m_binbuf.c:    atom_string(&dollar0, buf, MAXPDSTRING/2-1);
m_binbuf.c:    atom_string(av+(argno-1), buf, MAXPDSTRING/2-1);
m_binbuf.c:  return (arglen-1);
m_binbuf.c:    char*str=s->s_name;
m_binbuf.c:    while(i--)buf2[i]=0;
m_binbuf.c:    if (!substr || substr-str >= MAXPDSTRING)
m_binbuf.c:    strncat(buf2, str, (substr-str));
m_binbuf.c:        * this happens, when expanding in a message-box, but does not happen
m_binbuf.c:        strncat(buf2, buf, MAXPDSTRING/2-1);
m_binbuf.c:            strncat(buf2, str, (substr-str));
m_binbuf.c:    t_atom *at = x->b_vec;
m_binbuf.c:    int ac = x->b_n;
m_binbuf.c:            int i, j = (target ? 0 : -1);
m_binbuf.c:                    j = -1;
m_binbuf.c:            while (ac && (at->a_type == A_SEMI || at->a_type == A_COMMA))
m_binbuf.c:                ac--,  at++;
m_binbuf.c:            if (at->a_type == A_DOLLAR)
m_binbuf.c:                if (at->a_w.w_index <= 0 || at->a_w.w_index > argc)
m_binbuf.c:                            at->a_w.w_index);
m_binbuf.c:                else if (argv[at->a_w.w_index-1].a_type != A_SYMBOL)
m_binbuf.c:                        at->a_w.w_index);
m_binbuf.c:                else s = argv[at->a_w.w_index-1].a_w.w_symbol;
m_binbuf.c:            else if (at->a_type == A_DOLLSYM)
m_binbuf.c:                if (!(s = binbuf_realizedollsym(at->a_w.w_symbol,
m_binbuf.c:                        at->a_w.w_symbol->s_name);
m_binbuf.c:            if (!(target = s->s_thing))
m_binbuf.c:                error("%s: no such object", s->s_name);
m_binbuf.c:                do at++, ac--;
m_binbuf.c:                while (ac && at->a_type != A_SEMI);
m_binbuf.c:                at++, ac--;
m_binbuf.c:            switch (at->a_type)
m_binbuf.c:                if (at->a_w.w_index > 0 && at->a_w.w_index <= argc)
m_binbuf.c:                    *msp = argv[at->a_w.w_index-1];
m_binbuf.c:                else if (at->a_w.w_index == 0)
m_binbuf.c:                            at->a_w.w_index);
m_binbuf.c:                s9 = binbuf_realizedollsym(at->a_w.w_symbol, argc, argv,
m_binbuf.c:                    error("%s: argument number out of range", at->a_w.w_symbol->s_name);
m_binbuf.c:                    SETSYMBOL(msp, at->a_w.w_symbol);
m_binbuf.c:            ac--;
m_binbuf.c:            switch (mstack->a_type)
m_binbuf.c:                typedmess(target, mstack->a_w.w_symbol, nargs-1, mstack+1);
m_binbuf.c:                if (nargs == 1) pd_float(target, mstack->a_w.w_float);
m_binbuf.c:        ac--;
m_binbuf.c:        fprintf(stderr, "read (%d %ld) -> %d\n", fd, length, readret);
m_binbuf.c:    startpost("binbuf_read "); postatom(b->b_n, b->b_vec); endpost();
m_binbuf.c:    if (!strcmp(filename + strlen(filename) - 4, ".pat") ||
m_binbuf.c:        !strcmp(filename + strlen(filename) - 4, ".mxt"))
m_binbuf.c:    for (ap = x->b_vec, indx = x->b_n; indx--; ap++)
m_binbuf.c:        if (ap->a_type == A_SYMBOL || ap->a_type == A_DOLLSYM)
m_binbuf.c:            length = 80 + strlen(ap->a_w.w_symbol->s_name);
m_binbuf.c:        if (ep - bp < length)
m_binbuf.c:            if (fwrite(sbuf, bp-sbuf, 1, f) < 1)
m_binbuf.c:        if ((ap->a_type == A_SEMI || ap->a_type == A_COMMA) &&
m_binbuf.c:            bp > sbuf && bp[-1] == ' ') bp--;
m_binbuf.c:        if (!crflag || ap->a_type != A_SEMI)
m_binbuf.c:            atom_string(ap, bp, (ep-bp)-2);
m_binbuf.c:        if (ap->a_type == A_SEMI || (!crflag && ncolumn > 65))
m_binbuf.c:    if (fwrite(sbuf, bp-sbuf, 1, f) < 1)
m_binbuf.c:#define ISSYMBOL(a, b) ((a)->a_type == A_SYMBOL && \
m_binbuf.c:    !strcmp((a)->a_w.w_symbol->s_name, (b)))
m_binbuf.c:    t_atom *vec = oldb->b_vec;
m_binbuf.c:    t_int n = oldb->b_n, nextindex, stackdepth = 0, stack[MAXSTACK],
m_binbuf.c:        natom = endmess - nextindex;
m_binbuf.c:        if (natom > MAXSTACK-10) natom = MAXSTACK-10;
m_binbuf.c:        first = nextmess->a_w.w_symbol->s_name;
m_binbuf.c:        second = (nextmess+1)->a_w.w_symbol->s_name;
m_binbuf.c:                    sprintf(buf, "%s", nextmess[i].a_w.w_symbol->s_name);
m_binbuf.c:                            atom_getfloatarg(4, natom, nextmess) -
m_binbuf.c:                            atom_getfloatarg(5, natom, nextmess) -
m_binbuf.c:                    natom--;
m_binbuf.c:                    second = (nextmess+1)->a_w.w_symbol->s_name;
m_binbuf.c:                    if (stackdepth) stackdepth--;
m_binbuf.c:                        outmess[i-2] = nextmess[i];
m_binbuf.c:                    SETSEMI(outmess + natom - 2);
m_binbuf.c:                    binbuf_add(newb, natom - 1, outmess);
m_binbuf.c:                        outmess[i-2] = nextmess[i];
m_binbuf.c:                    SETSEMI(outmess + natom - 2);
m_binbuf.c:                    binbuf_add(newb, natom - 1, outmess);
m_binbuf.c:                            + (atom_getfloatarg(5, natom, nextmess) - 1) * inc,
m_binbuf.c:                        0., -8., 0., 8., -262144., -1., -1., 0., 1.);
m_binbuf.c:                    third = (nextmess+2)->a_w.w_symbol->s_name;
m_binbuf.c:                                    0., -8., 0., 8., -262144., -1., -1., 0., 1.); 
m_binbuf.c:                                    0., -8., 0., 8., -262144., -1., -1., 0., 1.);
m_binbuf.c:                        nobj - atom_getfloatarg(2, natom, nextmess) - 1,
m_binbuf.c:                        nobj - atom_getfloatarg(4, natom, nextmess) - 1,
m_binbuf.c:                    SETFLOAT(outmess + 4, 50.*(natom-5));
m_binbuf.c:                    if (stackdepth) stackdepth--;
m_binbuf.c:                            (atom_getfloatarg(8, natom, nextmess) -
m_binbuf.c:                                         atom_getfloatarg(6, natom, nextmess) - 1),
m_binbuf.c:                            slmax - slmin + 1, /* range */
m_binbuf.c:                        SETFLOAT(outmess + 4, 50.*(natom-4));
m_binbuf.c:                        SETFLOAT(outmess + 4, 50.*(natom-4));
m_binbuf.c:                    SETFLOAT(outmess + 4, 50.*(natom-4));
m_binbuf.c:                        nobj - atom_getfloatarg(2, natom, nextmess) - 1,
m_binbuf.c:                        nobj - atom_getfloatarg(4, natom, nextmess) - 1,
m_binbuf.c:    binbuf_write(newb, "import-result.pd", "/tmp", 0);
m_binbuf.c:    for (indexin = 0; indexin <= inbuf->b_n - searchbuf->b_n; indexin++)
m_binbuf.c:        for (nmatched = 0; nmatched < searchbuf->b_n; nmatched++)
m_binbuf.c:            t_atom *a1 = &inbuf->b_vec[indexin + nmatched], 
m_binbuf.c:                *a2 = &searchbuf->b_vec[nmatched];
m_binbuf.c:            if (a1->a_type == A_SEMI || a1->a_type == A_COMMA)
m_binbuf.c:                if (a2->a_type != a1->a_type)
m_binbuf.c:            else if (a1->a_type == A_FLOAT || a1->a_type == A_DOLLAR)
m_binbuf.c:                if (a2->a_type != a1->a_type || 
m_binbuf.c:                    a1->a_w.w_float != a2->a_w.w_float)
m_binbuf.c:            else if (a1->a_type == A_SYMBOL || a1->a_type == A_DOLLSYM)
m_binbuf.c:                if ((a2->a_type != A_SYMBOL && a2->a_type != A_DOLLSYM)
m_binbuf.c:                    || (wholeword && a1->a_w.w_symbol != a2->a_w.w_symbol)
m_binbuf.c:                    || (!wholeword &&  !strstr(a1->a_w.w_symbol->s_name,
m_binbuf.c:                                        a2->a_w.w_symbol->s_name)))
m_binbuf.c:/* LATER make this evaluate the file on-the-fly. */
m_binbuf.c:    int import = !strcmp(name->s_name + strlen(name->s_name) - 4, ".pat") ||
m_binbuf.c:        !strcmp(name->s_name + strlen(name->s_name) - 4, ".mxt");
m_binbuf.c:    if (binbuf_read(b, name->s_name, dir->s_name, 0))
m_binbuf.c:        error("%s: read failed; %s", name->s_name, strerror(errno));
m_binbuf.c:        t_pd *bounda = gensym("#A")->s_thing, *boundn = s__N.s_thing;
m_binbuf.c:        gensym("#A")->s_thing = 0;
m_binbuf.c:        gensym("#A")->s_thing = bounda;
m_binbuf.c:        is still necessary -- probably not. */
m_class.c:/* Copyright (c) 1997-1999 Miller Puckette.
m_class.c:    pd_error(x, "%s: no method for '%s'", (*x)->c_name->s_name, s->s_name);
m_class.c:    if (*(*x)->c_listmethod != pd_defaultlist)
m_class.c:        (*(*x)->c_listmethod)(x, 0, 0, 0);
m_class.c:    else (*(*x)->c_anymethod)(x, &s_bang, 0, 0);
m_class.c:    if (*(*x)->c_listmethod != pd_defaultlist)
m_class.c:        (*(*x)->c_listmethod)(x, 0, 1, &at);
m_class.c:        (*(*x)->c_anymethod)(x, &s_pointer, 1, &at);
m_class.c:    if (*(*x)->c_listmethod != pd_defaultlist)
m_class.c:        (*(*x)->c_listmethod)(x, 0, 1, &at);
m_class.c:        (*(*x)->c_anymethod)(x, &s_float, 1, &at);
m_class.c:    if (*(*x)->c_listmethod != pd_defaultlist)
m_class.c:        (*(*x)->c_listmethod)(x, 0, 1, &at);
m_class.c:        (*(*x)->c_anymethod)(x, &s_symbol, 1, &at);
m_class.c:    if (argc == 0 && *(*x)->c_bangmethod != pd_defaultbang)
m_class.c:        (*(*x)->c_bangmethod)(x);
m_class.c:        if (argv->a_type == A_FLOAT &&
m_class.c:        *(*x)->c_floatmethod != pd_defaultfloat)
m_class.c:            (*(*x)->c_floatmethod)(x, argv->a_w.w_float);
m_class.c:        else if (argv->a_type == A_SYMBOL &&
m_class.c:            *(*x)->c_symbolmethod != pd_defaultsymbol)
m_class.c:            (*(*x)->c_symbolmethod)(x, argv->a_w.w_symbol);
m_class.c:        else if (argv->a_type == A_POINTER &&
m_class.c:            *(*x)->c_pointermethod != pd_defaultpointer)
m_class.c:            (*(*x)->c_pointermethod)(x, argv->a_w.w_gpointer);
m_class.c:    if ((*x)->c_anymethod != pd_defaultanything)
m_class.c:        (*(*x)->c_anymethod)(x, &s_list, argc, argv);
m_class.c:    else if ((*x)->c_patchable)
m_class.c:    "select", are actually two classes of the same name, one for the single-
m_class.c:                s->s_name, MAXPDARG);
m_class.c:            char *loadstring = class_loadsym->s_name,
m_class.c:                l1 = strlen(s->s_name), l2 = strlen(loadstring);
m_class.c:            if (l2 > l1 && !strcmp(s->s_name, loadstring + (l2 - l1)))
m_class.c:    c->c_name = c->c_helpname = s;
m_class.c:    c->c_size = size;
m_class.c:    c->c_methods = t_getbytes(0);
m_class.c:    c->c_nmethod = 0;
m_class.c:    c->c_freemethod = (t_method)freemethod;
m_class.c:    c->c_bangmethod = pd_defaultbang;
m_class.c:    c->c_pointermethod = pd_defaultpointer;
m_class.c:    c->c_floatmethod = pd_defaultfloat;
m_class.c:    c->c_symbolmethod = pd_defaultsymbol;
m_class.c:    c->c_listmethod = pd_defaultlist;
m_class.c:    c->c_anymethod = pd_defaultanything;
m_class.c:    c->c_wb = (typeflag == CLASS_PATCHABLE ? &text_widgetbehavior : 0);
m_class.c:    c->c_pwb = 0;
m_class.c:    c->c_firstin = ((flags & CLASS_NOINLET) == 0);
m_class.c:    c->c_patchable = (typeflag == CLASS_PATCHABLE);
m_class.c:    c->c_gobj = (typeflag >= CLASS_GOBJ);
m_class.c:    c->c_drawcommand = 0;
m_class.c:    c->c_floatsignalin = 0;
m_class.c:    c->c_externdir = class_extern_dir;
m_class.c:    c->c_savefn = (typeflag == CLASS_PATCHABLE ? text_save : class_nosavefn);
m_class.c:    post("class: %s", c->c_name->s_name);
m_class.c:                s->s_name, MAXPDARG);
m_class.c:        if (c->c_floatsignalin)
m_class.c:        c->c_floatsignalin = -1;
m_class.c:        for (i = 0; i < c->c_nmethod; i++)
m_class.c:            if (c->c_methods[i].me_name == sel)
m_class.c:            snprintf(nbuf, 80, "%s_aliased", sel->s_name);
m_class.c:            c->c_methods[i].me_name = gensym(nbuf);
m_class.c:                    sel->s_name, nbuf);
m_class.c:                sel->s_name, c->c_name->s_name, nbuf);
m_class.c:        c->c_methods = t_resizebytes(c->c_methods,
m_class.c:            c->c_nmethod * sizeof(*c->c_methods),
m_class.c:            (c->c_nmethod + 1) * sizeof(*c->c_methods));
m_class.c:        m = c->c_methods +  c->c_nmethod;
m_class.c:        c->c_nmethod++;
m_class.c:        m->me_name = sel;
m_class.c:        m->me_fun = (t_gotfn)fn;
m_class.c:            m->me_arg[nargs++] = argtype;
m_class.c:                c->c_name->s_name, sel->s_name);
m_class.c:        m->me_arg[nargs] = A_NULL;
m_class.c:        c->c_name->s_name, sel->s_name);
m_class.c:    c->c_bangmethod = (t_bangmethod)fn;
m_class.c:    c->c_pointermethod = (t_pointermethod)fn;
m_class.c:    c->c_floatmethod = (t_floatmethod)fn;
m_class.c:    c->c_symbolmethod = (t_symbolmethod)fn;
m_class.c:    c->c_listmethod = (t_listmethod)fn;
m_class.c:    c->c_anymethod = (t_anymethod)fn;
m_class.c:    c->c_wb = w;
m_class.c:    c->c_pwb = pw;
m_class.c:    return (c->c_name->s_name);
m_class.c:    return (c->c_helpname->s_name);
m_class.c:    c->c_helpname = s;
m_class.c:    return ((*x)->c_pwb);
m_class.c:    c->c_drawcommand = 1;
m_class.c:    return (c->c_drawcommand);
m_class.c:    int offset = (*x)->c_floatsignalin;
m_class.c:            (*x)->c_name->s_name);
m_class.c:    if (onset <= 0) onset = -1;
m_class.c:        if (c->c_floatmethod != pd_defaultfloat)
m_class.c:            post("warning: %s: float method overwritten", c->c_name->s_name);
m_class.c:        c->c_floatmethod = (t_floatmethod)pd_floatforsignal;
m_class.c:    c->c_floatsignalin = onset;
m_class.c:    return (c->c_externdir->s_name);
m_class.c:    c->c_savefn = f;
m_class.c:    return (c->c_savefn);
m_class.c:    c->c_propertiesfn = f;
m_class.c:    return (c->c_propertiesfn);
m_class.c:/* ---------------- the symbol table ------------------------ */
m_class.c:    sym1 = symhash + (hash2 & (HASHSIZE-1));
m_class.c:        if (!strcmp(sym2->s_name, s)) return(sym2);
m_class.c:        sym1 = &sym2->s_next;
m_class.c:        sym2->s_name = t_getbytes(length+1);
m_class.c:        sym2->s_next = 0;
m_class.c:        sym2->s_thing = 0;
m_class.c:        strcpy(sym2->s_name, s);
m_class.c:    char namebuf[MAXPDSTRING], *str = s->s_name;
m_class.c:    if (!strcmp(str + ln - 3, ".pd")) return (s);
m_class.c:    if (sys_load_lib(canvas_getcurrent(), s->s_name))
m_class.c:        tryingalready--;
m_class.c:    snprintf(classslashclass, MAXPDSTRING, "%s/%s", s->s_name, s->s_name);
m_class.c:    if ((fd = canvas_open(canvas_getcurrent(), s->s_name, ".pd",
m_class.c:            (fd = canvas_open(canvas_getcurrent(), s->s_name, ".pat",
m_class.c:        else error("%s: can't load abstraction within itself\n", s->s_name);
m_class.c:    for (i = sizeof(symlist)/sizeof(*symlist), sp = symlist; i--; sp++)
m_class.c:        (void) dogensym((*sp)->s_name, *sp);
m_class.c:        if (!argc) (*c->c_floatmethod)(x, 0.);
m_class.c:        else if (argv->a_type == A_FLOAT)
m_class.c:            (*c->c_floatmethod)(x, argv->a_w.w_float);
m_class.c:        (*c->c_bangmethod)(x);
m_class.c:        (*c->c_listmethod)(x, s, argc, argv);
m_class.c:        if (argc && argv->a_type == A_SYMBOL)
m_class.c:            (*c->c_symbolmethod)(x, argv->a_w.w_symbol);
m_class.c:            (*c->c_symbolmethod)(x, &s_);
m_class.c:    for (i = c->c_nmethod, m = c->c_methods; i--; m++)
m_class.c:        if (m->me_name == s)
m_class.c:        wp = m->me_arg;
m_class.c:                newest = (*((t_newgimme)(m->me_fun)))(s, argc, argv);
m_class.c:            else (*((t_messgimme)(m->me_fun)))(x, s, argc, argv);
m_class.c:                    if (argv->a_type == A_POINTER)
m_class.c:                        *ap = (t_int)(argv->a_w.w_gpointer);
m_class.c:                    argc--;
m_class.c:                    if (argv->a_type == A_FLOAT)
m_class.c:                        *dp = argv->a_w.w_float;
m_class.c:                    argc--;
m_class.c:                    if (argv->a_type == A_SYMBOL)
m_class.c:                        *ap = (t_int)(argv->a_w.w_symbol);
m_class.c:                    else if (x == &pd_objectmaker && argv->a_type == A_FLOAT
m_class.c:                        && argv->a_w.w_float == 0)
m_class.c:                    argc--;
m_class.c:        case 0 : bonzo = (*(t_fun0)(m->me_fun))
m_class.c:        case 1 : bonzo = (*(t_fun1)(m->me_fun))
m_class.c:        case 2 : bonzo = (*(t_fun2)(m->me_fun))
m_class.c:        case 3 : bonzo = (*(t_fun3)(m->me_fun))
m_class.c:        case 4 : bonzo = (*(t_fun4)(m->me_fun))
m_class.c:        case 5 : bonzo = (*(t_fun5)(m->me_fun))
m_class.c:        case 6 : bonzo = (*(t_fun6)(m->me_fun))
m_class.c:    (*c->c_anymethod)(x, s, argc, argv);
m_class.c:        s->s_name, c->c_name->s_name);
m_class.c:        t_atomtype t = argv->a_type;
m_class.c:        if (t == A_SYMBOL) pd_typedmess(x, argv->a_w.w_symbol, argc-1, argv+1);
m_class.c:            if (argc == 1) pd_pointer(x, argv->a_w.w_gpointer);
m_class.c:            if (argc == 1) pd_float(x, argv->a_w.w_float);
m_class.c:    for (i = c->c_nmethod, m = c->c_methods; i--; m++)
m_class.c:        if (m->me_name == s) return(m->me_fun);
m_class.c:    pd_error(x, "%s: no method for message '%s'", c->c_name->s_name, s->s_name);
m_class.c:    for (i = c->c_nmethod, m = c->c_methods; i--; m++)
m_class.c:        if (m->me_name == s) return(m->me_fun);
m_conf.c:/* Copyright (c) 1997-1999 Miller Puckette.
m_glob.c:/* Copyright (c) 1997-1999 Miller Puckette.
m_glob.c:        s->s_name);
m_glob.c:        gensym("audio-properties"), A_DEFFLOAT, 0);
m_glob.c:        gensym("audio-dialog"), A_GIMME, 0);
m_glob.c:        gensym("audio-setapi"), A_FLOAT, 0);
m_glob.c:        gensym("midi-setapi"), A_FLOAT, 0);
m_glob.c:        gensym("midi-properties"), A_DEFFLOAT, 0);
m_glob.c:        gensym("midi-dialog"), A_GIMME, 0);
m_glob.c:        gensym("start-path-dialog"), 0);
m_glob.c:        gensym("path-dialog"), A_GIMME, 0);
m_glob.c:        gensym("start-startup-dialog"), 0);
m_glob.c:        gensym("startup-dialog"), A_GIMME, 0);
m_glob.c:        gensym("save-preferences"), 0);
m_imp.h:/* Copyright (c) 1997-1999 Miller Puckette.
m_memory.c:/* Copyright (c) 1997-1999 Miller Puckette.
m_memory.c:        post("pd: getbytes() failed -- out of memory");
m_memory.c:        memset(((char *)ret) + oldsize, 0, newsize - oldsize);
m_memory.c:    fprintf(stderr, "resize %lx %d --> %lx %d\n", (int)old, oldsize, (int)ret, newsize);
m_memory.c:    totalmem += (newsize - oldsize);
m_memory.c:        post("pd: resizebytes() failed -- out of memory");
m_memory.c:    totalmem -= nbytes;
m_obj.c:/* Copyright (c) 1997-1999 Miller Puckette.
m_obj.c:/* this file handles Max-style patchable objects, i.e., objects which
m_obj.c:/* --------------------- generic inlets ala max ------------------ */
m_obj.c:    x->i_owner = owner;
m_obj.c:    x->i_dest = dest;
m_obj.c:        x->i_un.iu_floatsignalvalue = 0;
m_obj.c:    else x->i_symto = s2;
m_obj.c:    x->i_symfrom = s1;
m_obj.c:    x->i_next = 0;
m_obj.c:    if (y = owner->ob_inlet)
m_obj.c:        while (y2 = y->i_next) y = y2;
m_obj.c:        y->i_next = x;
m_obj.c:    else owner->ob_inlet = x;
m_obj.c:    t_inlet *x = inlet_new(owner, &owner->ob_pd, &s_signal, &s_signal);
m_obj.c:    x->i_un.iu_floatsignalvalue = f;
m_obj.c:    pd_error(x->i_owner, "inlet: expected '%s' but got '%s'",
m_obj.c:        x->i_symfrom->s_name, s->s_name);
m_obj.c:    if (x->i_symfrom == &s_bang) 
m_obj.c:        pd_vmess(x->i_dest, x->i_symto, "");
m_obj.c:    else if (!x->i_symfrom) pd_bang(x->i_dest);
m_obj.c:    else if (x->i_symfrom == &s_list)
m_obj.c:    if (x->i_symfrom == &s_pointer) 
m_obj.c:        pd_vmess(x->i_dest, x->i_symto, "p", gp);
m_obj.c:    else if (!x->i_symfrom) pd_pointer(x->i_dest, gp);
m_obj.c:    else if (x->i_symfrom == &s_list)
m_obj.c:    if (x->i_symfrom == &s_float)
m_obj.c:        pd_vmess(x->i_dest, x->i_symto, "f", (t_floatarg)f);
m_obj.c:    else if (x->i_symfrom == &s_signal)
m_obj.c:        x->i_un.iu_floatsignalvalue = f;
m_obj.c:    else if (!x->i_symfrom)
m_obj.c:        pd_float(x->i_dest, f);
m_obj.c:    else if (x->i_symfrom == &s_list)
m_obj.c:    if (x->i_symfrom == &s_symbol) 
m_obj.c:        pd_vmess(x->i_dest, x->i_symto, "s", s);
m_obj.c:    else if (!x->i_symfrom) pd_symbol(x->i_dest, s);
m_obj.c:    else if (x->i_symfrom == &s_list)
m_obj.c:    if (x->i_symfrom == &s_list || x->i_symfrom == &s_float
m_obj.c:        || x->i_symfrom == &s_symbol || x->i_symfrom == &s_pointer)
m_obj.c:            typedmess(x->i_dest, x->i_symto, argc, argv);
m_obj.c:    else if (!x->i_symfrom) pd_list(x->i_dest, s, argc, argv);
m_obj.c:    else if (argc==1 && argv->a_type == A_FLOAT)
m_obj.c:    else if (argc==1 && argv->a_type == A_SYMBOL)
m_obj.c:    if (x->i_symfrom == s)
m_obj.c:        typedmess(x->i_dest, x->i_symto, argc, argv);
m_obj.c:    else if (!x->i_symfrom)
m_obj.c:        typedmess(x->i_dest, s, argc, argv);
m_obj.c:    t_object *y = x->i_owner;
m_obj.c:    if (y->ob_inlet == x) y->ob_inlet = x->i_next;
m_obj.c:    else for (x2 = y->ob_inlet; x2; x2 = x2->i_next)
m_obj.c:        if (x2->i_next == x)
m_obj.c:        x2->i_next = x->i_next;
m_obj.c:/* ----- pointerinlets, floatinlets, syminlets: optimized inlets ------- */
m_obj.c:    gpointer_unset(x->i_pointerslot);
m_obj.c:    *(x->i_pointerslot) = *gp;
m_obj.c:    if (gp->gp_stub) gp->gp_stub->gs_refcount++;
m_obj.c:    x->i_owner = owner;
m_obj.c:    x->i_dest = 0;
m_obj.c:    x->i_symfrom = &s_pointer;
m_obj.c:    x->i_pointerslot = gp;
m_obj.c:    x->i_next = 0;
m_obj.c:    if (y = owner->ob_inlet)
m_obj.c:        while (y2 = y->i_next) y = y2;
m_obj.c:        y->i_next = x;
m_obj.c:    else owner->ob_inlet = x;
m_obj.c:    *(x->i_floatslot) = f;
m_obj.c:    x->i_owner = owner;
m_obj.c:    x->i_dest = 0;
m_obj.c:    x->i_symfrom = &s_float;
m_obj.c:    x->i_floatslot = fp;
m_obj.c:    x->i_next = 0;
m_obj.c:    if (y = owner->ob_inlet)
m_obj.c:        while (y2 = y->i_next) y = y2;
m_obj.c:        y->i_next = x;
m_obj.c:    else owner->ob_inlet = x;
m_obj.c:    *(x->i_symslot) = s;
m_obj.c:    x->i_owner = owner;
m_obj.c:    x->i_dest = 0;
m_obj.c:    x->i_symfrom = &s_symbol;
m_obj.c:    x->i_symslot = sp;
m_obj.c:    x->i_next = 0;
m_obj.c:    if (y = owner->ob_inlet)
m_obj.c:        while (y2 = y->i_next) y = y2;
m_obj.c:        y->i_next = x;
m_obj.c:    else owner->ob_inlet = x;
m_obj.c:/* ---------------------- routine to handle lists ---------------------- */
m_obj.c:    t_inlet *ip = ((t_object *)x)->ob_inlet;
m_obj.c:    for (count = argc-1, ap = argv+1; ip && count--; ap++, ip = ip->i_next)
m_obj.c:        if (ap->a_type == A_POINTER) pd_pointer(&ip->i_pd, ap->a_w.w_gpointer);
m_obj.c:        else if (ap->a_type == A_FLOAT) pd_float(&ip->i_pd, ap->a_w.w_float);
m_obj.c:        else pd_symbol(&ip->i_pd, ap->a_w.w_symbol);
m_obj.c:    if (argv->a_type == A_POINTER) pd_pointer(&x->ob_pd, argv->a_w.w_gpointer);
m_obj.c:    else if (argv->a_type == A_FLOAT) pd_float(&x->ob_pd, argv->a_w.w_float);
m_obj.c:    else pd_symbol(&x->ob_pd, argv->a_w.w_symbol);
m_obj.c:/* --------------------------- outlets ------------------------------ */
m_obj.c:    x->o_owner = owner;
m_obj.c:    x->o_next = 0;
m_obj.c:    if (y = owner->ob_outlet)
m_obj.c:        while (y2 = y->o_next) y = y2;
m_obj.c:        y->o_next = x;
m_obj.c:    else owner->ob_outlet = x;
m_obj.c:    x->o_connections = 0;
m_obj.c:    x->o_sym = s;
m_obj.c:    pd_error(x->o_owner, "stack overflow");
m_obj.c:    for (oc = x->o_connections; oc; oc = oc->oc_next)
m_obj.c:        pd_bang(oc->oc_to);
m_obj.c:    --stackcount;
m_obj.c:        for (oc = x->o_connections; oc; oc = oc->oc_next)
m_obj.c:            pd_pointer(oc->oc_to, &gpointer);
m_obj.c:    --stackcount;
m_obj.c:    for (oc = x->o_connections; oc; oc = oc->oc_next)
m_obj.c:        pd_float(oc->oc_to, f);
m_obj.c:    --stackcount;
m_obj.c:    for (oc = x->o_connections; oc; oc = oc->oc_next)
m_obj.c:        pd_symbol(oc->oc_to, s);
m_obj.c:    --stackcount;
m_obj.c:    for (oc = x->o_connections; oc; oc = oc->oc_next)
m_obj.c:        pd_list(oc->oc_to, s, argc, argv);
m_obj.c:    --stackcount;
m_obj.c:    for (oc = x->o_connections; oc; oc = oc->oc_next)
m_obj.c:        typedmess(oc->oc_to, s, argc, argv);
m_obj.c:    --stackcount;
m_obj.c:    return (x->o_sym);
m_obj.c:    t_object *y = x->o_owner;
m_obj.c:    if (y->ob_outlet == x) y->ob_outlet = x->o_next;
m_obj.c:    else for (x2 = y->ob_outlet; x2; x2 = x2->o_next)
m_obj.c:        if (x2->o_next == x)
m_obj.c:        x2->o_next = x->o_next;
m_obj.c:    for (o = source->ob_outlet; o && outno; o = o->o_next, outno--) ;
m_obj.c:    if (sink->ob_pd->c_firstin)
m_obj.c:            to = &sink->ob_pd;
m_obj.c:        else inno--;
m_obj.c:    for (i = sink->ob_inlet; i && inno; i = i->i_next, inno--) ;
m_obj.c:    to = &i->i_pd;
m_obj.c:    oc->oc_next = 0;
m_obj.c:    oc->oc_to = to;
m_obj.c:    if ((oc2 = o->o_connections))
m_obj.c:        while (oc2->oc_next) oc2 = oc2->oc_next;
m_obj.c:        oc2->oc_next = oc;
m_obj.c:    else o->o_connections = oc;
m_obj.c:    if (o->o_sym == &s_signal) canvas_update_dsp();
m_obj.c:    for (o = source->ob_outlet; o && outno; o = o->o_next, outno--)
m_obj.c:    if (sink->ob_pd->c_firstin)
m_obj.c:            to = &sink->ob_pd;
m_obj.c:        else inno--;
m_obj.c:    for (i = sink->ob_inlet; i && inno; i = i->i_next, inno--) ;
m_obj.c:    to = &i->i_pd;
m_obj.c:    if (!(oc = o->o_connections)) return;
m_obj.c:    if (oc->oc_to == to)
m_obj.c:        o->o_connections = oc->oc_next;
m_obj.c:    while (oc2 = oc->oc_next)
m_obj.c:        if (oc2->oc_to == to)
m_obj.c:            oc->oc_next = oc2->oc_next;
m_obj.c:    if (o->o_sym == &s_signal) canvas_update_dsp();
m_obj.c:/* ------ traversal routines for code that can't see our structures ------ */
m_obj.c:    for (o = x->ob_outlet, n = 0; o; o = o->o_next) n++;
m_obj.c:    for (i = x->ob_inlet, n = 0; i; i = i->i_next) n++;
m_obj.c:    if (x->ob_pd->c_firstin) n++;
m_obj.c:    t_outlet *o = x->ob_outlet;
m_obj.c:    while (nout-- && o) o = o->o_next;
m_obj.c:    if (o) return (o->o_connections);
m_obj.c:    y = lastconnect->oc_to;
m_obj.c:        t_object *dest = i->i_owner;
m_obj.c:        for (n = dest->ob_pd->c_firstin, i2 = dest->ob_inlet;
m_obj.c:            i2 && i2 != i; i2 = i2->i_next) n++;
m_obj.c:    return (lastconnect->oc_next);
m_obj.c:    if ((*x)->c_patchable) return ((t_object *)x);
m_obj.c:    if (x->ob_inlet == i) return;
m_obj.c:    else for (i2 = x->ob_inlet; i2; i2 = i2->i_next)
m_obj.c:        if (i2->i_next == i)
m_obj.c:        i2->i_next = i->i_next;
m_obj.c:        i->i_next = x->ob_inlet;
m_obj.c:        x->ob_inlet = i;
m_obj.c:    if (x->ob_outlet == o) return;
m_obj.c:    else for (o2 = x->ob_outlet; o2; o2 = o2->o_next)
m_obj.c:        if (o2->o_next == o)
m_obj.c:        o2->o_next = o->o_next;
m_obj.c:        o->o_next = x->ob_outlet;
m_obj.c:        x->ob_outlet = o;
m_obj.c:    for (i = x->ob_inlet, n = 0; i; i = i->i_next)
m_obj.c:        if (i->i_symfrom == &s_signal) n++;
m_obj.c:    if (x->ob_pd->c_firstin && x->ob_pd->c_floatsignalin) n++;
m_obj.c:    if (x->ob_pd->c_firstin && x->ob_pd->c_floatsignalin)
m_obj.c:        if (!m--) return (0);
m_obj.c:    for (i = x->ob_inlet; i; i = i->i_next, m--)
m_obj.c:        if (i->i_symfrom == &s_signal)
m_obj.c:    return (-1);
m_obj.c:    if (x->ob_pd->c_firstin)
m_obj.c:            return (x->ob_pd->c_firstin && x->ob_pd->c_floatsignalin);
m_obj.c:        else m--;
m_obj.c:    for (i = x->ob_inlet; i && m; i = i->i_next, m--)
m_obj.c:    return (i && (i->i_symfrom == &s_signal));
m_obj.c:    for (o = x->ob_outlet, n = 0; o; o = o->o_next)
m_obj.c:        if (o->o_sym == &s_signal) n++;
m_obj.c:    for (o2 = x->ob_outlet, n = 0; o2; o2 = o2->o_next, m--)
m_obj.c:        if (o2->o_sym == &s_signal)
m_obj.c:    return (-1);
m_obj.c:    for (o2 = x->ob_outlet, n = 0; o2 && m--; o2 = o2->o_next);
m_obj.c:    return (o2 && (o2->o_sym == &s_signal));
m_obj.c:    if (x->ob_pd->c_firstin && x->ob_pd->c_floatsignalin)
m_obj.c:        if (!m--)
m_obj.c:            return (x->ob_pd->c_floatsignalin > 0 ?
m_obj.c:                (t_float *)(((char *)x) + x->ob_pd->c_floatsignalin) : 0);
m_obj.c:    for (i = x->ob_inlet; i; i = i->i_next, m--)
m_obj.c:        if (i->i_symfrom == &s_signal)
m_obj.c:            return (&i->i_un.iu_floatsignalvalue);
m_obj.c:    if (x->i_symfrom != &s_signal)
m_obj.c:    for (i = x->i_owner->ob_inlet, n = 0; i && i != x; i = i->i_next)
m_obj.c:        if (i->i_symfrom == &s_signal) n++;
m_obj.c:    for (o = x->o_owner->ob_outlet, n = 0; o && o != x; o = o->o_next) 
m_obj.c:        if (o->o_sym == &s_signal) n++;
m_pd.c:/* Copyright (c) 1997-1999 Miller Puckette.
m_pd.c:    /* FIXME no out-of-memory testing yet! */
m_pd.c:    x = (t_pd *)t_getbytes(c->c_size);
m_pd.c:    if (c->c_patchable)
m_pd.c:        ((t_object *)x)->ob_inlet = 0;
m_pd.c:        ((t_object *)x)->ob_outlet = 0;
m_pd.c:    if (c->c_freemethod) (*(t_gotfn)(c->c_freemethod))(x);
m_pd.c:    if (c->c_patchable)
m_pd.c:        while (((t_object *)x)->ob_outlet)
m_pd.c:            outlet_free(((t_object *)x)->ob_outlet);
m_pd.c:        while (((t_object *)x)->ob_inlet)
m_pd.c:            inlet_free(((t_object *)x)->ob_inlet);
m_pd.c:        if (((t_object *)x)->ob_binbuf)
m_pd.c:            binbuf_free(((t_object *)x)->ob_binbuf);
m_pd.c:    if (c->c_size) t_freebytes(x, c->c_size);
m_pd.c:    t_class *c = x->g_pd;
m_pd.c:    if (c->c_savefn)
m_pd.c:        (c->c_savefn)(x, b);
m_pd.c:    for (e = x->b_list; e; e = e->e_next)
m_pd.c:        pd_bang(e->e_who);
m_pd.c:    for (e = x->b_list; e; e = e->e_next)
m_pd.c:        pd_float(e->e_who, f);
m_pd.c:    for (e = x->b_list; e; e = e->e_next)
m_pd.c:        pd_symbol(e->e_who, s);
m_pd.c:    for (e = x->b_list; e; e = e->e_next)
m_pd.c:        pd_pointer(e->e_who, gp);
m_pd.c:    for (e = x->b_list; e; e = e->e_next)
m_pd.c:        pd_list(e->e_who, s, argc, argv);
m_pd.c:    for (e = x->b_list; e; e = e->e_next)
m_pd.c:        pd_typedmess(e->e_who, s, argc, argv);
m_pd.c:    if (s->s_thing)
m_pd.c:        if (*s->s_thing == bindlist_class)
m_pd.c:            t_bindlist *b = (t_bindlist *)s->s_thing;
m_pd.c:            e->e_next = b->b_list;
m_pd.c:            e->e_who = x;
m_pd.c:            b->b_list = e;
m_pd.c:            b->b_list = e1;
m_pd.c:            e1->e_who = x;
m_pd.c:            e1->e_next = e2;
m_pd.c:            e2->e_who = s->s_thing;
m_pd.c:            e2->e_next = 0;
m_pd.c:            s->s_thing = &b->b_pd;
m_pd.c:    else s->s_thing = x;
m_pd.c:    if (s->s_thing == x) s->s_thing = 0;
m_pd.c:    else if (s->s_thing && *s->s_thing == bindlist_class)
m_pd.c:        t_bindlist *b = (t_bindlist *)s->s_thing;
m_pd.c:        if ((e = b->b_list)->e_who == x)
m_pd.c:            b->b_list = e->e_next;
m_pd.c:        else for (e = b->b_list; e2 = e->e_next; e = e2)
m_pd.c:            if (e2->e_who == x)
m_pd.c:            e->e_next = e2->e_next;
m_pd.c:        if (!b->b_list->e_next)
m_pd.c:            s->s_thing = b->b_list->e_who;
m_pd.c:            freebytes(b->b_list, sizeof(t_bindelem));
m_pd.c:            pd_free(&b->b_pd);
m_pd.c:    else pd_error(x, "%s: couldn't unbind", s->s_name);
m_pd.c:    if (!s->s_thing) return (0);
m_pd.c:    if (*s->s_thing == c) return (s->s_thing);
m_pd.c:    if (*s->s_thing == bindlist_class)
m_pd.c:        t_bindlist *b = (t_bindlist *)s->s_thing;
m_pd.c:        for (e = b->b_list; e; e = e->e_next)
m_pd.c:            if (*e->e_who == c)
m_pd.c:                post("warning: %s: multiply defined", s->s_name);
m_pd.c:            x = e->e_who;
m_pd.c:    for (foo = gstack_head; foo; foo = foo->g_next)
m_pd.c:        if (foo->g_loadingabstraction == sym)
m_pd.c:    y->g_what = s__X.s_thing;
m_pd.c:    y->g_next = gstack_head;
m_pd.c:    y->g_loadingabstraction = pd_loadingabstraction;
m_pd.c:        s__X.s_thing = headwas->g_what;
m_pd.c:        gstack_head = headwas->g_next;
m_pd.c:    (*(*x)->c_bangmethod)(x);
m_pd.c:    (*(*x)->c_floatmethod)(x, f);
m_pd.c:    (*(*x)->c_pointermethod)(x, gp);
m_pd.c:    (*(*x)->c_symbolmethod)(x, s);
m_pd.c:    (*(*x)->c_listmethod)(x, &s_list, argc, argv);
m_pd.h:/* Copyright (c) 1997-1999 Miller Puckette.
m_pd.h:/* old name for "MSW" flag -- we have to take it for the sake of many old
m_pd.h:#include <stddef.h>     /* just for size_t -- how lame! */
m_pd.h:typedef PD_LONGINTTYPE t_int;       /* pointer-size integer */
m_pd.h:    t_word sc_vec[1];       /* indeterminate-length array of words */
m_pd.h:typedef struct _text        /* patchable object - graphical, with text */
m_pd.h:/* ---------------- pre-defined objects and symbols --------------*/
m_pd.h:/* --------- prototypes from the central message system ----------- */
m_pd.h:/* --------------- memory management -------------------- */
m_pd.h:/* -------------------- atoms ----------------------------- */
m_pd.h:#define SETSEMI(atom) ((atom)->a_type = A_SEMI, (atom)->a_w.w_index = 0)
m_pd.h:#define SETCOMMA(atom) ((atom)->a_type = A_COMMA, (atom)->a_w.w_index = 0)
m_pd.h:#define SETPOINTER(atom, gp) ((atom)->a_type = A_POINTER, \
m_pd.h:    (atom)->a_w.w_gpointer = (gp))
m_pd.h:#define SETFLOAT(atom, f) ((atom)->a_type = A_FLOAT, (atom)->a_w.w_float = (f))
m_pd.h:#define SETSYMBOL(atom, s) ((atom)->a_type = A_SYMBOL, \
m_pd.h:    (atom)->a_w.w_symbol = (s))
m_pd.h:#define SETDOLLAR(atom, n) ((atom)->a_type = A_DOLLAR, \
m_pd.h:    (atom)->a_w.w_index = (n))
m_pd.h:#define SETDOLLSYM(atom, s) ((atom)->a_type = A_DOLLSYM, \
m_pd.h:    (atom)->a_w.w_symbol= (s))
m_pd.h:/* ------------------  binbufs --------------- */
m_pd.h:/* ------------------  clocks --------------- */
m_pd.h:/* ----------------- pure data ---------------- */
m_pd.h:/* ----------------- pointers ---------------- */
m_pd.h:/* ----------------- patchable "objects" -------------- */
m_pd.h:/* -------------------- canvases -------------- */
m_pd.h:/* ---------------- widget behaviors ---------------------- */
m_pd.h:/* -------------------- classes -------------- */
m_pd.h:    class_domainsignalin(c, (char *)(&((type *)0)->field) - (char *)0)
m_pd.h:/* ------------   printing --------------------------------- */
m_pd.h:/* ------------  system interface routines ------------------- */
m_pd.h:/* Win32's open()/fopen() do not handle UTF-8 filenames so we need
m_pd.h: * these internal versions that handle UTF-8 filenames the same across
m_pd.h:/* ------------  threading ------------------- */ 
m_pd.h:/* --------------- signals ----------------------------------- */
m_pd.h:/* ----------------------- utility functions for signals -------------- */
m_pd.h:/* --------------------- data --------------------------------- */
m_pd.h:/* ------- GUI interface - functions to send strings to TK --------- */
m_pd.h:/*-------------  Max 0.26 compatibility --------------------*/
m_pd.h:/* A definition to help gui objects straddle 0.34-0.35 changes.  If this is
m_pd.h:/* more stringent test: anything not between 1e-19 and 1e19 in absolute val */
m_sched.c:/* Copyright (c) 1997-1999 Miller Puckette.
m_sched.c:    x->c_settime = -1;
m_sched.c:    x->c_owner = owner;
m_sched.c:    x->c_fn = (t_clockmethod)fn;
m_sched.c:    x->c_next = 0;
m_sched.c:    if (x->c_settime >= 0)
m_sched.c:        if (x == clock_setlist) clock_setlist = x->c_next;
m_sched.c:            while (x2->c_next != x) x2 = x2->c_next;
m_sched.c:            x2->c_next = x->c_next;
m_sched.c:        x->c_settime = -1;
m_sched.c:    x->c_settime = setticks;
m_sched.c:    if (clock_setlist && clock_setlist->c_settime <= setticks)
m_sched.c:        for (cbefore = clock_setlist, cafter = clock_setlist->c_next;
m_sched.c:            cbefore; cbefore = cafter, cafter = cbefore->c_next)
m_sched.c:            if (!cafter || cafter->c_settime > setticks)
m_sched.c:                cbefore->c_next = x;
m_sched.c:                x->c_next = cafter;
m_sched.c:    else x->c_next = clock_setlist, clock_setlist = x;
m_sched.c:    return ((sys_time - prevsystime)/sys_time_per_msec);
m_sched.c:/* the following routines maintain a real-execution-time histogram of the
m_sched.c:various phases of real-time execution. */
m_sched.c:    int msec = (newtime - sys_histtime) * 1000.;
m_sched.c:    for (j = NBIN-1; j >= 0; j--)
m_sched.c:    nresyncphase = oss_resyncphase - 1;
m_sched.c:            (sched_diddsp - oss_resync[nresyncphase].r_ntick)
m_sched.c:        nresyncphase--;
m_sched.c:    if (sys_nogui && sys_hipriority && (sched_diddsp - sched_nextpingtime > 0))
m_sched.c:    if (sched_diddsp - sched_nextmeterpolltime < 0)
m_sched.c:    if (sched_diored && (sched_diddsp - sched_dioredtime > 0))
m_sched.c:        -1;
m_sched.c:    while (clock_setlist && clock_setlist->c_settime < next_sys_time)
m_sched.c:        sys_time = c->c_settime;
m_sched.c:        (*c->c_fn)(c->c_owner);
m_sched.c:        if (!countdown--)
m_sched.c:            /* T.Grill - send_dacs may sleep -> 
m_sched.c:                - could messaging do any harm while sys_send_dacs is running?
m_sched.c:            /* T.Grill - done */
m_sched.c:                    else if (sys_getrealtime() - idletime > 1.)
m_sched.c:            if (1000. * (sys_getrealtime() - sched_referencerealtime)
m_sched.c:        sys_setmiditimediff(0, 1e-6 * sys_schedadvance);
m_sched.c:    sys_setmiditimediff(0, 1e-6 * sys_schedadvance);
m_sched.c:/* ------------ thread locking ------------------- */
notes.txt:---------------- dolist --------------------
notes.txt:  check the right-click-on-empty-canvas
notes.txt:  "-audiodev" with no args in registry can't start up?
notes.txt:check real-time gaps in writesf~
notes.txt:add -stack option to make 'regular' stack larger
notes.txt:don't draw in/outlets on gui objects in graph-on-parent
notes.txt:loading e-mailed patches without removing headers crashes pd
notes.txt:real-time spectrum grapher
notes.txt:"installation mode" - turn off Pd window, accelerators, menu bars, scrollbars
notes.txt:machine-independent fonts
notes.txt:sigmund~: sort by pitch; one-shot
notes.txt:poly inlet to turn stealing on/off, plus mode to handle note-with-duration
notes.txt:delete-in-rectangle message to Pds
notes.txt:flags to defeat pre-loading specified classes
notes.txt:    tab to jump to a connected object (first one?) (shift-tab to back up?)
notes.txt:    option-drag an outlet to make a new, connected object
notes.txt:add -x [-n?] flag to drawnumbers
notes.txt:make a 2-pass process for finding hot spot closest to any given click
notes.txt:arrays of non-existent templates crash
notes.txt:non-clickable arrays (plus arrays that respond more easily than default)
notes.txt:set -any, get -any
notes.txt:"-march=pentium4 -O2 -mfpmath=sse -msse -msse2 -mmmx" ?
notes.txt:try to improve for AMD - try "-march=athlon-xp -msse2"
notes.txt:search for -mcpu=cpu-type in man gcc.
notes.txt:-Wno-unused to -Wno-unused-paramter and clean up unused automatic variables
notes.txt:security module system in 2.6 - see the kernel module replacing jackstart
notes.txt:investigate gcc 3.3 warnings; try to reinstate -fstrict-aliasing
notes.txt:close-subwindows menu item
notes.txt:windows escape from control-C
notes.txt:in glist_delete, consider why this can't be just "vis 0" -- why do we need it?
notes.txt:obj_new should do a longjmp on out-of-memory
Binary file pd.ico matches
pd.rc:      VALUE "FileVersion", "0.44-3"
pd.rc:      VALUE "ProductVersion", "0.44-3"
s_audio_alsa.c:/* Copyright (c) 1997-2003 Guenter Geiger, Miller Puckette, Larry Troxler,
s_audio_alsa.c:    /* don't assume we can turn all 31 bits when doing float-to-fix;
s_audio_alsa.c:#define CLIP32(x) (((x)>FMAX)?FMAX:((x) < -FMAX)?-FMAX:(x))
s_audio_alsa.c:    err1 = snd_pcm_hw_params_any(dev->a_handle, hw_params);
s_audio_alsa.c:      check_error(err1, -1, "snd_pcm_hw_params_any");
s_audio_alsa.c:    err1 = snd_pcm_hw_params_set_access(dev->a_handle,
s_audio_alsa.c:        err2 = snd_pcm_hw_params_set_access(dev->a_handle,
s_audio_alsa.c:    else err2 = -1;
s_audio_alsa.c:/* set up an input or output device.  Return 0 on success, -1 on failure. */
s_audio_alsa.c:    err = snd_pcm_hw_params_any(dev->a_handle, hw_params);
s_audio_alsa.c:    err = snd_pcm_hw_params_set_access(dev->a_handle,
s_audio_alsa.c:        return (-1);
s_audio_alsa.c:            fprintf(stderr, "%d -> %d\n",
s_audio_alsa.c:                i, snd_pcm_hw_params_test_format(dev->a_handle, hw_params, i));
s_audio_alsa.c:    err = snd_pcm_hw_params_set_format(dev->a_handle,
s_audio_alsa.c:        err = snd_pcm_hw_params_set_format(dev->a_handle, hw_params,
s_audio_alsa.c:            err = snd_pcm_hw_params_set_format(dev->a_handle, hw_params,
s_audio_alsa.c:            dev->a_sampwidth = 2;
s_audio_alsa.c:        else dev->a_sampwidth = 3;
s_audio_alsa.c:    else dev->a_sampwidth = 4;
s_audio_alsa.c:        post("Sample width set to %d bytes", dev->a_sampwidth);
s_audio_alsa.c:    err = snd_pcm_hw_params_set_subformat(dev->a_handle,
s_audio_alsa.c:    err = snd_pcm_hw_params_set_channels_min(dev->a_handle,
s_audio_alsa.c:    dev->a_channels = *channels;
s_audio_alsa.c:    err = snd_pcm_hw_params_set_rate_near(dev->a_handle, hw_params,
s_audio_alsa.c:    err = snd_pcm_hw_params_set_period_size_near(dev->a_handle,
s_audio_alsa.c:    err = snd_pcm_hw_params_set_buffer_size_near(dev->a_handle,
s_audio_alsa.c:    err = snd_pcm_hw_params(dev->a_handle, hw_params);
s_audio_alsa.c:    bufsizeforthis = DEFDACBLKSIZE * dev->a_sampwidth * *channels;
s_audio_alsa.c:                return (-1);
s_audio_alsa.c:            return (-1);
s_audio_alsa.c:    err = snd_pcm_sw_params_current(dev->a_handle, sw_params);
s_audio_alsa.c:        return (-1);
s_audio_alsa.c:    err = snd_pcm_sw_params_set_stop_threshold(dev->a_handle, sw_params,
s_audio_alsa.c:        return (-1);
s_audio_alsa.c:    err = snd_pcm_sw_params_set_avail_min(dev->a_handle, sw_params, 4);
s_audio_alsa.c:        return (-1);
s_audio_alsa.c:    err = snd_pcm_sw_params(dev->a_handle, sw_params);
s_audio_alsa.c:        return (-1);
s_audio_alsa.c:        check_error(err, -1, "snd_pcm_status_malloc");
s_audio_alsa.c:        while (i--)
s_audio_alsa.c:                        check_error(err, -1, "input start failed");
s_audio_alsa.c:    if (timenow - timelast > 0.050)
s_audio_alsa.c:            (int)(1000 * (timenow - timelast))), fflush(stderr);
s_audio_alsa.c:        chansouttogo -= chans;
s_audio_alsa.c:                for (j = i, k = DEFDACBLKSIZE, fp2 = fp1; k--;
s_audio_alsa.c:                for (j = i, k = DEFDACBLKSIZE; k--; j += thisdevchans)
s_audio_alsa.c:                for (j = i, k = DEFDACBLKSIZE, fp2 = fp1; k--;
s_audio_alsa.c:                else if (s < -8388351)
s_audio_alsa.c:                    s = -8388351;
s_audio_alsa.c:                fprintf(stderr, "big endian 24-bit not supported");
s_audio_alsa.c:                for (j = i, k = DEFDACBLKSIZE; k--; j += thisdevchans)
s_audio_alsa.c:                for (j = ch, k = DEFDACBLKSIZE, fp2 = fp1; k--;
s_audio_alsa.c:                else if (s < -32767)
s_audio_alsa.c:                    s = -32767;
s_audio_alsa.c:                for (j = ch, k = DEFDACBLKSIZE; k--; j += thisdevchans)
s_audio_alsa.c:            if (result == -EPIPE)
s_audio_alsa.c:        if (sys_getrealtime() - timenow > 0.002)
s_audio_alsa.c:                    callno, (int)(1000 * (timenow - timelast))), fflush(stderr);
s_audio_alsa.c:        chansouttogo -= chans;
s_audio_alsa.c:            if (result == -EPIPE)
s_audio_alsa.c:                for (j = ch, k = DEFDACBLKSIZE, fp2 = fp1; k--;
s_audio_alsa.c:                for (j = ch, k = DEFDACBLKSIZE, fp2 = fp1; k--;
s_audio_alsa.c:                fprintf(stderr, "big endian 24-bit not supported");
s_audio_alsa.c:                for (j = ch, k = DEFDACBLKSIZE, fp2 = fp1; k--;
s_audio_alsa.c:                            * 3.051850e-05;
s_audio_alsa.c:    if (sys_getrealtime() - timenow > 0.002)
s_audio_alsa.c:            (int)(1000 * (sys_getrealtime() - timenow)));
s_audio_alsa.c:        if (!checkcountdown--)
s_audio_alsa.c:        error("restart-audio: implemented for ALSA only.");
s_audio_alsa.c:        if (giveup-- <= 0)
s_audio_alsa.c:        maxphase = -0x7fffffff;
s_audio_alsa.c:            thisphase = alsa_buf_samps - outdelay;
s_audio_alsa.c:            thisphase = alsa_buf_samps - outdelay;
s_audio_alsa.c:    alsa_names[alsa_nnames] = gensym(name)->s_name;
s_audio_alsa.c:    int ndev = 0, cardno = -1;
s_audio_alsa.c:        snprintf(devname, nchar, "%s", alsa_names[devno - 2*ndev]);
s_audio_alsa.c:    int ndev = 0, cardno = -1, i, j;
s_audio_alsa.c:        sprintf(indevlist + (2*ndev + 1) * devdescsize, "%s (plug-in)", desc);
s_audio_alsa.c:        sprintf(outdevlist + (2*ndev + 1) * devdescsize, "%s (plug-in)", desc);
s_audio_alsa.h:/* Copyright (c) 1997- Guenter Geiger, Miller Puckette, Larry Troxler,
s_audio_alsamm.c:/* Copyright (c) 1997-2003 Guenter Geiger, Miller Puckette, Larry Troxler,
s_audio_alsamm.c:    - audio Card with ALSA-Driver > 1.0.3, 
s_audio_alsamm.c:    - alsa-device (preferable hw) with MMAP NONINTERLEAVED SIGNED-32Bit features
s_audio_alsamm.c:    - up to 4 cards with has to be hardwaresynced
s_audio_alsamm.c:    don't assume we can turn all 31 bits when doing float-to-fix; 
s_audio_alsamm.c:#define CLIP32(x) (((x)>F32MAX)?F32MAX:((x) < -F32MAX)?-F32MAX:(x))
s_audio_alsamm.c:   you can mix rme9632,hdsp9632 (18 chans) rme9652,hdsp9652 (26 chans), dsp-madi (64 chans) 
s_audio_alsamm.c:   due the need to link in and out-device on one card
s_audio_alsamm.c:   time is in us,   size in frames (i hope so ;-)
s_audio_alsamm.c:    alsa_indev[i].a_channels=alsa_outdev[i].a_channels=-1; /* query defaults */
s_audio_alsamm.c:  alsamm_periods = 0; /* no one wants periods setting from command line ;-) */
s_audio_alsamm.c:        post("capture card %d:--------------------",i);
s_audio_alsamm.c:  /* start ---------------------------- */
s_audio_alsamm.c:/* ------- PCM INITS --------------------------------- */
s_audio_alsamm.c:  dir=-1;
s_audio_alsamm.c:  err = snd_pcm_sw_params_set_stop_threshold(handle, swparams, (snd_pcm_uframes_t)-1);
s_audio_alsamm.c:    return -1;
s_audio_alsamm.c:    return -1;
s_audio_alsamm.c:  if (err == -EPIPE) {    /* under-run */
s_audio_alsamm.c:  } else if (err == -ESTRPIPE) {
s_audio_alsamm.c:    while ((err = snd_pcm_resume(handle)) == -EAGAIN)
s_audio_alsamm.c:      addr[chn] = (char *) a->addr + ((a->first + a->step * *offset) / 8);
s_audio_alsamm.c:  return -1;
s_audio_alsamm.c:    if ((err = snd_pcm_prepare (dev->a_handle)) < 0) {
s_audio_alsamm.c:    avail = snd_pcm_avail_update(dev->a_handle);
s_audio_alsamm.c:      if ((err = alsamm_get_channels(dev->a_handle, &avail, &offset,
s_audio_alsamm.c:                                     dev->a_channels,dev->a_addr)) < 0) {
s_audio_alsamm.c:      for (chn = 0; chn < dev->a_channels; chn++) 
s_audio_alsamm.c:        memset(dev->a_addr[chn],0,avail*ALSAMM_SAMPLEWIDTH_32); 
s_audio_alsamm.c:      comitted = snd_pcm_mmap_commit (dev->a_handle, offset, avail);
s_audio_alsamm.c:      avail = snd_pcm_avail_update(dev->a_handle);
s_audio_alsamm.c:    avail = snd_pcm_avail_update(dev->a_handle);
s_audio_alsamm.c:    if ((err = snd_pcm_start (dev->a_handle)) < 0) {
s_audio_alsamm.c:    if(dev->a_synced == 0){
s_audio_alsamm.c:      if ((err = snd_pcm_prepare (dev->a_handle)) < 0) {
s_audio_alsamm.c:    iavail = snd_pcm_avail_update (dev->a_handle);
s_audio_alsamm.c:      if ((err = alsamm_get_channels(dev->a_handle, &iavail, &ioffset,
s_audio_alsamm.c:                                     dev->a_channels,dev->a_addr)) < 0) {
s_audio_alsamm.c:      snd_pcm_mmap_commit (dev->a_handle, ioffset, iavail);
s_audio_alsamm.c:      iavail = snd_pcm_avail_update (dev->a_handle);
s_audio_alsamm.c:    if(dev->a_synced == 0){
s_audio_alsamm.c:      if ((err = snd_pcm_start (dev->a_handle)) < 0) {
s_audio_alsamm.c:    if ((err = snd_pcm_drop(dev->a_handle)) < 0) {
s_audio_alsamm.c:    if ((err = snd_pcm_drop(dev->a_handle)) < 0) {
s_audio_alsamm.c:/* ---------- ADC/DAC tranfer in  the main loop ------- */
s_audio_alsamm.c:   if we have more channels opened then dac-channels = sys_outchannels
s_audio_alsamm.c:   and if not it will click... users fault ;-)))
s_audio_alsamm.c:    out_cm[dac_send] = -1;
s_audio_alsamm.c:    in_avail[dac_send] = out_avail[dac_send] = -1;
s_audio_alsamm.c:    in_offset[dac_send] = out_offset[dac_send] = -1;
s_audio_alsamm.c:    snd_pcm_t *out = dev->a_handle;
s_audio_alsamm.c:    int ochannels =dev->a_channels;
s_audio_alsamm.c:      err = xrun_recovery(out, -EPIPE); 
s_audio_alsamm.c:      err = xrun_recovery(out, -EPIPE);
s_audio_alsamm.c:      err = xrun_recovery(out, -ESTRPIPE);
s_audio_alsamm.c:       this should only happen on first card otherwise we got a problem :-(()*/
s_audio_alsamm.c:        (unsigned long *)&ooffset,ochannels,dev->a_addr);
s_audio_alsamm.c:        outaddr[dac_send] = (char *) dev->a_addr[0];
s_audio_alsamm.c:        t_alsa_sample32 *buf = (t_alsa_sample32 *)dev->a_addr[chn];
s_audio_alsamm.c:        osc(buf, oframes, (dac_send%1000 < 500)?-100.0:-10.0,440,&(indexes[chn]));
s_audio_alsamm.c:            /* better but slower, better never clip ;-)
s_audio_alsamm.c:        if ((err = xrun_recovery(out, commitres >= 0 ? -EPIPE : commitres)) < 0) {
s_audio_alsamm.c:      size -= oframes;
s_audio_alsamm.c:    snd_pcm_t *in = dev->a_handle;
s_audio_alsamm.c:    int ichannels = dev->a_channels;
s_audio_alsamm.c:      err = xrun_recovery(in, -EPIPE);
s_audio_alsamm.c:      err = xrun_recovery(in, -ESTRPIPE);
s_audio_alsamm.c:        (unsigned long *)&iframes, (unsigned long *)&ioffset,ichannels,dev->a_addr);
s_audio_alsamm.c:        inaddr[dac_send] = dev->a_addr[0];
s_audio_alsamm.c:        t_alsa_sample32 *buf = (t_alsa_sample32 *) dev->a_addr[chn];
s_audio_alsamm.c:        if ((err = xrun_recovery(in, commitres >= 0 ? -EPIPE : commitres)) < 0) {
s_audio_alsamm.c:      size -= iframes;
s_audio_audiounit.c:/* ------------- routines for Apple AudioUnit in AudioToolbox -------------- */
s_audio.c:/*  machine-independent (well, mostly!) audio layer.  Stores and recalls
s_audio.c:int sys_audioapiopened = -1;    /* save last API opened for later closing */
s_audio.c:static int audio_naudioindev = -1;
s_audio.c:static int audio_naudiooutdev = -1;
s_audio.c:static int audio_advance = -1;
s_audio.c:/* ----------------------- public routines ----------------------- */
s_audio.c:    first one.)  We can later re-open audio and/or show the settings on a
s_audio.c:    if (naudioindev == -1)
s_audio.c:        if (nchindev == -1)
s_audio.c:        if (nchindev == -1)
s_audio.c:                else audioindev[i] = audioindev[i-1] + 1;
s_audio.c:                else chindev[i] = chindev[i-1];
s_audio.c:    if (naudiooutdev == -1)
s_audio.c:        if (nchoutdev == -1)
s_audio.c:        if (nchoutdev == -1)
s_audio.c:                else audiooutdev[i] = audiooutdev[i-1] + 1;
s_audio.c:                else choutdev[i] = choutdev[i-1];
s_audio.c:    sys_audioapiopened = -1;
s_audio.c:        sys_audioapiopened = -1;
s_audio.c:            else if (-f > maxsamp) maxsamp = -f;
s_audio.c:            else if (-f > maxsamp) maxsamp = -f;
s_audio.c:        rate, advance, canmulti, (cancallback ? callback : -1),
s_audio_esd.c:      esd_socket_in = esd_record_stream_fallback(format, ESD_DEFAULT_RATE, NULL, "pd-in");
s_audio_esd.c:                 sp = (short *)buf; i--; fp1++, sp += esd_channels_in) {
s_audio_esd.c:         sp = (short *)buf; i--; fp1++, sp += esd_channels_out) {
s_audio_esd.c:          else if (s < -32767) s = -32767;
s_audio_jack.c:/* ----------------------- Experimental routines for jack -------------- */
s_audio_jack.c:        jack_filled -= nframes;
s_audio_jack.c:        nframes -= (nframes % DEFDACBLKSIZE);
s_audio_jack.c:                match_info.rm_eo - match_info.rm_so );
s_audio_jack.c:        tmp_client_name[ match_info.rm_eo - match_info.rm_so ] = '\0';
s_audio_jack.c:  if (strlen(client) > 96)  return -1;
s_audio_jack.c:        error ("JACK: cannot connect input ports %s -> %s", jack_ports[i],jack_port_name (input_port[i]));
s_audio_jack.c:        error( "JACK: cannot connect output ports %s -> %s", jack_port_name (output_port[i]),jack_ports[i]);
s_audio_jack.c:    if ((timenow = sys_getrealtime()) - timeref > 0.002)
s_audio_mmio.c:/* Copyright (c) 1997-1999 Miller Puckette.
s_audio_mmio.c:/* ------------------------- audio -------------------------- */
s_audio_mmio.c:    if (!(bp->hData =
s_audio_mmio.c:    if (!(bp->lpData =
s_audio_mmio.c:        (HPSTR) GlobalLock(bp->hData)))
s_audio_mmio.c:    if (!(bp->hWaveHdr =
s_audio_mmio.c:    if (!(wh = bp->lpWaveHdr =
s_audio_mmio.c:        (WAVEHDR *) GlobalLock(bp->hWaveHdr))) 
s_audio_mmio.c:        sp = (short *)bp->lpData; i--; )
s_audio_mmio.c:    wh->lpData = bp->lpData;
s_audio_mmio.c:    wh->dwBufferLength = (CHANNELS_PER_DEVICE * SAMPSIZE * nt_realdacblksize);
s_audio_mmio.c:    wh->dwFlags = 0;
s_audio_mmio.c:    wh->dwLoops = 0L;
s_audio_mmio.c:    wh->lpNext = 0;
s_audio_mmio.c:    wh->reserved = 0;
s_audio_mmio.c:        wh->dwFlags = WHDR_DONE;
s_audio_mmio.c:    /* ------------- MIDI time stamping from audio clock ------------ */
s_audio_mmio.c:static double initsystime = -1;
s_audio_mmio.c:    if (initsystime == -1) nt_resetmidisync();
s_audio_mmio.c:    diff = sys_getrealtime() - 0.001 * clock_gettimesince(initsystime);
s_audio_mmio.c:    if (diff < nt_hibuftime - jittersec)
s_audio_mmio.c:    return (nt_tixtotime(timestamp) - nt_hibuftime);
s_audio_mmio.c:#define WRAPFWD(x) ((x) >= nt_naudiobuffer ? (x) - nt_naudiobuffer: (x))
s_audio_mmio.c:        int firstphasedone = -1, firstphasebusy = -1;
s_audio_mmio.c:                (ntsnd_invec[nad][phase2].lpWaveHdr->dwFlags & WHDR_DONE);
s_audio_mmio.c:                (ntsnd_invec[nad][phase3].lpWaveHdr->dwFlags & WHDR_DONE);
s_audio_mmio.c:                (ntsnd_invec[nad][count].lpWaveHdr->dwFlags & WHDR_DONE));
s_audio_mmio.c:        int firstphasedone = -1, firstphasebusy = -1;
s_audio_mmio.c:                (ntsnd_outvec[nda][phase2].lpWaveHdr->dwFlags & WHDR_DONE);
s_audio_mmio.c:                (ntsnd_outvec[nda][phase3].lpWaveHdr->dwFlags & WHDR_DONE);
s_audio_mmio.c:            nda, phase, (ntsnd_outvec[nad][0].lpWaveHdr->dwFlags & WHDR_DONE));
s_audio_mmio.c:                (ntsnd_outvec[nad][count].lpWaveHdr->dwFlags & WHDR_DONE));
s_audio_mmio.c:            if (!(inwavehdr->dwFlags & WHDR_DONE)) break;
s_audio_mmio.c:            if (inwavehdr->dwFlags & WHDR_PREPARED)
s_audio_mmio.c:            inwavehdr->dwFlags = 0L;
s_audio_mmio.c:            if (!(outwavehdr->dwFlags & WHDR_DONE)) break;
s_audio_mmio.c:            if (outwavehdr->dwFlags & WHDR_PREPARED)
s_audio_mmio.c:            outwavehdr->dwFlags = 0L;
s_audio_mmio.c:static double nt_nextreporttime = -1;
s_audio_mmio.c:        nt_nextreporttime = sys_getrealtime() - 5;
s_audio_mmio.c:            else if (-f > maxsamp) maxsamp = -f;
s_audio_mmio.c:            else if (-f > maxsamp) maxsamp = -f;
s_audio_mmio.c:            if (!(inwavehdr->dwFlags & WHDR_DONE)) goto idle;
s_audio_mmio.c:            if (!(outwavehdr->dwFlags & WHDR_DONE)) goto idle;
s_audio_mmio.c:            if (inwavehdr->dwFlags & WHDR_PREPARED)
s_audio_mmio.c:            if (outwavehdr->dwFlags & WHDR_PREPARED)
s_audio_mmio.c:        /* Convert audio output to fixed-point and put it in the output
s_audio_mmio.c:                else if (x1 < -32767) x1 = -32767;
s_audio_mmio.c:            int phase = WRAPBACK(ntsnd_inphase[nad] - 2);
s_audio_mmio.c:            if (inwavehdr->dwFlags & WHDR_DONE) goto late;
s_audio_mmio.c:            int phase = WRAPBACK(ntsnd_outphase[nda] - 2);
s_audio_mmio.c:            if (outwavehdr->dwFlags & WHDR_DONE) goto late;
s_audio_mmio.c:        if (inwavehdr->dwFlags & WHDR_DONE)
s_audio_mmio.c:        if (outwavehdr->dwFlags & WHDR_DONE)
s_audio_mmio.c:/* ------------------- public routines -------------------------- */
s_audio_mmio.c:    if (nt_adcjitterbufsallowed > nbuf - 2)
s_audio_mmio.c:        nt_adcjitterbufsallowed = nbuf - 2;
s_audio_mmio.c:    if (nt_dacjitterbufsallowed > nbuf - 2)
s_audio_mmio.c:        nt_dacjitterbufsallowed = nbuf - 2;
s_audio_mmio.c:        (nt_nwavein > 1 ? WAVE_MAPPER : -1) : audioindev[0]);
s_audio_mmio.c:        (nt_nwaveout > 1 ? WAVE_MAPPER : -1) : audiooutdev[0]);
s_audio_oss.c:/* Copyright (c) 1997-2003 Guenter Geiger, Miller Puckette, Larry Troxler,
s_audio_oss.c:    /* OSS-specific private variables */
s_audio_oss.c:    /* don't assume we can turn all 31 bits when doing float-to-fix; 
s_audio_oss.c:#define CLIP32(x) (((x)>FMAX)?FMAX:((x) < -FMAX)?-FMAX:(x))
s_audio_oss.c:/* ---------------- public routines ----------------------- */
s_audio_oss.c:        if ( (fd = open(devname, O_WRONLY|O_NONBLOCK)) != -1)
s_audio_oss.c:    int orig, param, nblk, fd = dev->d_fd, wantformat;
s_audio_oss.c:    int nchannels = dev->d_nchannels;
s_audio_oss.c:    dev->d_bytespersamp = 2;
s_audio_oss.c:    if (ioctl(fd, SNDCTL_DSP_SETFMT, &param) == -1)
s_audio_oss.c:    if (ioctl(fd, SNDCTL_DSP_SPEED, &param) == -1)
s_audio_oss.c:        nfragment = (sys_schedadvance * (44100. * 1.e-6)) / linux_fragsize;
s_audio_oss.c:        fragbytes = linux_fragsize * (dev->d_bytespersamp * nchannels);
s_audio_oss.c:                (1 << logfragsize)/(dev->d_bytespersamp * nchannels));
s_audio_oss.c:        if (ioctl(fd,SNDCTL_DSP_SETFRAGMENT, &param) == -1)
s_audio_oss.c:        dev->d_bufsize = ainfo.bytes;
s_audio_oss.c:        defect = sys_advance_samples * (dev->d_bytespersamp * nchannels)
s_audio_oss.c:            - dev->d_bufsize - OSS_XFERSIZE(nchannels, dev->d_bytespersamp);
s_audio_oss.c:            if (sys_verbose || defect > (dev->d_bufsize >> 2))
s_audio_oss.c:                        sys_advance_samples * (dev->d_bytespersamp * nchannels),
s_audio_oss.c:                        dev->d_bufsize);
s_audio_oss.c:                (dev->d_bufsize - OSS_XFERSAMPS(nchannels)) /
s_audio_oss.c:                    (dev->d_bytespersamp *nchannels);
s_audio_oss.c:    if (ioctl(fd, SNDCTL_DSP_CHANNELS, &param) == -1)
s_audio_oss.c:        if (ioctl(fd, SNDCTL_DSP_CHANNELS, &param) == -1)
s_audio_oss.c:        param = save - 1;
s_audio_oss.c:        linux_adcs[i].d_fd = linux_dacs[i].d_fd = -1;
s_audio_oss.c:        int gotchans, j, inindex = -1;
s_audio_oss.c:        fd = -1;
s_audio_oss.c:            if ((fd = open(devname, O_RDWR | O_AUDIOFLAG)) == -1)
s_audio_oss.c:                post("(now will try write-only...)");
s_audio_oss.c:                    post("couldn't set close-on-exec flag on audio");
s_audio_oss.c:            /* if that didn't happen or if it failed, try write-only */
s_audio_oss.c:        if (fd == -1)
s_audio_oss.c:            if ((fd = open(devname, O_WRONLY | O_AUDIOFLAG)) == -1)
s_audio_oss.c:                post("couldn't set close-on-exec flag on audio");
s_audio_oss.c:        if (ioctl(fd, SNDCTL_DSP_GETCAPS, &capabilities) == -1)
s_audio_oss.c:            various dsp's and vice-versa */
s_audio_oss.c:        wantmore = wantchannels - gotchans;
s_audio_oss.c:            if ((fd = open(devname, O_RDONLY | O_AUDIOFLAG)) == -1)
s_audio_oss.c:                post("couldn't set close-on-exec flag on audio");
s_audio_oss.c:        wantmore = wantchannels-gotchans;
s_audio_oss.c:            various dsp's and vice-versa */
s_audio_oss.c:        while (linux_dacs[dev].d_space > linux_dacs[dev].d_bufsize - 
s_audio_oss.c:        if (linux_dacs[dev].d_space > linux_dacs[dev].d_bufsize - 
s_audio_oss.c:            (sys_advance_samples - 1) * linux_dacs[dev].d_nchannels *
s_audio_oss.c:            linux_dacs[dev].d_dropcount = sys_advance_samples - 1 - 
s_audio_oss.c:                (linux_dacs[dev].d_space - linux_dacs[dev].d_bufsize) /
s_audio_oss.c:                (linux_dacs[dev].d_bufsize - linux_dacs[dev].d_space >
s_audio_oss.c:            /* sometimes---rarely---when the ADC available-byte-count is
s_audio_oss.c:            no output device should have less than sys_advance_samples-1
s_audio_oss.c:                (linux_dacs[dev].d_bufsize - linux_dacs[dev].d_space <
s_audio_oss.c:                    (sys_advance_samples - 2) *
s_audio_oss.c:            linux_dacs[dev].d_dropcount--;
s_audio_oss.c:                    sp = (t_oss_int16 *)buf; i--; fp1++, sp += nchannels)
s_audio_oss.c:                        else if (s < -32767) s = -32767;
s_audio_oss.c:            if ((timenow = sys_getrealtime()) - timeref > 0.002)
s_audio_oss.c:        if ((timenow = sys_getrealtime()) - timeref > 0.002)
s_audio_oss.c:                sp = (t_oss_int16 *)buf; i--; fp1++, sp += nchannels)
s_audio_oss.c:                    fp1[j*DEFDACBLKSIZE] = (float)sp[j]*(float)3.051850e-05;
s_audio_pa.c:    Both blocking and non-blocking call styles are supported.  If non-blocking
s_audio_pa.c:    is requested, either we call portaudio in non-blocking mode, or else we
s_audio_pa.c:    for waiting on the (presumebly other-thread) I/O to complete, either
s_audio_pa.c:#ifndef _WIN32          /* for the "dup2" workaround -- do we still need it? */
s_audio_pa.c:        nframes -= (nframes % DEFDACBLKSIZE);
s_audio_pa.c:    /* callback for "non-callback" case in which we actualy open portaudio
s_audio_pa.c:    /* callback routine for non-callback client... throw samples into
s_audio_pa.c:              inRate=info->defaultSampleRate;
s_audio_pa.c:              if(info->maxInputChannels<inchannels)
s_audio_pa.c:                instreamparams.channelCount=info->maxInputChannels;
s_audio_pa.c:              outRate=info->defaultSampleRate;
s_audio_pa.c:              if(info->maxOutputChannels<outchannels)
s_audio_pa.c:                outstreamparams.channelCount=info->maxOutputChannels;
s_audio_pa.c:    int j, devno, pa_indev = -1, pa_outdev = -1;
s_audio_pa.c:            if (info->maxInputChannels > 0)
s_audio_pa.c:                    if (inchans > info->maxInputChannels)
s_audio_pa.c:                      inchans = info->maxInputChannels;
s_audio_pa.c:            if (info->maxOutputChannels > 0)
s_audio_pa.c:                    if (outchans > info->maxOutputChannels)
s_audio_pa.c:                      outchans = info->maxOutputChannels;
s_audio_pa.c:    if (inchans > 0 && pa_indev == -1)
s_audio_pa.c:    if (outchans > 0 && pa_outdev == -1)
s_audio_pa.c:            for (j = 0; j < pa_nbuffers-1; j++)
s_audio_pa.c:    if (sys_getrealtime() - timebefore > 0.002)
s_audio_pa.c:        fprintf(stderr, " %s;", pdi->name );
s_audio_pa.c:        fprintf(stderr, "%d inputs, ", pdi->maxInputChannels  );
s_audio_pa.c:        fprintf(stderr, "%d outputs", pdi->maxOutputChannels  );
s_audio_pa.c:        if (pdi->maxInputChannels > 0 && nin < maxndev)
s_audio_pa.c:                pdi->hostApi,pdi->name);
s_audio_pa.c:            /* strcpy(indevlist + nin * devdescsize, pdi->name); */
s_audio_pa.c:        if (pdi->maxOutputChannels > 0 && nout < maxndev)
s_audio_pa.c:                pdi->hostApi,pdi->name);
s_audio_pa.c:            /* strcpy(outdevlist + nout * devdescsize, pdi->name); */
s_audio_paring.c: * Copyright (c) 1999-2000 Ross Bencina and Phil Burk
s_audio_paring.c:    rbuf->bufferSize = numBytes;
s_audio_paring.c:    rbuf->buffer = (char *)dataPtr;
s_audio_paring.c:    long ret = rbuf->writeIndex - rbuf->readIndex;
s_audio_paring.c:        ret += 2 * rbuf->bufferSize;
s_audio_paring.c:    if (ret < 0 || ret > rbuf->bufferSize)
s_audio_paring.c:    return ( rbuf->bufferSize - sys_ringbuf_GetReadAvailable(rbuf));
s_audio_paring.c:    rbuf->readIndex = 0;
s_audio_paring.c:    rbuf->writeIndex = nfill;
s_audio_paring.c:    for (n = nfill, s = dataPtr; n--; s++)
s_audio_paring.c:** If non-contiguous, size2 will be the size of second region.
s_audio_paring.c:    index = rbuf->writeIndex;
s_audio_paring.c:    while (index >= rbuf->bufferSize)
s_audio_paring.c:        index -= rbuf->bufferSize;
s_audio_paring.c:    if( (index + numBytes) > rbuf->bufferSize )
s_audio_paring.c:        long   firstHalf = rbuf->bufferSize - index;
s_audio_paring.c:        *dataPtr1 = &rbuf->buffer[index];
s_audio_paring.c:        *dataPtr2 = &rbuf->buffer[0];
s_audio_paring.c:        *sizePtr2 = numBytes - firstHalf;
s_audio_paring.c:        *dataPtr1 = &rbuf->buffer[index];
s_audio_paring.c:    long ret = (rbuf->writeIndex + numBytes);
s_audio_paring.c:    if ( ret >= 2 * rbuf->bufferSize)
s_audio_paring.c:        ret -= 2 * rbuf->bufferSize;    /* check for end of buffer */
s_audio_paring.c:    return rbuf->writeIndex = ret;
s_audio_paring.c:** If non-contiguous, size2 will be the size of second region.
s_audio_paring.c:    index = rbuf->readIndex;
s_audio_paring.c:    while (index >= rbuf->bufferSize)
s_audio_paring.c:        index -= rbuf->bufferSize;
s_audio_paring.c:    if( (index + numBytes) > rbuf->bufferSize )
s_audio_paring.c:        long firstHalf = rbuf->bufferSize - index;
s_audio_paring.c:        *dataPtr1 = &rbuf->buffer[index];
s_audio_paring.c:        *dataPtr2 = &rbuf->buffer[0];
s_audio_paring.c:        *sizePtr2 = numBytes - firstHalf;
s_audio_paring.c:        *dataPtr1 = &rbuf->buffer[index];
s_audio_paring.c:    long ret = (rbuf->readIndex + numBytes);
s_audio_paring.c:    if( ret >= 2 * rbuf->bufferSize)
s_audio_paring.c:        ret -= 2 * rbuf->bufferSize;
s_audio_paring.c:    return rbuf->readIndex = ret;
s_audio_paring.h: * Copyright (c) 1999-2000 Ross Bencina and Phil Burk
s_audio_paring.h:** If non-contiguous, size2 will be the size of second region.
s_audio_paring.h:** If non-contiguous, size2 will be the size of second region.
s_file.c:/* Copyright (c) 1997-2004 Miller Puckette.
s_file.c:        sys_libdir->s_name);
s_file.c:    filenamebuf[MAXPDSTRING-1] = 0;
s_file.c:        whereend--;
s_file.c:    if (whereend > where + size - 1)
s_file.c:        whereend = where + size - 1;
s_file.c:    strncpy(value, where, whereend+1-where);
s_file.c:    value[whereend+1-where] = 0;
s_file.c:    filenamebuf[MAXPDSTRING-1] = 0;
s_file.c:        sys_libdir->s_name);
s_file.c:        int newread = fread(value+nread, 1, size-nread, fp);
s_file.c:        nread = size-1;
s_file.c:    if (value[nread-1] == '\n')     /* remove newline character at end */
s_file.c:        value[nread-1] = 0;
s_file.c:    int i, rate = 0, advance = -1, callback = 0, blocksize = 0,
s_file.c:            /* if no preferences at all, set -1 for default behavior */
s_file.c:            naudioindev = -1;
s_file.c:            naudiooutdev = -1;
s_file.c:        (sys_flags ? sys_flags->s_name : ""));
s_inter.c:/* Copyright (c) 1997-1999 Miller Puckette.
s_inter.c:/* Pd side of the Pd/Pd-gui interface.  Also, some system interface routines
s_inter.c:#define DEBUG_MESSUP 1      /* messages up from pd to pd-gui */
s_inter.c:#define DEBUG_MESSDOWN 2    /* messages down from pd-gui to pd */
s_inter.c:/* ----------- functions for timing, signals, priorities, etc  --------- */
s_inter.c:    return (((double)(dumbass->QuadPart - nt_inittime.QuadPart)) / nt_freq);
s_inter.c:    return ((now.tv_sec - then.tv_sec) +
s_inter.c:        (1./1000000.) * (now.tv_usec - then.tv_usec));
s_inter.c:    return (((double)(now.QuadPart - nt_inittime.QuadPart)) / nt_freq);
s_inter.c:        for (fp = sys_fdpoll, i = sys_nfdpoll; i--; fp++)
s_inter.c:            FD_SET(fp->fdp_fd, &readset);
s_inter.c:    p3 = (higher ? p2 - 1 : p2 - 3);
s_inter.c:    if (sched_setscheduler(0,SCHED_FIFO,&par) != -1)
s_inter.c:    if (mlockall(MCL_FUTURE) != -1) 
s_inter.c:/* ------------------ receiving incoming messages over sockets ------------- */
s_inter.c:    fp->fdp_fd = fd;
s_inter.c:    fp->fdp_fn = fn;
s_inter.c:    fp->fdp_ptr = ptr;
s_inter.c:    for (i = nfd, fp = sys_fdpoll; i--; fp++)
s_inter.c:        if (fp->fdp_fd == fd)
s_inter.c:            while (i--)
s_inter.c:                size - sizeof(t_fdpoll));
s_inter.c:            sys_nfdpoll = nfd - 1;
s_inter.c:    x->sr_inhead = x->sr_intail = 0;
s_inter.c:    x->sr_owner = owner;
s_inter.c:    x->sr_notifier = notifier;
s_inter.c:    x->sr_socketreceivefn = socketreceivefn;
s_inter.c:    x->sr_udp = udp;
s_inter.c:    if (!(x->sr_inbuf = malloc(INBUFSIZE))) bug("t_socketreceiver");;
s_inter.c:    free(x->sr_inbuf);
s_inter.c:    int inhead = x->sr_inhead;
s_inter.c:    int intail = x->sr_intail;
s_inter.c:    char *inbuf = x->sr_inbuf;
s_inter.c:        first = 0, (indx = (indx+1)&(INBUFSIZE-1)))
s_inter.c:        if (c == ';' && (!indx || inbuf[indx-1] != '\\'))
s_inter.c:            intail = (indx+1)&(INBUFSIZE-1);
s_inter.c:            binbuf_text(inbinbuf, messbuf, bp - messbuf);
s_inter.c:                write(2,  messbuf, bp - messbuf);
s_inter.c:            x->sr_inhead = inhead;
s_inter.c:            x->sr_intail = intail;
s_inter.c:        if (buf[ret-1] != '\n')
s_inter.c:            if (x->sr_socketreceivefn)
s_inter.c:                (*x->sr_socketreceivefn)(x->sr_owner, inbinbuf);
s_inter.c:    if (x->sr_udp)   /* UDP ("datagram") socket protocol */
s_inter.c:            (x->sr_inhead >= x->sr_intail ? INBUFSIZE : x->sr_intail-1);
s_inter.c:        if (readto == x->sr_inhead)
s_inter.c:            x->sr_inhead = x->sr_intail = 0;
s_inter.c:            ret = recv(fd, x->sr_inbuf + x->sr_inhead,
s_inter.c:                readto - x->sr_inhead, 0);
s_inter.c:                    if (x->sr_notifier) (*x->sr_notifier)(x->sr_owner);
s_inter.c:                    if (x->sr_notifier) (*x->sr_notifier)(x->sr_owner);
s_inter.c:                x->sr_inhead += ret;
s_inter.c:                if (x->sr_inhead >= INBUFSIZE) x->sr_inhead = 0;
s_inter.c:                    if (x->sr_socketreceivefn)
s_inter.c:                        (*x->sr_socketreceivefn)(x->sr_owner, inbinbuf);
s_inter.c:                    if (x->sr_inhead == x->sr_intail)
s_inter.c:/* ---------------------- sending messages to the GUI ------------------ */
s_inter.c:        /* if realloc fails, make a last-ditch attempt to stay alive by
s_inter.c:        int bytestowrite = sys_guibuftail - sys_guibufhead;
s_inter.c:    if (sys_guibufhead > sys_guibufsize - (GUI_ALLOCCHUNK/2))
s_inter.c:        sys_guibufsize - sys_guibufhead, fmt, ap);
s_inter.c:    if (msglen >= sys_guibufsize - sys_guibufhead)
s_inter.c:            sys_guibufsize - sys_guibufhead, fmt, ap);
s_inter.c:        if (msglen >= sys_guibufsize - sys_guibufhead)
s_inter.c:            msglen = sys_guibufsize - sys_guibufhead;
s_inter.c:    int writesize = sys_guibufhead - sys_guibuftail, nwrote = 0;
s_inter.c:        perror("pd-to-gui socket");
s_inter.c:    else if (nwrote >= sys_guibufhead - sys_guibuftail)
s_inter.c:                sys_guibufhead - sys_guibuftail);
s_inter.c:            sys_guibufhead = sys_guibufhead - sys_guibuftail;
s_inter.c:            sys_guiqueuehead = headwas->gq_next;
s_inter.c:            (*headwas->gq_fn)(headwas->gq_client, headwas->gq_glist);
s_inter.c:        for (gq = sys_guiqueuehead; gq->gq_next; gq = gq->gq_next)
s_inter.c:            if (gq->gq_client == client)
s_inter.c:        if (gq->gq_client == client)
s_inter.c:        gqnextptr = &gq->gq_next;
s_inter.c:    gq->gq_next = 0;
s_inter.c:    gq->gq_client = client;
s_inter.c:    gq->gq_glist = glist;
s_inter.c:    gq->gq_fn = f;
s_inter.c:    gq->gq_next = 0;
s_inter.c:    if (sys_guiqueuehead->gq_client == client)
s_inter.c:    else for (gq = sys_guiqueuehead; gq2 = gq->gq_next; gq = gq2)
s_inter.c:        if (gq2->gq_client == client)
s_inter.c:        gq->gq_next = gq2->gq_next;
s_inter.c:/* --------------------- starting up the GUI connection ------------- */
s_inter.c:    int xsock = -1;
s_inter.c:        memcpy((char *)&server.sin_addr, (char *)hp->h_addr, hp->h_length);
s_inter.c:             * filename as the Pd.app, i.e. 'Pd-0.42-3.app' should have a Wish
s_inter.c:             * executable called 'Pd-0.42-3.app/Contents/MacOS/Pd-0.42-3' */
s_inter.c:             * will automatically load pd-gui.tcl if that embedded Wish can
s_inter.c:             * to receive the pd-gui.tcl as an argument.  Otherwise it needs
s_inter.c:             * to know how to find pd-gui.tcl */
s_inter.c:                sprintf(cmdbuf, "\"%s\" \"%s/%spd-gui.tcl\" %d\n", 
s_inter.c:  wish \"%s/" PDGUIDIR "/pd-gui.tcl\" %d\n",
s_inter.c:            execl("/bin/sh", "sh", "-c", sys_guicmd, (char*)0);
s_inter.c:        strcat(scriptbuf, "/" PDGUIDIR "pd-gui.tcl\"");
s_inter.c:        (-1), we assume real-time was wanted.  Afterward, just in case
s_inter.c:                @audio - rtprio 99
s_inter.c:                @audio - memlock unlimited
s_inter.c:    if (sys_hipriority == -1)
s_inter.c:    sprintf(cmdbuf, "%s/bin/pd-watchdog", libdir);
s_inter.c:              "disabling real-time priority due to missing pd-watchdog (%s)\n",
s_inter.c:            higher real-time priority than ours.  The GUI has to send
s_inter.c:            execl("/bin/sh", "sh", "-c", cmdbuf, (char*)0);
s_loader.c:/* Copyright (c) 1997-1999 Miller Puckette.
s_loader.c:#include <mach-o/dyld.h> 
s_loader.c:fallbacks are provided, primarily for back-compatibility; these suffice if
s_loader.c:    for (ll = sys_loaded; ll; ll = ll->ll_next)
s_loader.c:        if (ll->ll_name == s)
s_loader.c:    ll->ll_name = gensym(classname);
s_loader.c:    ll->ll_next = sys_loaded;
s_loader.c:    for (i = 0, nameptr = classname; i < MAXPDSTRING-7 && *nameptr; nameptr++)
s_loader.c:    filename[MAXPDSTRING-2] = 0;
s_loader.c:    strncat(filename, classname, MAXPDSTRING-strlen(filename));
s_loader.c:    filename[MAXPDSTRING-1] = 0;
s_loader.c:    strncat(libname, objectname, MAXPDSTRING - 4);
s_loader.c:    if (libname[len-1] == '~' && len < MAXPDSTRING - 6) {
s_loader.c:        strcpy(libname+len-1, "_tilde");
s_loader.c:    filename[MAXPDSTRING-2] = 0;
s_loader.c:    strncat(filename, nameptr, MAXPDSTRING-strlen(filename));
s_loader.c:    filename[MAXPDSTRING-1] = 0;
s_loader.c:        if (q->loader == loader)    /* already loaded - nothing to do */
s_loader.c:        else if (q->next) 
s_loader.c:            q = q->next;
s_loader.c:            q->next = (loader_queue_t *)getbytes(sizeof(loader_queue_t));
s_loader.c:            q->next->loader = loader;
s_loader.c:            q->next->next = NULL;
s_loader.c:    for(q = &loaders; q; q = q->next)
s_loader.c:        if (ok = q->loader(canvas, classname)) break;
s_loader.c:            /* if first-choice file extent can't 'stat', go for second */
s_main.c:/* Copyright (c) 1997-1999 Miller Puckette and others.
s_main.c:char *pd_version = "Pd-" stringify(PD_MAJOR_VERSION) "." stringify(PD_MINOR_VERSION) "." stringify(PD_BUGFIX_VERSION) " (" stringify(PD_TEST_VERSION) ")";
s_main.c:int sys_hipriority = -1;    /* -1 = don't care; 0 = no; 1 = yes */
s_main.c:int sys_nmidiout = -1;
s_main.c:int sys_nmidiin = -1;
s_main.c:    /* here the "-1" counts signify that the corresponding vector hasn't been
s_main.c:static int sys_nsoundin = -1;
s_main.c:static int sys_nsoundout = -1;
s_main.c:static int sys_nchin = -1;
s_main.c:static int sys_nchout = -1;
s_main.c:    for (i = 0, fi = sys_fontlist; i < (NFONT-1); i++, fi++)
s_main.c:    return (sys_fontlist + (NFONT-1));
s_main.c:    return (sys_findfont(fontsize)->fi_fontsize);
s_main.c:    return (sys_findfont(fontsize)->fi_hostfontsize);
s_main.c:    return (sys_findfont(fontsize)->fi_width);
s_main.c:    return (sys_findfont(fontsize)->fi_height);
s_main.c:    char *cwd = atom_getsymbolarg(0, argc, argv)->s_name;
s_main.c:    int nhostfont = (argc-2)/3;
s_main.c:        fprintf(stderr, "font (%d %d %d) -> (%d %d %d)\n",
s_main.c:        /* load dynamic libraries specified with "-lib" args */
s_main.c:    for  (nl = sys_externlist; nl; nl = nl->nl_next)
s_main.c:        if (!sys_load_lib(0, nl->nl_string))
s_main.c:            post("%s: can't load library", nl->nl_string);
s_main.c:        /* open patches specifies with "-open" args */
s_main.c:    for  (nl = sys_openlist; nl; nl = nl->nl_next)
s_main.c:        openit(cwd, nl->nl_string);
s_main.c:        /* send messages specified with "-send" args */
s_main.c:    for  (nl = sys_messagelist; nl; nl = nl->nl_next)
s_main.c:        binbuf_text(b, nl->nl_string, strlen(nl->nl_string));
s_main.c:        if (!strcmp(argv[i], "-noprefs"))
s_main.c:    if (sys_argparse(argc-1, argv+1))           /* parse cmd line */
s_main.c:    sys_afterargparse();                    /* post-argparse settings */
s_main.c:    if (sys_startgui(sys_libdir->s_name))       /* start the gui */
s_main.c:"usage: pd [-flags] [file]...\n",
s_main.c:"-r <n>           -- specify sample rate\n",
s_main.c:"-audioindev ...  -- audio in devices; e.g., \"1,3\" for first and third\n",
s_main.c:"-audiooutdev ... -- audio out devices (same)\n",
s_main.c:"-audiodev ...    -- specify input and output together\n",
s_main.c:"-inchannels ...  -- audio input channels (by device, like \"2\" or \"16,8\")\n",
s_main.c:"-outchannels ... -- number of audio out channels (same)\n",
s_main.c:"-channels ...    -- specify both input and output channels\n",
s_main.c:"-audiobuf <n>    -- specify size of audio buffer in msec\n",
s_main.c:"-blocksize <n>   -- specify audio I/O block size in sample frames\n",
s_main.c:"-sleepgrain <n>  -- specify number of milliseconds to sleep when idle\n",
s_main.c:"-nodac           -- suppress audio output\n",
s_main.c:"-noadc           -- suppress audio input\n",
s_main.c:"-noaudio         -- suppress audio input and output (-nosound is synonym) \n",
s_main.c:"-listdev         -- list audio and MIDI devices\n",
s_main.c:"-oss             -- use OSS audio API\n",
s_main.c:"-alsa            -- use ALSA audio API\n",
s_main.c:"-alsaadd <name>  -- add an ALSA device name to list\n",
s_main.c:"-jack            -- use JACK audio API\n",
s_main.c:"-asio            -- use ASIO audio driver (via Portaudio)\n",
s_main.c:"-pa              -- synonym for -asio\n",
s_main.c:"-pa              -- use Portaudio API\n",
s_main.c:"-mmio            -- use MMIO audio API (default for Windows)\n",
s_main.c:"-audiounit       -- use Apple AudioUnit API\n",
s_main.c:"-esd             -- use Enlightenment Sound Daemon (ESD) API\n",
s_main.c:"-midiindev ...   -- midi in device list; e.g., \"1,3\" for first and third\n",
s_main.c:"-midioutdev ...  -- midi out device list, same format\n",
s_main.c:"-mididev ...     -- specify -midioutdev and -midiindev together\n",
s_main.c:"-nomidiin        -- suppress MIDI input\n",
s_main.c:"-nomidiout       -- suppress MIDI output\n",
s_main.c:"-nomidi          -- suppress MIDI input and output\n",
s_main.c:"-alsamidi        -- use ALSA midi API\n",
s_main.c:"-path <path>     -- add to file search path\n",
s_main.c:"-nostdpath       -- don't search standard (\"extra\") directory\n",
s_main.c:"-stdpath         -- search standard directory (true by default)\n",
s_main.c:"-helppath <path> -- add to help file search path\n",
s_main.c:"-open <file>     -- open file(s) on startup\n",
s_main.c:"-lib <file>      -- load object library(s)\n",
s_main.c:"-font-size <n>     -- specify default font size in points\n",
s_main.c:"-font-face <name>  -- specify default font\n",
s_main.c:"-font-weight <name>-- specify default font weight (normal or bold)\n",
s_main.c:"-verbose         -- extra printout on startup and when searching for files\n",
s_main.c:"-version         -- don't run Pd; just print out which version it is \n",
s_main.c:"-d <n>           -- specify debug level\n",
s_main.c:"-noloadbang      -- suppress all loadbangs\n",
s_main.c:"-stderr          -- send printout to standard error instead of GUI\n",
s_main.c:"-nogui           -- suppress starting the GUI\n",
s_main.c:"-guiport <n>     -- connect to pre-existing GUI over port <n>\n",
s_main.c:"-guicmd \"cmd...\" -- start alternatve GUI program (e.g., remote via ssh)\n",
s_main.c:"-send \"msg...\"   -- send a message at startup, after patches are loaded\n",
s_main.c:"-noprefs         -- suppress loading preferences on startup\n",
s_main.c:"-rt or -realtime -- use real-time priority\n",
s_main.c:"-nrt             -- don't use real-time priority\n",
s_main.c:"-nosleep         -- spin, don't sleep (may lower latency on multi-CPUs)\n",
s_main.c:"-schedlib <file> -- plug in external scheduler\n",
s_main.c:"-extraflags <s>  -- string argument to send schedlib\n",
s_main.c:"-batch           -- run off-line as a batch process\n",
s_main.c:"-noautopatch     -- defeat auto-patching new from selected objects\n",
s_main.c:"-compatibility <f> -- set back-compatibility to version <f>\n",
s_main.c:    if (n<0)return(-1);
s_main.c:    while(n--)sum+=*devlist++;
s_main.c:    sbuf2[MAXPDSTRING-1] = 0;
s_main.c:    sbuf[MAXPDSTRING-1] = 0;
s_main.c:            strncpy(sbuf2, sbuf, lastslash-sbuf);
s_main.c:            sbuf2[lastslash-sbuf] = 0;
s_main.c:            .../bin/pd-watchdog (etc)
s_main.c:            .../bin/pd-gui.tcl
s_main.c:            .../lib/pd/bin/pd-watchdog
s_main.c:            .../lib/pd/bin/pd-gui.tcl
s_main.c:    strncpy(sbuf, sbuf2, MAXPDSTRING-30);
s_main.c:    sbuf[MAXPDSTRING-30] = 0;
s_main.c:            /* complicated layout: lib dir is the one we just stat-ed above */
s_main.c:    while ((argc > 0) && **argv == '-')
s_main.c:        if (!strcmp(*argv, "-r") && argc > 1 &&
s_main.c:            argc -= 2;
s_main.c:        else if (!strcmp(*argv, "-inchannels") && (argc > 1))
s_main.c:          argc -= 2; argv += 2;
s_main.c:        else if (!strcmp(*argv, "-outchannels") && (argc > 1))
s_main.c:          argc -= 2; argv += 2;
s_main.c:        else if (!strcmp(*argv, "-channels") && (argc > 1))
s_main.c:            argc -= 2; argv += 2;
s_main.c:        else if (!strcmp(*argv, "-soundbuf") || !strcmp(*argv, "-audiobuf") && (argc > 1))
s_main.c:            argc -= 2; argv += 2;
s_main.c:        else if (!strcmp(*argv, "-callback"))
s_main.c:            argc--; argv++;
s_main.c:        else if (!strcmp(*argv, "-blocksize"))
s_main.c:            argc -= 2; argv += 2;
s_main.c:        else if (!strcmp(*argv, "-sleepgrain") && (argc > 1))
s_main.c:            argc -= 2; argv += 2;
s_main.c:        else if (!strcmp(*argv, "-nodac"))
s_main.c:            argc--; argv++;
s_main.c:        else if (!strcmp(*argv, "-noadc"))
s_main.c:            argc--; argv++;
s_main.c:        else if (!strcmp(*argv, "-nosound") || !strcmp(*argv, "-noaudio"))
s_main.c:            argc--; argv++;
s_main.c:        else if (!strcmp(*argv, "-oss"))
s_main.c:            argc--; argv++;
s_main.c:        else if (!strcmp(*argv, "-alsa"))
s_main.c:            argc--; argv++;
s_main.c:        else if (!strcmp(*argv, "-alsaadd") && (argc > 1))
s_main.c:            argc -= 2; argv +=2;
s_main.c:        else if (!strcmp(*argv, "-alsamidi"))
s_main.c:            argc--; argv++;
s_main.c:        else if (!strcmp(*argv, "-jack"))
s_main.c:            argc--; argv++;
s_main.c:        else if (!strcmp(*argv, "-pa") || !strcmp(*argv, "-portaudio")
s_main.c:            || !strcmp(*argv, "-asio")
s_main.c:            argc--; argv++;
s_main.c:        else if (!strcmp(*argv, "-mmio"))
s_main.c:            argc--; argv++;
s_main.c:        else if (!strcmp(*argv, "-audiounit"))
s_main.c:            argc--; argv++;
s_main.c:        else if (!strcmp(*argv, "-esd"))
s_main.c:            argc--; argv++;
s_main.c:        else if (!strcmp(*argv, "-nomidiin"))
s_main.c:            argc--; argv++;
s_main.c:        else if (!strcmp(*argv, "-nomidiout"))
s_main.c:            argc--; argv++;
s_main.c:        else if (!strcmp(*argv, "-nomidi"))
s_main.c:            argc--; argv++;
s_main.c:        else if (!strcmp(*argv, "-midiindev"))
s_main.c:            argc -= 2; argv += 2;
s_main.c:        else if (!strcmp(*argv, "-midioutdev") && (argc > 1))
s_main.c:            argc -= 2; argv += 2;
s_main.c:        else if (!strcmp(*argv, "-mididev") && (argc > 1))
s_main.c:            argc -= 2; argv += 2;
s_main.c:        else if (!strcmp(*argv, "-path") && (argc > 1))
s_main.c:            argc -= 2; argv += 2;
s_main.c:        else if (!strcmp(*argv, "-nostdpath"))
s_main.c:            argc--; argv++;
s_main.c:        else if (!strcmp(*argv, "-stdpath"))
s_main.c:            argc--; argv++;
s_main.c:        else if (!strcmp(*argv, "-helppath"))
s_main.c:            argc -= 2; argv += 2;
s_main.c:        else if (!strcmp(*argv, "-open") && argc > 1)
s_main.c:            argc -= 2; argv += 2;
s_main.c:        else if (!strcmp(*argv, "-lib") && argc > 1)
s_main.c:            argc -= 2; argv += 2;
s_main.c:        else if ((!strcmp(*argv, "-font-size") || !strcmp(*argv, "-font"))
s_main.c:            argc -= 2;
s_main.c:        else if ((!strcmp(*argv, "-font-face") || !strcmp(*argv, "-typeface"))
s_main.c:            strncpy(sys_font,*(argv+1),sizeof(sys_font)-1);
s_main.c:            sys_font[sizeof(sys_font)-1] = 0;
s_main.c:            argc -= 2;
s_main.c:        else if (!strcmp(*argv, "-font-weight") && argc > 1)
s_main.c:            strncpy(sys_fontweight,*(argv+1),sizeof(sys_fontweight)-1);
s_main.c:            sys_fontweight[sizeof(sys_fontweight)-1] = 0;
s_main.c:            argc -= 2;
s_main.c:        else if (!strcmp(*argv, "-verbose"))
s_main.c:            argc--; argv++;
s_main.c:        else if (!strcmp(*argv, "-version"))
s_main.c:            argc--; argv++;
s_main.c:        else if (!strcmp(*argv, "-d") && argc > 1 &&
s_main.c:            argc -= 2;
s_main.c:        else if (!strcmp(*argv, "-noloadbang"))
s_main.c:            argc--; argv++;
s_main.c:        else if (!strcmp(*argv, "-nogui"))
s_main.c:            argc--; argv++;
s_main.c:        else if (!strcmp(*argv, "-guiport") && argc > 1 &&
s_main.c:            argc -= 2;
s_main.c:        else if (!strcmp(*argv, "-stderr"))
s_main.c:            argc--; argv++;
s_main.c:            /* we need to tell Windows to output UTF-8 */
s_main.c:        else if (!strcmp(*argv, "-guicmd") && argc > 1)
s_main.c:            argc -= 2; argv += 2;
s_main.c:        else if (!strcmp(*argv, "-send") && argc > 1)
s_main.c:            argc -= 2; argv += 2;
s_main.c:        else if (!strcmp(*argv, "-listdev"))
s_main.c:            argc--; argv++;
s_main.c:        else if (!strcmp(*argv, "-schedlib") && argc > 1)
s_main.c:                sizeof(sys_externalschedlibname) - 1);
s_main.c:            argc -= 2;
s_main.c:        else if (!strcmp(*argv, "-extraflags") && argc > 1)
s_main.c:                sizeof(sys_extraflagsstring) - 1);
s_main.c:            argc -= 2;
s_main.c:        else if (!strcmp(*argv, "-batch"))
s_main.c:            argc--; argv++;
s_main.c:        else if (!strcmp(*argv, "-noautopatch"))
s_main.c:            argc--; argv++;
s_main.c:        else if (!strcmp(*argv, "-compatibility") && argc > 1)
s_main.c:            pd_compatibilitylevel = 0.5 + 100. * f; /* e.g., 2.44 --> 244 */
s_main.c:            argc -= 2;
s_main.c:        else if (!strcmp(*argv, "-rt") || !strcmp(*argv, "-realtime"))
s_main.c:            argc--; argv++;
s_main.c:        else if (!strcmp(*argv, "-nrt"))
s_main.c:            argc--; argv++;
s_main.c:        else if (!strcmp(*argv, "-nosleep"))
s_main.c:            argc--; argv++;
s_main.c:        else if (!strcmp(*argv, "-soundindev") ||
s_main.c:            !strcmp(*argv, "-audioindev"))
s_main.c:            argc -= 2; argv += 2;
s_main.c:        else if (!strcmp(*argv, "-soundoutdev") ||
s_main.c:            !strcmp(*argv, "-audiooutdev"))
s_main.c:            argc -= 2; argv += 2;
s_main.c:        else if ((!strcmp(*argv, "-sounddev") || !strcmp(*argv, "-audiodev"))
s_main.c:            argc -= 2; argv += 2;
s_main.c:        else if (!strcmp(*argv, "-noprefs")) /* did this earlier */
s_main.c:            argc--, argv++;
s_main.c:    for (; argc > 0; argc--, argv++) 
s_main.c:    /* stuff to do, once, after calling sys_argparse() -- which may itself
s_main.c:    from command-line arguments */
s_main.c:    strncpy(sbuf, sys_libdir->s_name, MAXPDSTRING-30);
s_main.c:    sbuf[MAXPDSTRING-30] = 0;
s_main.c:    strncpy(sbuf, sys_libdir->s_name, MAXPDSTRING-30);
s_main.c:    sbuf[MAXPDSTRING-30] = 0;
s_main.c:            sys_soundindevlist[i]--;
s_main.c:            sys_soundoutdevlist[i]--;
s_main.c:        sys_midiindevlist[i]--;
s_main.c:        sys_midioutdevlist[i]--;
s_midi_alsa.c:/* Copyright (c) 1997-1999 Guenter Geiger, Miller Puckette, Larry Troxler,
s_midi_alsa.c:        sprintf(portname,"Pure Data Midi-In %d",i+1);
s_midi_alsa.c:        sprintf(portname,"Pure Data Midi-Out %d",i+1);
s_midi_alsa.c:            channel = a-224;
s_midi_alsa.c:            snd_seq_ev_set_pitchbend(&ev, channel, (((c<<7)|b)-8192)); /* b and c are already correct but alsa needs to recalculate them */
s_midi_alsa.c:            channel = a-208;
s_midi_alsa.c:            channel = a-192;
s_midi_alsa.c:            channel = a-176;
s_midi_alsa.c:            channel = a-160;
s_midi_alsa.c:            channel = a-144;
s_midi_alsa.c:       alsa_source = midievent->dest.port;
s_midi.c:/* Copyright (c) 1997-1999 Miller Puckette and others.
s_midi.c:static double sys_newdactimeminusrealtime = -1e20;
s_midi.c:static double sys_newadctimeminusrealtime = -1e20;
s_midi.c:    think we know the delay (outbuftime) in seconds, at which the last-output
s_midi.c:            - outbuftime - sys_getrealtime();
s_midi.c:            + inbuftime - sys_getrealtime();
s_midi.c:        sys_newdactimeminusrealtime = -1e20;
s_midi.c:        sys_newadctimeminusrealtime = -1e20;
s_midi.c:                (midi_outqueue[midi_outtail].q_time - midirealtime),
s_midi.c:/* ------------------------- MIDI input queue handling ------------------ */
s_midi.c:                    parserp->mp_status = 0;
s_midi.c:                parserp->mp_status = byte;
s_midi.c:                parserp->mp_status = 0;
s_midi.c:                parserp->mp_status = byte;
s_midi.c:            parserp->mp_gotbyte1 = 0;
s_midi.c:            int cmd = (parserp->mp_status >= 0xf0 ? parserp->mp_status :
s_midi.c:                (parserp->mp_status & 0xf0));
s_midi.c:            int chan = (parserp->mp_status & 0xf);
s_midi.c:            int byte1 = parserp->mp_byte1, gotbyte1 = parserp->mp_gotbyte1;
s_midi.c:                        parserp->mp_gotbyte1 = 0;
s_midi.c:                else parserp->mp_byte1 = byte, parserp->mp_gotbyte1 = 1;
s_midi.c:                        parserp->mp_gotbyte1 = 0;
s_midi.c:                else parserp->mp_byte1 = byte, parserp->mp_gotbyte1 = 1;
s_midi.c:                        parserp->mp_gotbyte1 = 0;
s_midi.c:                else parserp->mp_byte1 = byte, parserp->mp_gotbyte1 = 1;
s_midi.c:                        parserp->mp_gotbyte1 = 0;
s_midi.c:                else parserp->mp_byte1 = byte, parserp->mp_gotbyte1 = 1;
s_midi.c:                        parserp->mp_gotbyte1 = 0;
s_midi.c:                else parserp->mp_byte1 = byte, parserp->mp_gotbyte1 = 1;
s_midi.c:                (midi_inqueue[midi_intail].q_time - logicaltime),
s_midi.c:        if (midi_inqueue[midi_intail].q_time <= logicaltime - 0.007)
s_midi.c:                1000 * (logicaltime - midi_inqueue[midi_intail].q_time));
s_midi.c:                1000* (logicaltime - midi_inqueue[midi_intail].q_time));
s_midi.c:    if (newtime - lasttime > 0.007)
s_midi.c:        post("delay %d", (int)(1000 * (newtime - lasttime)));
s_midi.c:    sprintf(buf + strlen(buf), "{OSS-MIDI %d} ", API_DEFAULTMIDI); n++;
s_midi.c:    sprintf(buf + strlen(buf), "{ALSA-MIDI %d} ", API_ALSA); n++;
s_midi.c:            newmidiindev[nindev] = newmidiindev[i]-1;
s_midi.c:            newmidioutdev[noutdev] = newmidioutdev[i]-1;
s_midi_dummy.c:/* Copyright (c) 1997-2003 Guenter Geiger, Miller Puckette, Larry Troxler,
s_midi_mmio.c:/* Copyright (c) 1997-1999 Miller Puckette.
s_midi_mmio.c:    /* ------------- MIDI time stamping from audio clock ------------ */
s_midi_mmio.c:static double initsystime = -1;
s_midi_mmio.c:    if (initsystime == -1) msw_resetmidisync();
s_midi_mmio.c:    diff = sys_getrealtime() - 0.001 * clock_gettimesince(initsystime);
s_midi_mmio.c:    if (diff < msw_hibuftime - jittersec)
s_midi_mmio.c:    return (msw_tixtotime(timestamp) - msw_hibuftime);
s_midi_mmio.c:/* ------------------------- MIDI output -------------------------- */
s_midi_mmio.c:/* -------------------------- MIDI input ---------------------------- */
s_midi_mmio.c:   to the low-level callback function.
s_midi_mmio.c:/* AllocCallbackInstanceData - Allocates a CALLBACKINSTANCEDATA
s_midi_mmio.c: *      low-level callback function, each time it receives a message.
s_midi_mmio.c: *      Because this structure is accessed by the low-level callback
s_midi_mmio.c: *      GMEM_SHARE and GMEM_MOVEABLE flags and page-locked with
s_midi_mmio.c:    lpBuf->hSelf = hMem;
s_midi_mmio.c:/* FreeCallbackInstanceData - Frees the given CALLBACKINSTANCEDATA structure.
s_midi_mmio.c: * Params:  lpBuf - Points to the CALLBACKINSTANCEDATA structure to be freed.
s_midi_mmio.c:    hMem = lpBuf->hSelf;
s_midi_mmio.c: * AllocCircularBuffer -    Allocates memory for a CIRCULARBUFFER structure 
s_midi_mmio.c: * with GlobalLock(), and page-locked with GlobalPageLock().
s_midi_mmio.c: * Params:  dwSize - The size of the buffer, in events.
s_midi_mmio.c:     * low-level callback functions must be page locked.
s_midi_mmio.c:    lpBuf->hSelf = hMem;
s_midi_mmio.c:        GlobalUnlock(lpBuf->hSelf);
s_midi_mmio.c:        GlobalFree(lpBuf->hSelf);
s_midi_mmio.c:        GlobalUnlock(lpBuf->hSelf);
s_midi_mmio.c:        GlobalFree(lpBuf->hSelf);
s_midi_mmio.c:     * low-level callback functions must be page locked.
s_midi_mmio.c:    lpBuf->hBuffer = hMem;
s_midi_mmio.c:    lpBuf->wError = 0;
s_midi_mmio.c:    lpBuf->dwSize = dwSize;
s_midi_mmio.c:    lpBuf->dwCount = 0L;
s_midi_mmio.c:    lpBuf->lpStart = lpMem;
s_midi_mmio.c:    lpBuf->lpEnd = lpMem + dwSize;
s_midi_mmio.c:    lpBuf->lpTail = lpMem;
s_midi_mmio.c:    lpBuf->lpHead = lpMem;
s_midi_mmio.c:/* FreeCircularBuffer - Frees the memory for the given CIRCULARBUFFER 
s_midi_mmio.c: * Params:  lpBuf - Points to the CIRCULARBUFFER to be freed.
s_midi_mmio.c:    GlobalSmartPageUnlock((HGLOBAL)HIWORD(lpBuf->lpStart));
s_midi_mmio.c:    GlobalUnlock(lpBuf->hBuffer);
s_midi_mmio.c:    GlobalFree(lpBuf->hBuffer);
s_midi_mmio.c:    hMem = lpBuf->hSelf;
s_midi_mmio.c:/* GetEvent - Gets a MIDI event from the circular input buffer.  Events
s_midi_mmio.c: *  is called by the low-level callback function, so it must reside in
s_midi_mmio.c: * Params:  lpBuf - Points to the circular buffer.
s_midi_mmio.c: *          lpEvent - Points to an EVENT structure that is filled with the
s_midi_mmio.c: * Return:  Returns non-zero if successful, zero if there are no 
s_midi_mmio.c:    if (!wNumDevices || lpBuf->dwCount <= 0) return (0);
s_midi_mmio.c:    *lpEvent = *lpBuf->lpTail;
s_midi_mmio.c:    --lpBuf->dwCount;
s_midi_mmio.c:    ++lpBuf->lpTail;
s_midi_mmio.c:    if(lpBuf->lpTail >= lpBuf->lpEnd)
s_midi_mmio.c:        lpBuf->lpTail = lpBuf->lpStart;
s_midi_mmio.c:/* PutEvent - Puts an EVENT in a CIRCULARBUFFER.  If the buffer is full, 
s_midi_mmio.c: *      to be non-zero.
s_midi_mmio.c: * Params:  lpBuf - Points to the CIRCULARBUFFER.
s_midi_mmio.c: *          lpEvent - Points to the EVENT.
s_midi_mmio.c:    if(lpBuf->dwCount >= lpBuf->dwSize){
s_midi_mmio.c:        lpBuf->wError = 1;
s_midi_mmio.c:    *lpBuf->lpHead = *lpEvent;
s_midi_mmio.c:    ++lpBuf->lpHead;
s_midi_mmio.c:    ++lpBuf->dwCount;
s_midi_mmio.c:    if(lpBuf->lpHead >= lpBuf->lpEnd)
s_midi_mmio.c:        lpBuf->lpHead = lpBuf->lpStart;
s_midi_mmio.c:/* midiInputHandler - Low-level callback function to handle MIDI input.
s_midi_mmio.c: * Param:   hMidiIn - Handle for the associated input device.
s_midi_mmio.c: *          wMsg - One of the MIM_***** messages.
s_midi_mmio.c: *          dwInstance - Points to CALLBACKINSTANCEDATA structure.
s_midi_mmio.c: *          dwParam1 - MIDI data.
s_midi_mmio.c: *          dwParam2 - Timestamp (in milliseconds)
s_midi_mmio.c:            event.dwDevice = ((LPCALLBACKINSTANCEDATA)dwInstance)->dwDevice;
s_midi_mmio.c:            PutEvent(((LPCALLBACKINSTANCEDATA)dwInstance)->lpBuf,
s_midi_mmio.c:    /* Allocate a circular buffer for low-level MIDI input.  This buffer
s_midi_mmio.c:     * is filled by the low-level callback function and emptied by the
s_midi_mmio.c:     * the low-level callback function.  It also includes a device ID,
s_midi_mmio.c:        lpCallbackInstanceData[i]->dwDevice = i;
s_midi_mmio.c:        lpCallbackInstanceData[i]->lpBuf = lpInputBuffer;
s_midi_mmio.c:/* ------------------- public routines -------------------------- */
s_midi_mmio.c:            int msgtype = ((msw_nextevent.data & 0xf0) >> 4) - 8;
s_midi_mmio.c:        indevlist[(i+1) * devdescsize - 1] = 0;
s_midi_mmio.c:        outdevlist[(i+1) * devdescsize - 1] = 0;
s_midi_oss.c:/* Copyright (c) 1997-1999 Guenter Geiger, Miller Puckette, Larry Troxler,
s_midi_oss.c:        oss_midioutfd[i] = -1;
s_midi_oss.c:        int fd = -1, j, outdevindex = -1;
s_midi_oss.c:            /* OK, try read-only */
s_midi_oss.c:                post("tried to open %s read-only; got %d\n",
s_midi_oss.c:                post("tried to open %s write-only; got %d\n",
s_midi_oss.c:        if (throttle-- < 0)
s_midi_oss.c:        if (throttle-- < 0)
s_midi_pm.c:/* Copyright (c) 1997-2003 Guenter Geiger, Miller Puckette, Larry Troxler,
s_midi_pm.c:            if (info->input)
s_midi_pm.c:                            j, info->name, Pm_GetErrorText(err));
s_midi_pm.c:                                info->name);
s_midi_pm.c:            if (info->output)
s_midi_pm.c:                            j, info->name, Pm_GetErrorText(err));
s_midi_pm.c:                                info->name);
s_midi_pm.c:/* this is non-zero if we are in the middle of transmitting sysex */
s_midi_pm.c:            if (!throttle--)
s_midi_pm.c:                int msgtype = (status >> 4) - 8;
s_midi_pm.c:        /* post("%d: %s, %s (%d,%d)", i, info->interf, info->name,
s_midi_pm.c:            info->input, info->output); */
s_midi_pm.c:        if (info->input && nindev < maxndev)
s_midi_pm.c:            strcpy(indevlist + nindev * devdescsize, info->name);
s_midi_pm.c:        if (info->output && noutdev < maxndev)
s_midi_pm.c:            strcpy(outdevlist + noutdev * devdescsize, info->name);
s_path.c:            to[bufsize-1] = 0;
s_path.c:            strncpy(to + strlen(to), from + 1, bufsize - strlen(to));
s_path.c:            to[bufsize-1] = 0;
s_path.c:        to[bufsize-1] = 0;
s_path.c:        ExpandEnvironmentStrings(to, buf, bufsize-1);
s_path.c:        buf[bufsize-1] = 0;
s_path.c:        to[bufsize-1] = 0;
s_path.c:        for (; i < (to_len - 1) && from[i] && from[i] != delim; i++)
s_path.c:    nl2->nl_next = 0;
s_path.c:    nl2->nl_string = (char *)getbytes(strlen(s) + 1);
s_path.c:    strcpy(nl2->nl_string, s);
s_path.c:    sys_unbashfilename(nl2->nl_string, nl2->nl_string);
s_path.c:            if (!allowdup && !strcmp(nl->nl_string, s))
s_path.c:            if (!nl->nl_next)
s_path.c:            nl = nl->nl_next;
s_path.c:        nl->nl_next = nl2;
s_path.c:/* add a colon-separated list of names to a namelist */
s_path.c:        nl2 = nl->nl_next;
s_path.c:        t_freebytes(nl->nl_string, strlen(nl->nl_string) + 1);
s_path.c:    for (i = 0, nl = namelist; i < n && nl; i++, nl = nl->nl_next)
s_path.c:    return (nl ? nl->nl_string : 0);
s_path.c:    sys_expandpath("~/pd-externals", pathbuf, MAXPDSTRING);
s_path.c:    sys_staticpath = namelist_append(sys_staticpath, "/usr/local/lib/pd-externals", 0);
s_path.c:    /* add built-in "extra" path last so its checked last */
s_path.c:        return (-1);
s_path.c:    if (*dirresult && dirresult[strlen(dirresult)-1] != '/')
s_path.c:            fd = -1;
s_path.c:    return (-1);
s_path.c:        dirlen = z - name;
s_path.c:        if (dirlen > MAXPDSTRING-1) 
s_path.c:            dirlen = MAXPDSTRING-1;
s_path.c:canvas-specific path. */
s_path.c:    int fd = -1;
s_path.c:    for (nl = searchpath; nl; nl = nl->nl_next)
s_path.c:        if ((fd = sys_trytoopenone(nl->nl_string, name, ext,
s_path.c:        /* next look in built-in paths like "extra" */
s_path.c:        for (nl = sys_staticpath; nl; nl = nl->nl_next)
s_path.c:            if ((fd = sys_trytoopenone(nl->nl_string, name, ext,
s_path.c:    return (-1);
s_path.c:    /* open a file with a UTF-8 filename
s_path.c:    This is needed because WIN32 does not support UTF-8 filenames, only UCS2.
s_path.c:    u8_utf8toucs2(ucs2path, MAXPDSTRING, pathbuf, MAXPDSTRING-1);
s_path.c:     * so we ignore the argument and just hard-code read/write. */
s_path.c:    u8_utf8toucs2(ucs2buf, MAXPDSTRING, namebuf, MAXPDSTRING-1);
s_path.c:           -> http://www.mail-archive.com/bug-gnulib@gnu.org/msg14212.html
s_path.c:           -> http://bugs.debian.org/647345
s_path.c:   across dll-boundaries, but we provide it for other platforms as well */
s_path.c:        /* 1. "objectname-help.pd" */
s_path.c:    strncpy(realname, name, MAXPDSTRING-10);
s_path.c:    realname[MAXPDSTRING-10] = 0;
s_path.c:    if (strlen(realname) > 3 && !strcmp(realname+strlen(realname)-3, ".pd"))
s_path.c:        realname[strlen(realname)-3] = 0;
s_path.c:    strcat(realname, "-help.pd");
s_path.c:        /* 2. "help-objectname.pd" */
s_path.c:    strcpy(realname, "help-");
s_path.c:    strncat(realname, name, MAXPDSTRING-10);
s_path.c:    realname[MAXPDSTRING-1] = 0;
s_path.c:    /* initialize rc-arg-array so we can safely clean up at the end */
s_path.c:    for (i = 1; i < NUMARGS-1; i++)
s_path.c:    strncat(fname, home? home : ".", MAXPDSTRING-10);
s_path.c:    for (i = 1; i < NUMARGS-1; i++)
s_path.c:    if (i >= NUMARGS-1)
s_path.c:    if (sys_argparse(rcargc-1, rcargv+1))
s_path.c:    for (i = 1; i < NUMARGS-1; i++)
s_path.c:    int i, beginstring = 0, state = 0, len = strlen(sys_flags->s_name);
s_path.c:        error("flags: %s: too long", sys_flags->s_name);
s_path.c:        int c = sys_flags->s_name[i];
s_path.c:                char *foo = malloc(i - beginstring + 1);
s_path.c:                strncpy(foo, sys_flags->s_name + beginstring, i - beginstring);
s_path.c:                foo[i - beginstring] = 0;
s_path.c:    char buf[MAXPDSTRING], *sp = s->s_name;
s_path.c:    for (i = 0; i < MAXPDSTRING-1; i++, sp++)
s_path.c:    /* send the user-specified search path to pd-gui */
s_path.c:    for (nl = sys_searchpath, i = 0; nl; nl = nl->nl_next, i++)
s_path.c:        sys_vgui("lappend ::tmp_path {%s}\n", nl->nl_string);
s_path.c:    /* send the hard-coded search path to pd-gui */
s_path.c:    for (nl = sys_staticpath, i = 0; nl; nl = nl->nl_next, i++)
s_path.c:        sys_vgui("lappend ::tmp_path {%s}\n", nl->nl_string);
s_path.c:    for (i = 0; i < argc-2; i++)
s_path.c:        if (*s->s_name)
s_path.c:            sys_searchpath = namelist_append_files(sys_searchpath, s->s_name);
s_path.c:    sys_vgui("set ::startup_flags {%s}\n", sys_flags->s_name);
s_path.c:    for (nl = sys_externlist, i = 0; nl; nl = nl->nl_next, i++)
s_path.c:        sys_vgui("lappend ::startup_libraries {%s}\n", nl->nl_string);
s_path.c:        sys_flags->s_name);
s_path.c:    for (i = 0; i < argc-2; i++)
s_path.c:        if (*s->s_name)
s_path.c:            sys_externlist = namelist_append_files(sys_externlist, s->s_name);
s_print.c:/* Copyright (c) 1997-1999 Miller Puckette.
s_print.c:        dest[len-1]=0;
s_print.c:    upbuf[MAXPDSTRING-1]=0;
s_print.c:        snprintf(upbuf, MAXPDSTRING-1, "error: %s", s);
s_print.c:    upbuf[MAXPDSTRING-1]=0;
s_print.c:        snprintf(upbuf, MAXPDSTRING-1, "verbose(%d): %s", level, s);
s_print.c:    upbuf[MAXPDSTRING-1]=0;
s_print.c:        snprintf(upbuf, MAXPDSTRING-1, "consistency check failed: %s", s);
s_print.c:    vsnprintf(buf, MAXPDSTRING-1, fmt, ap);
s_print.c:    vsnprintf(buf, MAXPDSTRING-1, fmt, ap);
s_print.c:    vsnprintf(buf, MAXPDSTRING-1, fmt, ap);
s_print.c:    vsnprintf(buf, MAXPDSTRING-1, fmt, ap);
s_print.c:    vsnprintf(buf, MAXPDSTRING-1, fmt, ap);
s_print.c:    /* here's the good way to log errors -- keep a pointer to the
s_print.c:    vsnprintf(buf, MAXPDSTRING-1, fmt, ap);
s_print.c:    if (sscanf(s->s_name, ".x%lx", &obj))
s_print.c:    vsnprintf(buf, MAXPDSTRING-1, fmt, ap);
s_stuff.h:/* Copyright (c) 1997-1999 Miller Puckette.
s_stuff.h:extern int sys_hipriority;      /* real-time flag, true if priority boosted */
s_utf8.c:  Basic UTF-8 manipulation routines
s_utf8.c:  UTF-8 as an internal string encoding. These functions do not perform the
s_utf8.c:  error checking normally needed when handling UTF-8 data, so if you happen
s_utf8.c:/* returns length of next utf-8 sequence */
s_utf8.c:   only works for valid UTF-8, i.e. no 5- or 6-byte sequences
s_utf8.c:   srcsz = source size in bytes, or -1 if 0-terminated
s_utf8.c:   dest will always be L'\0'-terminated, even if there isn't enough room
s_utf8.c:    while (i < sz-1) {
s_utf8.c:        if (srcsz == -1) {
s_utf8.c:        ch -= offsetsFromUTF8[nb];
s_utf8.c:/* srcsz = number of source characters, or -1 if 0-terminated
s_utf8.c:   dest will only be '\0'-terminated if there is enough space. this is
s_utf8.c:   character requires 3 bytes. in this case we could NUL-terminate, but in
s_utf8.c:   only NUL-terminates if all the characters fit, and there's space for
s_utf8.c:            if (dest >= dest_end-1)
s_utf8.c:            if (dest >= dest_end-2)
s_utf8.c:  /*-- moo: support full UCS-4 range? --*/
s_utf8.c:  return 0; /*-- bad input --*/
s_utf8.c:/*-- moo --*/
s_utf8.c:        --charnum;
s_utf8.c:    return (int)(string - str);
s_utf8.c:/* reads the next utf-8 sequence out of a string, updating an index */
s_utf8.c:    ch -= offsetsFromUTF8[sz-1];
s_utf8.c:    (void)(isutf(s[--(*i)]) || isutf(s[--(*i)]) ||
s_utf8.c:           isutf(s[--(*i)]) || --(*i));
s_utf8.c:/*-- moo --*/
s_utf8.c:/*-- moo --*/
s_utf8.c:  (void)(isutf(*(--(*sp))) || isutf(*(--(*sp))) ||
s_utf8.c:         isutf(*(--(*sp))) || --(*sp));
s_utf8.h: *  define this to support the full potential range of UCS-4 codepoints
s_utf8.h: *  (in anticipation of a future UTF-8 standard)
s_utf8.h: *   maximum number of bytes required to represent a single character in UTF-8
s_utf8.h:/*--/moo--*/
s_utf8.h:/* convert UTF-8 data to UCS-2 wide character */
s_utf8.h:/* moo: compute required storage for UTF-8 encoding of 's[0..n-1]' */
s_utf8.h:/* single character to UTF-8, no NUL termination */
s_utf8.h:/* moo: single character to UTF-8, with NUL termination */
s_utf8.h:/* returns length of next utf-8 sequence */
s_watchdog.c:/* Copyright (c) 1997-2000 Miller Puckette.
s_watchdog.c:/* This file is compiled into the separate program, "pd-watchdog," which
tags:!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
tags:_text	m_pd.h	/^typedef struct _text        \/* patchable object - graphical, with text *\/$/;"	s
tags:a_samprate	d_soundfile.c	/^    unsigned char a_samprate[10];   \/* sample rate, 80-bit float! *\/$/;"	m	struct:_aiff	file:
tags:a_symfrom	g_text.c	/^    t_symbol *a_symfrom;    \/* "receive" name -- bind ourselvs to this *\/$/;"	m	struct:_gatom	file:
tags:a_symto	g_text.c	/^    t_symbol *a_symto;      \/* "send" name -- send to this on output *\/$/;"	m	struct:_gatom	file:
tags:a_wherelabel	g_text.c	/^    char a_wherelabel;      \/* 0-3 for left, right, above, below *\/$/;"	m	struct:_gatom	file:
tags:abs_class	x_arithmetic.c	/^static t_class *abs_class;      \/* ----------- abs --------------- *\/$/;"	v	file:
tags:atan2_class	x_arithmetic.c	/^static t_class *atan2_class;    \/* ----------- atan2 --------------- *\/$/;"	v	file:
tags:atan_class	x_arithmetic.c	/^static t_class *atan_class;     \/* ----------- atan --------------- *\/$/;"	v	file:
tags:audio_advance	s_audio.c	/^static int audio_advance = -1;$/;"	v	file:
tags:audio_naudioindev	s_audio.c	/^static int audio_naudioindev = -1;$/;"	v	file:
tags:audio_naudiooutdev	s_audio.c	/^static int audio_naudiooutdev = -1;$/;"	v	file:
tags:c_samprate	d_soundfile.c	/^    unsigned char c_samprate[10];   \/* sample rate, 80-bit float! *\/$/;"	m	struct:_comm	file:
tags:cfftw_bwd	d_fft_fftw.c	/^static cfftw_info cfftw_fwd[MAXFFT+1 - MINFFT],cfftw_bwd[MAXFFT+1 - MINFFT];$/;"	v	file:
tags:cfftw_fwd	d_fft_fftw.c	/^static cfftw_info cfftw_fwd[MAXFFT+1 - MINFFT],cfftw_bwd[MAXFFT+1 - MINFFT];$/;"	v	file:
tags:cos_class	x_arithmetic.c	/^static t_class *cos_class;      \/* ----------- cos --------------- *\/$/;"	v	file:
tags:exp_class	x_arithmetic.c	/^static t_class *exp_class;      \/* ----------- exp --------------- *\/$/;"	v	file:
tags:gl_goprect	g_canvas.h	/^    unsigned int gl_goprect:1;      \/* draw rectangle for graph-on-parent *\/$/;"	m	struct:_glist
tags:gl_hidetext	g_canvas.h	/^    unsigned int gl_hidetext:1;     \/* hide object-name + args when doing graph on parent *\/$/;"	m	struct:_glist
tags:gl_isdeleting	g_canvas.h	/^    unsigned int gl_isdeleting:1;   \/* we're inside glist_delete -- hack! *\/$/;"	m	struct:_glist
tags:initsystime	s_audio_mmio.c	/^static double initsystime = -1;$/;"	v	file:
tags:initsystime	s_midi_mmio.c	/^static double initsystime = -1;$/;"	v	file:
tags:log_class	x_arithmetic.c	/^static t_class *log_class;      \/* ----------- log --------------- *\/$/;"	v	file:
tags:ns_fileid	d_soundfile.c	/^    char ns_fileid[4];      \/* magic number '.snd' if file is big-endian *\/$/;"	m	struct:_nextstep	file:
tags:nt_nextreporttime	s_audio_mmio.c	/^static double nt_nextreporttime = -1;$/;"	v	file:
tags:pd_version	s_main.c	/^char *pd_version = "Pd-" stringify(PD_MAJOR_VERSION) "." stringify(PD_MINOR_VERSION) "." stringify(PD_BUGFIX_VERSION) " (" stringify(PD_TEST_VERSION) ")";$/;"	v
tags:rfftw_bwd	d_fft_fftw.c	/^static rfftw_info rfftw_fwd[MAXFFT+1 - MINFFT],rfftw_bwd[MAXFFT+1 - MINFFT];$/;"	v	file:
tags:rfftw_fwd	d_fft_fftw.c	/^static rfftw_info rfftw_fwd[MAXFFT+1 - MINFFT],rfftw_bwd[MAXFFT+1 - MINFFT];$/;"	v	file:
tags:sc_vec	m_pd.h	/^    t_word sc_vec[1];       \/* indeterminate-length array of words *\/$/;"	m	struct:_scalar
tags:sin_class	x_arithmetic.c	/^static t_class *sin_class;      \/* ----------- sin --------------- *\/$/;"	v	file:
tags:sqrt_class	x_arithmetic.c	/^static t_class *sqrt_class;     \/* ----------- sqrt --------------- *\/$/;"	v	file:
tags:sys_audioapiopened	s_audio.c	/^int sys_audioapiopened = -1;    \/* save last API opened for later closing *\/$/;"	v
tags:sys_hipriority	s_main.c	/^int sys_hipriority = -1;    \/* -1 = don't care; 0 = no; 1 = yes *\/$/;"	v
tags:sys_nchin	s_main.c	/^static int sys_nchin = -1;$/;"	v	file:
tags:sys_nchout	s_main.c	/^static int sys_nchout = -1;$/;"	v	file:
tags:sys_newadctimeminusrealtime	s_midi.c	/^static double sys_newadctimeminusrealtime = -1e20;$/;"	v	file:
tags:sys_newdactimeminusrealtime	s_midi.c	/^static double sys_newdactimeminusrealtime = -1e20;$/;"	v	file:
tags:sys_nmidiin	s_main.c	/^int sys_nmidiin = -1;$/;"	v
tags:sys_nmidiout	s_main.c	/^int sys_nmidiout = -1;$/;"	v
tags:sys_nsoundin	s_main.c	/^static int sys_nsoundin = -1;$/;"	v	file:
tags:sys_nsoundout	s_main.c	/^static int sys_nsoundout = -1;$/;"	v	file:
tags:t_int	m_pd.h	/^typedef PD_LONGINTTYPE t_int;       \/* pointer-size integer *\/$/;"	t
tags:tan_class	x_arithmetic.c	/^static t_class *tan_class;      \/* ----------- tan --------------- *\/$/;"	v	file:
tags:wrap_class	x_arithmetic.c	/^static t_class *wrap_class;      \/* ----------- wrap --------------- *\/$/;"	v	file:
tags:x_bangout	d_soundfile.c	/^    t_outlet *x_bangout;                    \/* bang-on-done outlet *\/$/;"	m	struct:_readsf	file:
tags:x_bigendian	d_soundfile.c	/^    int x_bigendian;        \/* true if file is big-endian *\/$/;"	m	struct:_readsf	file:
tags:x_buf	g_rtext.c	/^    char *x_buf;    \/*-- raw byte string, assumed UTF-8 encoded (moo) --*\/$/;"	m	struct:_rtext	file:
tags:x_bufsize	g_rtext.c	/^    int x_bufsize;  \/*-- byte length --*\/$/;"	m	struct:_rtext	file:
tags:x_downsample	d_ugen.c	/^    int x_downsample;   \/* downsampling-factor *\/$/;"	m	struct:_block	file:
tags:x_phase	d_ugen.c	/^    int x_phase;        \/* from 0 to period-1; when zero we run the block *\/$/;"	m	struct:_block	file:
tags:x_return	d_ugen.c	/^    int x_return;       \/* stop right after this block (for one-shots) *\/$/;"	m	struct:_block	file:
tags:x_selend	g_rtext.c	/^    int x_selend;   \/*-- byte offset --*\/$/;"	m	struct:_rtext	file:
tags:x_selstart	g_rtext.c	/^    int x_selstart; \/*-- byte offset --*\/$/;"	m	struct:_rtext	file:
tags:x_upsample	d_ugen.c	/^    int x_upsample;     \/* upsampling-factor *\/$/;"	m	struct:_block	file:
tags:x_value	d_ctl.c	/^    t_sample x_value; \/* current value of ramp at block-borders *\/$/;"	m	struct:_line	file:
u_pdreceive.c:#define SOCKET_ERROR -1
u_pdreceive.c:    fp->fdp_fd = fd;
u_pdreceive.c:    fp->fdp_outlen = fp->fdp_discard = fp->fdp_gotsemi = 0;
u_pdreceive.c:    if (!(fp->fdp_outbuf = (char*) malloc(BUFSIZE)))
u_pdreceive.c:    for (i = nfdpoll, fp = fdpoll; i--; fp++)
u_pdreceive.c:            x_closesocket(fp->fdp_fd);
u_pdreceive.c:            free(fp->fdp_outbuf);
u_pdreceive.c:            while (i--)
u_pdreceive.c:                (nfdpoll-1) * sizeof(t_fdpoll));
u_pdreceive.c:            nfdpoll--;
u_pdreceive.c:    int outlen = x->fdp_outlen;
u_pdreceive.c:    char *outbuf = x->fdp_outbuf;
u_pdreceive.c:        if((c != '\n') || (!x->fdp_gotsemi))
u_pdreceive.c:        x->fdp_gotsemi = 0; 
u_pdreceive.c:        if (outlen >= (BUFSIZE-1)) /*output buffer overflow; reserve 1 for '\n' */
u_pdreceive.c:            x->fdp_discard = 1;
u_pdreceive.c:            if (!x->fdp_discard)
u_pdreceive.c:            } /* if (!x->fdp_discard) */
u_pdreceive.c:            x->fdp_discard = 0;
u_pdreceive.c:            x->fdp_gotsemi = 1;
u_pdreceive.c:    x->fdp_outlen = outlen;
u_pdreceive.c:    ret = recv(x->fdp_fd, inbuf, BUFSIZE, 0);
u_pdreceive.c:        for (fp = fdpoll, i = nfdpoll; i--; fp++)
u_pdreceive.c:            FD_SET(fp->fdp_fd, &readset);
u_pdsend.c:#define SOCKET_ERROR -1
u_pdsend.c:    memcpy((char *)&server.sin_addr, (char *)hp->h_addr, hp->h_length);
u_pdsend.c:            int res = send(sockfd, bp, nsend-nsent, 0);
x_acoustics.c:/* Copyright (c) 1997-1999 Miller Puckette.
x_acoustics.c:    if (f <= -1500) return(0);
x_acoustics.c:    return (f > 0 ? 17.3123405046 * log(.12231220585 * f) : -1500);
x_acoustics.c:        return (exp((LOGTEN * 0.1) * (f-100.)));
x_acoustics.c:    return (exp((LOGTEN * 0.05) * (f-100.)));
x_acoustics.c:/* ------------- corresponding objects ----------------------- */
x_acoustics.c:    outlet_float(x->ob_outlet, mtof(f));
x_acoustics.c:    outlet_float(x->ob_outlet, ftom(f));
x_acoustics.c:    outlet_float(x->ob_outlet, rmstodb(f));
x_acoustics.c:    outlet_float(x->ob_outlet, powtodb(f));
x_acoustics.c:    outlet_float(x->ob_outlet, dbtopow(f));
x_acoustics.c:    outlet_float(x->ob_outlet, dbtorms(f));
x_arithmetic.c:/* Copyright (c) 1997-1999 Miller Puckette.
x_arithmetic.c:/* ------------------ binop1:  +, -, *, / ----------------------------- */
x_arithmetic.c:    outlet_new(&x->x_obj, &s_float);
x_arithmetic.c:    floatinlet_new(&x->x_obj, &x->x_f2);
x_arithmetic.c:    x->x_f1 = 0;
x_arithmetic.c:    x->x_f2 = f;
x_arithmetic.c:/* --------------------- addition ------------------------------- */
x_arithmetic.c:    outlet_float(x->x_obj.ob_outlet, x->x_f1 + x->x_f2);
x_arithmetic.c:    outlet_float(x->x_obj.ob_outlet, (x->x_f1 = f) + x->x_f2);
x_arithmetic.c:/* --------------------- subtraction ------------------------------- */
x_arithmetic.c:    outlet_float(x->x_obj.ob_outlet, x->x_f1 - x->x_f2);
x_arithmetic.c:    outlet_float(x->x_obj.ob_outlet, (x->x_f1 = f) - x->x_f2);
x_arithmetic.c:/* --------------------- multiplication ------------------------------- */
x_arithmetic.c:    outlet_float(x->x_obj.ob_outlet, x->x_f1 * x->x_f2);
x_arithmetic.c:    outlet_float(x->x_obj.ob_outlet, (x->x_f1 = f) * x->x_f2);
x_arithmetic.c:/* --------------------- division ------------------------------- */
x_arithmetic.c:    outlet_float(x->x_obj.ob_outlet,
x_arithmetic.c:        (x->x_f2 != 0 ? x->x_f1 / x->x_f2 : 0));
x_arithmetic.c:    x->x_f1 = f;
x_arithmetic.c:    outlet_float(x->x_obj.ob_outlet,
x_arithmetic.c:        (x->x_f2 != 0 ? x->x_f1 / x->x_f2 : 0));
x_arithmetic.c:/* ------------------------ pow -------------------------------- */
x_arithmetic.c:    outlet_float(x->x_obj.ob_outlet,
x_arithmetic.c:        (x->x_f1 > 0 ? powf(x->x_f1, x->x_f2) : 0));
x_arithmetic.c:    x->x_f1 = f;
x_arithmetic.c:    outlet_float(x->x_obj.ob_outlet,
x_arithmetic.c:        (x->x_f1 > 0 ? powf(x->x_f1, x->x_f2) : 0));
x_arithmetic.c:/* ------------------------ max -------------------------------- */
x_arithmetic.c:    outlet_float(x->x_obj.ob_outlet,
x_arithmetic.c:        (x->x_f1 > x->x_f2 ? x->x_f1 : x->x_f2));
x_arithmetic.c:    x->x_f1 = f;
x_arithmetic.c:    outlet_float(x->x_obj.ob_outlet,
x_arithmetic.c:        (x->x_f1 > x->x_f2 ? x->x_f1 : x->x_f2));
x_arithmetic.c:/* ------------------------ min -------------------------------- */
x_arithmetic.c:    outlet_float(x->x_obj.ob_outlet,
x_arithmetic.c:        (x->x_f1 < x->x_f2 ? x->x_f1 : x->x_f2));
x_arithmetic.c:    x->x_f1 = f;
x_arithmetic.c:    outlet_float(x->x_obj.ob_outlet,
x_arithmetic.c:        (x->x_f1 < x->x_f2 ? x->x_f1 : x->x_f2));
x_arithmetic.c:/* ------------------ binop2: ==, !=, >, <, >=, <=. -------------------- */
x_arithmetic.c:    outlet_new(&x->x_obj, &s_float);
x_arithmetic.c:    floatinlet_new(&x->x_obj, &x->x_f2);
x_arithmetic.c:    x->x_f1 = 0;
x_arithmetic.c:    x->x_f2 = f;
x_arithmetic.c:/* --------------------- == ------------------------------- */
x_arithmetic.c:    outlet_float(x->x_obj.ob_outlet, x->x_f1 == x->x_f2);
x_arithmetic.c:    outlet_float(x->x_obj.ob_outlet, (x->x_f1 = f) == x->x_f2);
x_arithmetic.c:/* --------------------- != ------------------------------- */
x_arithmetic.c:    outlet_float(x->x_obj.ob_outlet, x->x_f1 != x->x_f2);
x_arithmetic.c:    outlet_float(x->x_obj.ob_outlet, (x->x_f1 = f) != x->x_f2);
x_arithmetic.c:/* --------------------- > ------------------------------- */
x_arithmetic.c:    outlet_float(x->x_obj.ob_outlet, x->x_f1 > x->x_f2);
x_arithmetic.c:    outlet_float(x->x_obj.ob_outlet, (x->x_f1 = f) > x->x_f2);
x_arithmetic.c:/* --------------------- < ------------------------------- */
x_arithmetic.c:    outlet_float(x->x_obj.ob_outlet, x->x_f1 < x->x_f2);
x_arithmetic.c:    outlet_float(x->x_obj.ob_outlet, (x->x_f1 = f) < x->x_f2);
x_arithmetic.c:/* --------------------- >= ------------------------------- */
x_arithmetic.c:    outlet_float(x->x_obj.ob_outlet, x->x_f1 >= x->x_f2);
x_arithmetic.c:    outlet_float(x->x_obj.ob_outlet, (x->x_f1 = f) >= x->x_f2);
x_arithmetic.c:/* --------------------- <= ------------------------------- */
x_arithmetic.c:    outlet_float(x->x_obj.ob_outlet, x->x_f1 <= x->x_f2);
x_arithmetic.c:    outlet_float(x->x_obj.ob_outlet, (x->x_f1 = f) <= x->x_f2);
x_arithmetic.c:/* ------------- binop3: &, |, &&, ||, <<, >>, %, mod, div ------------------ */
x_arithmetic.c:    outlet_new(&x->x_obj, &s_float);
x_arithmetic.c:    floatinlet_new(&x->x_obj, &x->x_f2);
x_arithmetic.c:    x->x_f1 = 0;
x_arithmetic.c:    x->x_f2 = f;
x_arithmetic.c:/* --------------------------- & ---------------------------- */
x_arithmetic.c:    outlet_float(x->x_obj.ob_outlet, ((int)(x->x_f1)) & (int)(x->x_f2));
x_arithmetic.c:    outlet_float(x->x_obj.ob_outlet, ((int)(x->x_f1 = f)) & (int)(x->x_f2));
x_arithmetic.c:/* --------------------------- && ---------------------------- */
x_arithmetic.c:    outlet_float(x->x_obj.ob_outlet, ((int)(x->x_f1)) && (int)(x->x_f2));
x_arithmetic.c:    outlet_float(x->x_obj.ob_outlet, ((int)(x->x_f1 = f)) && (int)(x->x_f2));
x_arithmetic.c:/* --------------------------- | ---------------------------- */
x_arithmetic.c:    outlet_float(x->x_obj.ob_outlet, ((int)(x->x_f1)) | (int)(x->x_f2));
x_arithmetic.c:    outlet_float(x->x_obj.ob_outlet, ((int)(x->x_f1 = f)) | (int)(x->x_f2));
x_arithmetic.c:/* --------------------------- || ---------------------------- */
x_arithmetic.c:    outlet_float(x->x_obj.ob_outlet, ((int)(x->x_f1)) || (int)(x->x_f2));
x_arithmetic.c:    outlet_float(x->x_obj.ob_outlet, ((int)(x->x_f1 = f)) || (int)(x->x_f2));
x_arithmetic.c:/* --------------------------- << ---------------------------- */
x_arithmetic.c:    outlet_float(x->x_obj.ob_outlet, ((int)(x->x_f1)) << (int)(x->x_f2));
x_arithmetic.c:    outlet_float(x->x_obj.ob_outlet, ((int)(x->x_f1 = f)) << (int)(x->x_f2));
x_arithmetic.c:/* --------------------------- >> ---------------------------- */
x_arithmetic.c:    outlet_float(x->x_obj.ob_outlet, ((int)(x->x_f1)) >> (int)(x->x_f2));
x_arithmetic.c:    outlet_float(x->x_obj.ob_outlet, ((int)(x->x_f1 = f)) >> (int)(x->x_f2));
x_arithmetic.c:/* --------------------------- % ---------------------------- */
x_arithmetic.c:    int n2 = x->x_f2;
x_arithmetic.c:    outlet_float(x->x_obj.ob_outlet, ((int)(x->x_f1)) % (n2 ? n2 : 1));
x_arithmetic.c:    int n2 = x->x_f2;
x_arithmetic.c:    outlet_float(x->x_obj.ob_outlet, ((int)(x->x_f1 = f)) % (n2 ? n2 : 1));
x_arithmetic.c:/* --------------------------- mod ---------------------------- */
x_arithmetic.c:    int n2 = x->x_f2, result;
x_arithmetic.c:    if (n2 < 0) n2 = -n2;
x_arithmetic.c:    result = ((int)(x->x_f1)) % n2;
x_arithmetic.c:    outlet_float(x->x_obj.ob_outlet, (t_float)result);
x_arithmetic.c:    x->x_f1 = f;
x_arithmetic.c:/* --------------------------- div ---------------------------- */
x_arithmetic.c:    int n1 = x->x_f1, n2 = x->x_f2, result;
x_arithmetic.c:    if (n2 < 0) n2 = -n2;
x_arithmetic.c:    if (n1 < 0) n1 -= (n2-1);
x_arithmetic.c:    outlet_float(x->x_obj.ob_outlet, (t_float)result);
x_arithmetic.c:    x->x_f1 = f;
x_arithmetic.c:/* -------------------- mathematical functions ------------------ */
x_arithmetic.c:static t_class *sin_class;      /* ----------- sin --------------- */
x_arithmetic.c:    outlet_float(x->ob_outlet, sinf(f));
x_arithmetic.c:static t_class *cos_class;      /* ----------- cos --------------- */
x_arithmetic.c:    outlet_float(x->ob_outlet, cosf(f));
x_arithmetic.c:static t_class *tan_class;      /* ----------- tan --------------- */
x_arithmetic.c:    outlet_float(x->ob_outlet, t);
x_arithmetic.c:static t_class *atan_class;     /* ----------- atan --------------- */
x_arithmetic.c:    outlet_float(x->ob_outlet, atanf(f));
x_arithmetic.c:static t_class *atan2_class;    /* ----------- atan2 --------------- */
x_arithmetic.c:    floatinlet_new(&x->x_ob, &x->x_f);
x_arithmetic.c:    x->x_f = 0;
x_arithmetic.c:    outlet_new(&x->x_ob, &s_float);
x_arithmetic.c:    t_float r = (f == 0 && x->x_f == 0 ? 0 : atan2f(f, x->x_f));
x_arithmetic.c:    outlet_float(x->x_ob.ob_outlet, r);
x_arithmetic.c:static t_class *sqrt_class;     /* ----------- sqrt --------------- */
x_arithmetic.c:    outlet_float(x->ob_outlet, r);
x_arithmetic.c:static t_class *log_class;      /* ----------- log --------------- */
x_arithmetic.c:    t_float r = (f > 0 ? logf(f) : -1000);
x_arithmetic.c:    outlet_float(x->ob_outlet, r);
x_arithmetic.c:static t_class *exp_class;      /* ----------- exp --------------- */
x_arithmetic.c:    outlet_float(x->ob_outlet, g);
x_arithmetic.c:static t_class *abs_class;      /* ----------- abs --------------- */
x_arithmetic.c:    outlet_float(x->ob_outlet, fabsf(f));
x_arithmetic.c:static t_class *wrap_class;      /* ----------- wrap --------------- */
x_arithmetic.c:    outlet_float(x->ob_outlet, f - floor(f));
x_arithmetic.c:/* ------------------------  misc ------------------------ */
x_arithmetic.c:    floatinlet_new(&x->x_ob, &x->x_f2);
x_arithmetic.c:    floatinlet_new(&x->x_ob, &x->x_f3);
x_arithmetic.c:    outlet_new(&x->x_ob, &s_float);
x_arithmetic.c:    x->x_f2 = f1;
x_arithmetic.c:    x->x_f3 = f2;
x_arithmetic.c:        outlet_float(x->x_ob.ob_outlet, (x->x_f1 < x->x_f2 ? x->x_f2 : (
x_arithmetic.c:        x->x_f1 > x->x_f3 ? x->x_f3 : x->x_f1)));
x_arithmetic.c:        x->x_f1 = f;
x_arithmetic.c:        outlet_float(x->x_ob.ob_outlet, (x->x_f1 < x->x_f2 ? x->x_f2 : (
x_arithmetic.c:        x->x_f1 > x->x_f3 ? x->x_f3 : x->x_f1)));
x_arithmetic.c:    binop1_minus_class = class_new(gensym("-"),
x_arithmetic.c:        /* ------------------ binop2 ----------------------- */
x_arithmetic.c:        /* ------------------ binop3 ----------------------- */
x_arithmetic.c:        /* ------------------- math functions --------------- */
x_arithmetic.c:/* ------------------------  misc ------------------------ */
x_connective.c:/* Copyright (c) 1997-1999 Miller Puckette.
x_connective.c:/* -------------------------- int ------------------------------ */
x_connective.c:    x->x_f = f;
x_connective.c:    outlet_new(&x->x_obj, &s_float);
x_connective.c:    floatinlet_new(&x->x_obj, &x->x_f);
x_connective.c:    outlet_float(x->x_obj.ob_outlet, (t_float)(int)(x->x_f));
x_connective.c:    outlet_float(x->x_obj.ob_outlet, (t_float)(int)(x->x_f = f));
x_connective.c:/* -------------------------- float ------------------------------ */
x_connective.c:    they're created by short-circuited messages to the "new"
x_connective.c:    x->x_f = f;
x_connective.c:    outlet_new(&x->x_obj, &s_float);
x_connective.c:    floatinlet_new(&x->x_obj, &x->x_f);
x_connective.c:    newest = &x->x_obj.ob_pd;
x_connective.c:    outlet_float(x->x_obj.ob_outlet, x->x_f);
x_connective.c:    outlet_float(x->x_obj.ob_outlet, x->x_f = f);
x_connective.c:/* -------------------------- symbol ------------------------------ */
x_connective.c:    x->x_s = s;
x_connective.c:    outlet_new(&x->x_obj, &s_symbol);
x_connective.c:    symbolinlet_new(&x->x_obj, &x->x_s);
x_connective.c:    newest = &x->x_obj.ob_pd;
x_connective.c:    outlet_symbol(x->x_obj.ob_outlet, x->x_s);
x_connective.c:    outlet_symbol(x->x_obj.ob_outlet, x->x_s = s);
x_connective.c:    outlet_symbol(x->x_obj.ob_outlet, x->x_s = s);
x_connective.c:    else if (av->a_type == A_SYMBOL)
x_connective.c:        pdsymbol_symbol(x, av->a_w.w_symbol);
x_connective.c:/* -------------------------- bang ------------------------------ */
x_connective.c:    outlet_new(&x->x_obj, &s_bang);
x_connective.c:    newest = &x->x_obj.ob_pd;
x_connective.c:    outlet_bang(x->x_obj.ob_outlet);
x_connective.c:/* -------------------- send ------------------------------ */
x_connective.c:    if (x->x_sym->s_thing) pd_bang(x->x_sym->s_thing);
x_connective.c:    if (x->x_sym->s_thing) pd_float(x->x_sym->s_thing, f);
x_connective.c:    if (x->x_sym->s_thing) pd_symbol(x->x_sym->s_thing, s);
x_connective.c:    if (x->x_sym->s_thing) pd_pointer(x->x_sym->s_thing, gp);
x_connective.c:    if (x->x_sym->s_thing) pd_list(x->x_sym->s_thing, s, argc, argv);
x_connective.c:    if (x->x_sym->s_thing) typedmess(x->x_sym->s_thing, s, argc, argv);
x_connective.c:    if (!*s->s_name)
x_connective.c:        symbolinlet_new(&x->x_obj, &x->x_sym);
x_connective.c:    x->x_sym = s;
x_connective.c:/* -------------------- receive ------------------------------ */
x_connective.c:    outlet_bang(x->x_obj.ob_outlet);
x_connective.c:    outlet_float(x->x_obj.ob_outlet, f);
x_connective.c:    outlet_symbol(x->x_obj.ob_outlet, s);
x_connective.c:    outlet_pointer(x->x_obj.ob_outlet, gp);
x_connective.c:    outlet_list(x->x_obj.ob_outlet, s, argc, argv);
x_connective.c:    outlet_anything(x->x_obj.ob_outlet, s, argc, argv);
x_connective.c:    x->x_sym = s;
x_connective.c:    pd_bind(&x->x_obj.ob_pd, s);
x_connective.c:    outlet_new(&x->x_obj, 0);
x_connective.c:    pd_unbind(&x->x_obj.ob_pd, x->x_sym);
x_connective.c:/* -------------------------- select ------------------------------ */
x_connective.c:    if (x->x_atom.a_type == A_FLOAT && f == x->x_atom.a_w.w_float)
x_connective.c:        outlet_bang(x->x_outlet1);
x_connective.c:    else outlet_float(x->x_outlet2, f);
x_connective.c:    if (x->x_atom.a_type == A_SYMBOL && s == x->x_atom.a_w.w_symbol)
x_connective.c:        outlet_bang(x->x_outlet1);
x_connective.c:    else outlet_symbol(x->x_outlet2, s);
x_connective.c:    if (x->x_type == A_FLOAT)
x_connective.c:        for (nelement = x->x_nelement, e = x->x_vec; nelement--; e++)
x_connective.c:            if (e->e_w.w_float == f)
x_connective.c:            outlet_bang(e->e_outlet);
x_connective.c:    outlet_float(x->x_rejectout, f);
x_connective.c:    if (x->x_type == A_SYMBOL)
x_connective.c:        for (nelement = x->x_nelement, e = x->x_vec; nelement--; e++)
x_connective.c:            if (e->e_w.w_symbol == s)
x_connective.c:            outlet_bang(e->e_outlet);
x_connective.c:    outlet_symbol(x->x_rejectout, s);
x_connective.c:    freebytes(x->x_vec, x->x_nelement * sizeof(*x->x_vec));
x_connective.c:        x->x_atom = *argv;
x_connective.c:        x->x_outlet1 = outlet_new(&x->x_obj, &s_bang);
x_connective.c:        if (argv->a_type == A_FLOAT)
x_connective.c:            floatinlet_new(&x->x_obj, &x->x_atom.a_w.w_float);
x_connective.c:            x->x_outlet2 = outlet_new(&x->x_obj, &s_float);
x_connective.c:            symbolinlet_new(&x->x_obj, &x->x_atom.a_w.w_symbol);
x_connective.c:            x->x_outlet2 = outlet_new(&x->x_obj, &s_symbol);
x_connective.c:        x->x_nelement = argc;
x_connective.c:        x->x_vec = (t_selectelement *)getbytes(argc * sizeof(*x->x_vec));
x_connective.c:        x->x_type = argv[0].a_type;
x_connective.c:        for (n = 0, e = x->x_vec; n < argc; n++, e++)
x_connective.c:            e->e_outlet = outlet_new(&x->x_obj, &s_bang);
x_connective.c:            if ((x->x_type = argv->a_type) == A_FLOAT)
x_connective.c:                e->e_w.w_float = atom_getfloatarg(n, argc, argv);
x_connective.c:            else e->e_w.w_symbol = atom_getsymbolarg(n, argc, argv);
x_connective.c:        x->x_rejectout = outlet_new(&x->x_obj, &s_float);
x_connective.c:/* -------------------------- route ------------------------------ */
x_connective.c:    if (x->x_type == A_SYMBOL) 
x_connective.c:        for (nelement = x->x_nelement, e = x->x_vec; nelement--; e++)
x_connective.c:            if (e->e_w.w_symbol == sel)
x_connective.c:                outlet_anything(e->e_outlet, argv[0].a_w.w_symbol,
x_connective.c:                    argc-1, argv+1);
x_connective.c:            else outlet_list(e->e_outlet, 0, argc, argv);
x_connective.c:    outlet_anything(x->x_rejectout, sel, argc, argv);
x_connective.c:    if (x->x_type == A_FLOAT)
x_connective.c:        if (argv->a_type != A_FLOAT)
x_connective.c:        for (nelement = x->x_nelement, e = x->x_vec; nelement--; e++)
x_connective.c:            if (e->e_w.w_float == f)
x_connective.c:                outlet_anything(e->e_outlet, argv[1].a_w.w_symbol,
x_connective.c:                    argc-2, argv+2);
x_connective.c:            else outlet_list(e->e_outlet, 0, argc-1, argv+1);
x_connective.c:            for (nelement = x->x_nelement, e = x->x_vec; nelement--; e++)
x_connective.c:                if (e->e_w.w_symbol == &s_list)
x_connective.c:                        outlet_anything(e->e_outlet, argv[0].a_w.w_symbol,
x_connective.c:                            argc-1, argv+1);
x_connective.c:                    else outlet_list(e->e_outlet, 0, argc, argv);
x_connective.c:            for (nelement = x->x_nelement, e = x->x_vec; nelement--; e++)
x_connective.c:                if (e->e_w.w_symbol == &s_bang)
x_connective.c:                    outlet_bang(e->e_outlet);
x_connective.c:            for (nelement = x->x_nelement, e = x->x_vec; nelement--; e++)
x_connective.c:                if (e->e_w.w_symbol == &s_float)
x_connective.c:                    outlet_float(e->e_outlet, argv[0].a_w.w_float);
x_connective.c:            for (nelement = x->x_nelement, e = x->x_vec; nelement--; e++)
x_connective.c:                if (e->e_w.w_symbol == &s_symbol)
x_connective.c:                    outlet_symbol(e->e_outlet, argv[0].a_w.w_symbol);
x_connective.c:    outlet_list(x->x_rejectout, 0, argc, argv);
x_connective.c:    freebytes(x->x_vec, x->x_nelement * sizeof(*x->x_vec));
x_connective.c:    x->x_type = argv[0].a_type;
x_connective.c:    x->x_nelement = argc;
x_connective.c:    x->x_vec = (t_routeelement *)getbytes(argc * sizeof(*x->x_vec));
x_connective.c:    for (n = 0, e = x->x_vec; n < argc; n++, e++)
x_connective.c:        e->e_outlet = outlet_new(&x->x_obj, &s_list);
x_connective.c:        if (x->x_type == A_FLOAT)
x_connective.c:            e->e_w.w_float = atom_getfloatarg(n, argc, argv);
x_connective.c:        else e->e_w.w_symbol = atom_getsymbolarg(n, argc, argv);
x_connective.c:        if (argv->a_type == A_FLOAT)
x_connective.c:            floatinlet_new(&x->x_obj, &x->x_vec->e_w.w_float);
x_connective.c:        else symbolinlet_new(&x->x_obj, &x->x_vec->e_w.w_symbol);
x_connective.c:    x->x_rejectout = outlet_new(&x->x_obj, &s_list);
x_connective.c:/* -------------------------- pack ------------------------------ */
x_connective.c:    x->x_n = argc;
x_connective.c:    vec = x->x_vec = (t_atom *)getbytes(argc * sizeof(*x->x_vec));
x_connective.c:    x->x_outvec = (t_atom *)getbytes(argc * sizeof(*x->x_outvec));
x_connective.c:    for (i = argc, ap = argv; i--; ap++)
x_connective.c:        if (ap->a_type == A_SYMBOL && *ap->a_w.w_symbol->s_name == 'p')
x_connective.c:    gp = x->x_gpointer = (t_gpointer *)t_getbytes(nptr * sizeof (*gp));
x_connective.c:    x->x_nptr = nptr;
x_connective.c:    for (i = 0, vp = x->x_vec, ap = argv; i < argc; i++, ap++, vp++)
x_connective.c:        if (ap->a_type == A_FLOAT)
x_connective.c:            if (i) floatinlet_new(&x->x_obj, &vp->a_w.w_float);
x_connective.c:        else if (ap->a_type == A_SYMBOL)
x_connective.c:            char c = *ap->a_w.w_symbol->s_name;
x_connective.c:                if (i) symbolinlet_new(&x->x_obj, &vp->a_w.w_symbol);
x_connective.c:                vp->a_type = A_POINTER;
x_connective.c:                vp->a_w.w_gpointer = gp;
x_connective.c:                if (i) pointerinlet_new(&x->x_obj, gp);
x_connective.c:                    ap->a_w.w_symbol->s_name);
x_connective.c:                if (i) floatinlet_new(&x->x_obj, &vp->a_w.w_float);
x_connective.c:    outlet_new(&x->x_obj, &s_list);
x_connective.c:    int i, reentered = 0, size = x->x_n * sizeof (t_atom);
x_connective.c:    for (i = x->x_nptr, gp = x->x_gpointer; i--; gp++)
x_connective.c:        /* reentrancy protection.  The first time through use the pre-allocated
x_connective.c:    if (!x->x_outvec)
x_connective.c:        if (x->x_nptr)
x_connective.c:        outvec = x->x_outvec;
x_connective.c:        x->x_outvec = 0;
x_connective.c:    memcpy(outvec, x->x_vec, size);
x_connective.c:    outlet_list(x->x_obj.ob_outlet, &s_list, x->x_n, outvec);
x_connective.c:    else x->x_outvec = outvec;
x_connective.c:    if (x->x_vec->a_type == A_POINTER)
x_connective.c:        gpointer_unset(x->x_gpointer);
x_connective.c:        *x->x_gpointer = *gp;
x_connective.c:        if (gp->gp_stub) gp->gp_stub->gs_refcount++;
x_connective.c:    if (x->x_vec->a_type == A_FLOAT)
x_connective.c:        x->x_vec->a_w.w_float = f;
x_connective.c:    if (x->x_vec->a_type == A_SYMBOL)
x_connective.c:        x->x_vec->a_w.w_symbol = s;
x_connective.c:    obj_list(&x->x_obj, 0, ac, av);
x_connective.c:    obj_list(&x->x_obj, 0, ac+1, av2);
x_connective.c:    for (gp = x->x_gpointer, i = x->x_nptr; i--; gp++)
x_connective.c:    freebytes(x->x_vec, x->x_n * sizeof(*x->x_vec));
x_connective.c:    freebytes(x->x_outvec, x->x_n * sizeof(*x->x_outvec));
x_connective.c:    freebytes(x->x_gpointer, x->x_nptr * sizeof(*x->x_gpointer));
x_connective.c:/* -------------------------- unpack ------------------------------ */
x_connective.c:    x->x_n = argc;
x_connective.c:    x->x_vec = (t_unpackout *)getbytes(argc * sizeof(*x->x_vec));
x_connective.c:    for (i = 0, ap = argv, u = x->x_vec; i < argc; u++, ap++, i++)
x_connective.c:        t_atomtype type = ap->a_type;
x_connective.c:            char c = *ap->a_w.w_symbol->s_name;
x_connective.c:                u->u_type = A_SYMBOL;
x_connective.c:                u->u_outlet = outlet_new(&x->x_obj, &s_symbol);
x_connective.c:                u->u_type =  A_POINTER;
x_connective.c:                u->u_outlet = outlet_new(&x->x_obj, &s_pointer);
x_connective.c:                    ap->a_w.w_symbol->s_name);
x_connective.c:                u->u_type = A_FLOAT;
x_connective.c:                u->u_outlet = outlet_new(&x->x_obj, &s_float);
x_connective.c:            u->u_type =  A_FLOAT;
x_connective.c:            u->u_outlet = outlet_new(&x->x_obj, &s_float);
x_connective.c:    if (argc > x->x_n) argc = x->x_n;
x_connective.c:    for (i = argc, u = x->x_vec + i, ap = argv + i; u--, ap--, i--;)
x_connective.c:        t_atomtype type = u->u_type;
x_connective.c:        if (type != ap->a_type)
x_connective.c:            outlet_float(u->u_outlet, ap->a_w.w_float);
x_connective.c:            outlet_symbol(u->u_outlet, ap->a_w.w_symbol);
x_connective.c:        else outlet_pointer(u->u_outlet, ap->a_w.w_gpointer);
x_connective.c:    freebytes(x->x_vec, x->x_n * sizeof(*x->x_vec));
x_connective.c:/* -------------------------- trigger ------------------------------ */
x_connective.c:    x->x_n = argc;
x_connective.c:    x->x_vec = (t_triggerout *)getbytes(argc * sizeof(*x->x_vec));
x_connective.c:    for (i = 0, ap = argv, u = x->x_vec; i < argc; u++, ap++, i++)
x_connective.c:        t_atomtype thistype = ap->a_type;
x_connective.c:        if (thistype == TR_SYMBOL) c = ap->a_w.w_symbol->s_name[0];
x_connective.c:            u->u_type = TR_POINTER,
x_connective.c:                u->u_outlet = outlet_new(&x->x_obj, &s_pointer);
x_connective.c:            u->u_type = TR_FLOAT, u->u_outlet = outlet_new(&x->x_obj, &s_float);
x_connective.c:            u->u_type = TR_BANG, u->u_outlet = outlet_new(&x->x_obj, &s_bang);
x_connective.c:            u->u_type = TR_LIST, u->u_outlet = outlet_new(&x->x_obj, &s_list);
x_connective.c:            u->u_type = TR_SYMBOL,
x_connective.c:                u->u_outlet = outlet_new(&x->x_obj, &s_symbol);
x_connective.c:            u->u_type = TR_ANYTHING,
x_connective.c:                u->u_outlet = outlet_new(&x->x_obj, &s_symbol);
x_connective.c:            pd_error(x, "trigger: %s: bad type", ap->a_w.w_symbol->s_name);
x_connective.c:            u->u_type = TR_FLOAT, u->u_outlet = outlet_new(&x->x_obj, &s_float);
x_connective.c:    for (i = x->x_n, u = x->x_vec + i; u--, i--;)
x_connective.c:        if (u->u_type == TR_FLOAT)
x_connective.c:            outlet_float(u->u_outlet, (argc ? atom_getfloat(argv) : 0));
x_connective.c:        else if (u->u_type == TR_BANG)
x_connective.c:            outlet_bang(u->u_outlet);
x_connective.c:        else if (u->u_type == TR_SYMBOL)
x_connective.c:            outlet_symbol(u->u_outlet,
x_connective.c:        else if (u->u_type == TR_POINTER)
x_connective.c:            if (!argc || argv->a_type != TR_POINTER)
x_connective.c:            else outlet_pointer(u->u_outlet, argv->a_w.w_gpointer);
x_connective.c:        else outlet_list(u->u_outlet, &s_list, argc, argv);
x_connective.c:    for (i = x->x_n, u = x->x_vec + i; u--, i--;)
x_connective.c:        if (u->u_type == TR_BANG)
x_connective.c:            outlet_bang(u->u_outlet);
x_connective.c:        else if (u->u_type == TR_ANYTHING)
x_connective.c:            outlet_anything(u->u_outlet, s, argc, argv);
x_connective.c:    freebytes(x->x_vec, x->x_n * sizeof(*x->x_vec));
x_connective.c:/* -------------------------- spigot ------------------------------ */
x_connective.c:    floatinlet_new(&x->x_obj, &x->x_state);
x_connective.c:    outlet_new(&x->x_obj, 0);
x_connective.c:    x->x_state = f;
x_connective.c:    if (x->x_state != 0) outlet_bang(x->x_obj.ob_outlet);
x_connective.c:    if (x->x_state != 0) outlet_pointer(x->x_obj.ob_outlet, gp);
x_connective.c:    if (x->x_state != 0) outlet_float(x->x_obj.ob_outlet, f);
x_connective.c:    if (x->x_state != 0) outlet_symbol(x->x_obj.ob_outlet, s);
x_connective.c:    if (x->x_state != 0) outlet_list(x->x_obj.ob_outlet, s, argc, argv);
x_connective.c:    if (x->x_state != 0) outlet_anything(x->x_obj.ob_outlet, s, argc, argv);
x_connective.c:/* --------------------------- moses ----------------------------- */
x_connective.c:    floatinlet_new(&x->x_ob, &x->x_y);
x_connective.c:    outlet_new(&x->x_ob, &s_float);
x_connective.c:    x->x_out2 = outlet_new(&x->x_ob, &s_float);
x_connective.c:    x->x_y = f;
x_connective.c:    if (f < x->x_y) outlet_float(x->x_ob.ob_outlet, f);
x_connective.c:    else outlet_float(x->x_out2, f);
x_connective.c:/* ----------------------- until --------------------- */
x_connective.c:    inlet_new(&x->x_obj, &x->x_obj.ob_pd, gensym("bang"), gensym("bang2"));
x_connective.c:    outlet_new(&x->x_obj, &s_bang);
x_connective.c:    x->x_run = 0;
x_connective.c:    x->x_run = 1;
x_connective.c:    x->x_count = -1;
x_connective.c:    while (x->x_run && x->x_count)
x_connective.c:        x->x_count--, outlet_bang(x->x_obj.ob_outlet);
x_connective.c:    x->x_run = 1;
x_connective.c:    x->x_count = f;
x_connective.c:    while (x->x_run && x->x_count)
x_connective.c:        x->x_count--, outlet_bang(x->x_obj.ob_outlet);
x_connective.c:    x->x_run = 0;
x_connective.c:/* ----------------------- makefilename --------------------- */
x_connective.c:    if (!x->x_format) return;
x_connective.c:    x->x_accept = A_NULL;
x_connective.c:    for (str=x->x_format->s_name; *str; str++) {
x_connective.c:            if (strchr("-.#0123456789",*str)!=0)
x_connective.c:                x->x_accept = A_SYMBOL;
x_connective.c:                x->x_intconvert = 0;
x_connective.c:                x->x_accept = A_FLOAT;
x_connective.c:                x->x_intconvert = 0;
x_connective.c:                x->x_accept = A_FLOAT;
x_connective.c:                x->x_intconvert = 1;
x_connective.c:    if (!s || !*s->s_name)
x_connective.c:    outlet_new(&x->x_obj, &s_symbol);
x_connective.c:    x->x_format = s;
x_connective.c:    x->x_accept = A_NULL;
x_connective.c:    x->x_intconvert = 0;
x_connective.c:    if (x->x_accept == A_FLOAT) {
x_connective.c:        if (x->x_intconvert)
x_connective.c:            sprintf(buf, x->x_format->s_name, (int)f);
x_connective.c:        else sprintf(buf, x->x_format->s_name, f);
x_connective.c:        sprintf(buf, x->x_format->s_name, buf2);
x_connective.c:    outlet_symbol(x->x_obj.ob_outlet, gensym(buf));
x_connective.c:    if (x->x_accept == A_SYMBOL)
x_connective.c:    sprintf(buf, x->x_format->s_name, s->s_name);
x_connective.c:        sprintf(buf, x->x_format->s_name, 0);
x_connective.c:    outlet_symbol(x->x_obj.ob_outlet, gensym(buf));
x_connective.c:    x->x_format = s;
x_connective.c:/* -------------------------- swap ------------------------------ */
x_connective.c:    x->x_f2 = f;
x_connective.c:    x->x_f1 = 0;
x_connective.c:    outlet_new(&x->x_obj, &s_float);
x_connective.c:    x->x_out2 = outlet_new(&x->x_obj, &s_float);
x_connective.c:    floatinlet_new(&x->x_obj, &x->x_f2);
x_connective.c:    outlet_float(x->x_out2, x->x_f1);
x_connective.c:    outlet_float(x->x_obj.ob_outlet, x->x_f2);
x_connective.c:    x->x_f1 = f;
x_connective.c:/* -------------------------- change ------------------------------ */
x_connective.c:    x->x_f = f;
x_connective.c:    outlet_new(&x->x_obj, &s_float);
x_connective.c:    outlet_float(x->x_obj.ob_outlet, x->x_f);
x_connective.c:    if (f != x->x_f)
x_connective.c:        x->x_f = f;
x_connective.c:        outlet_float(x->x_obj.ob_outlet, x->x_f);
x_connective.c:    x->x_f = f;
x_connective.c:/* -------------------- value ------------------------------ */
x_connective.c:    /* get a pointer to a named floating-point variable.  The variable
x_connective.c:        c->c_f = 0;
x_connective.c:        c->c_refcount = 0;
x_connective.c:        pd_bind(&c->c_pd, s);
x_connective.c:    c->c_refcount++;
x_connective.c:    return (&c->c_f);
x_connective.c:        if (!--c->c_refcount)
x_connective.c:            pd_unbind(&c->c_pd, s);
x_connective.c:            pd_free(&c->c_pd);
x_connective.c: * value_getfloat -- obtain the float value of a "value" object 
x_connective.c:    *f = c->c_f;
x_connective.c: * value_setfloat -- set the float value of a "value" object
x_connective.c:    c->c_f = f; 
x_connective.c:    x->x_sym = s;
x_connective.c:    x->x_floatstar = value_get(s);
x_connective.c:    outlet_new(&x->x_obj, &s_float);
x_connective.c:    outlet_float(x->x_obj.ob_outlet, *x->x_floatstar);
x_connective.c:    *x->x_floatstar = f;
x_connective.c:    value_release(x->x_sym);
x_connective.c:/* -------------- overall setup routine for this file ----------------- */
x_gui.c:/* Copyright (c) 1997-2000 Miller Puckette.
x_gui.c:/* --------------------- graphics responder  ---------------- */
x_gui.c:    for (x = gfxstub_list; x; x = x->x_next)
x_gui.c:        if (x->x_key == key)
x_gui.c:    pd_bind(&x->x_pd, s);
x_gui.c:    x->x_owner = owner;
x_gui.c:    x->x_sym = s;
x_gui.c:    x->x_key = key;
x_gui.c:    x->x_next = gfxstub_list;
x_gui.c:    afterpercentlen = afterpercent - cmd;
x_gui.c:    sprintf(buf, sprintfbuf, s->s_name);
x_gui.c:    strncat(buf, afterpercent, (4*MAXPDSTRING) - afterpercentlen);
x_gui.c:        gfxstub_list = x->x_next;
x_gui.c:    else for (y1 = gfxstub_list; y2 = y1->x_next; y1 = y2)
x_gui.c:        y1->x_next = y2->x_next;
x_gui.c:        for (y = gfxstub_list; y; y = y->x_next)
x_gui.c:            if (y->x_key == key)
x_gui.c:                y->x_owner = 0;
x_gui.c:/* --------- pd messages for gfxstub (these come from the GUI) ---------- */
x_gui.c:    gfxstub_deleteforkey(x->x_key);
x_gui.c:    pd_free(&x->x_pd);
x_gui.c:    canvas_dataproperties((t_canvas *)x->x_owner,
x_gui.c:        (t_scalar *)x->x_key, gfxstub_binbuf);
x_gui.c:    if (x->x_owner)
x_gui.c:        pd_typedmess(x->x_owner, s, argc, argv);
x_gui.c:    pd_unbind(&x->x_pd, x->x_sym);
x_gui.c:/* -------------------------- openpanel ------------------------------ */
x_gui.c:    x->x_s = gensym(buf);
x_gui.c:    pd_bind(&x->x_obj.ob_pd, x->x_s);
x_gui.c:    outlet_new(&x->x_obj, &s_symbol);
x_gui.c:    char *path = (s && s->s_name) ? s->s_name : "\"\"";
x_gui.c:    sys_vgui("pdtk_openpanel {%s} {%s}\n", x->x_s->s_name, path);
x_gui.c:    outlet_symbol(x->x_obj.ob_outlet, s);
x_gui.c:    pd_unbind(&x->x_obj.ob_pd, x->x_s);
x_gui.c:/* -------------------------- savepanel ------------------------------ */
x_gui.c:    x->x_s = gensym(buf);
x_gui.c:    x->x_canvas = canvas_getcurrent();
x_gui.c:    pd_bind(&x->x_obj.ob_pd, x->x_s);
x_gui.c:    outlet_new(&x->x_obj, &s_symbol);
x_gui.c:    char *path = (s && s->s_name) ? s->s_name : "\"\"";
x_gui.c:    sys_vgui("pdtk_savepanel {%s} {%s}\n", x->x_s->s_name, path);
x_gui.c:    outlet_symbol(x->x_obj.ob_outlet, s);
x_gui.c:    pd_unbind(&x->x_obj.ob_pd, x->x_s);
x_gui.c:/* ---------------------- key and its relatives ------------------ */
x_gui.c:    outlet_new(&x->x_obj, &s_float);
x_gui.c:    pd_bind(&x->x_obj.ob_pd, key_sym);
x_gui.c:    outlet_float(x->x_obj.ob_outlet, f);
x_gui.c:    pd_unbind(&x->x_obj.ob_pd, key_sym);
x_gui.c:    outlet_new(&x->x_obj, &s_float);
x_gui.c:    pd_bind(&x->x_obj.ob_pd, keyup_sym);
x_gui.c:    outlet_float(x->x_obj.ob_outlet, f);
x_gui.c:    pd_unbind(&x->x_obj.ob_pd, keyup_sym);
x_gui.c:    x->x_outlet1 = outlet_new(&x->x_obj, &s_float);
x_gui.c:    x->x_outlet2 = outlet_new(&x->x_obj, &s_symbol);
x_gui.c:    pd_bind(&x->x_obj.ob_pd, keyname_sym);
x_gui.c:    outlet_symbol(x->x_outlet2, atom_getsymbolarg(1, ac, av));
x_gui.c:    outlet_float(x->x_outlet1, atom_getfloatarg(0, ac, av));
x_gui.c:    pd_unbind(&x->x_obj.ob_pd, keyname_sym);
x_gui.c:/* -------------------------- setup routine ------------------------------ */
x_interface.c:/* Copyright (c) 1997-1999 Miller Puckette.
x_interface.c:/* -------------------------- print ------------------------------ */
x_interface.c:        x->x_sym = gensym("print");
x_interface.c:    else if (argc == 1 && argv->a_type == A_SYMBOL)
x_interface.c:        if (!strcmp(s->s_name, "-n"))
x_interface.c:            x->x_sym = &s_;
x_interface.c:        else x->x_sym = s;
x_interface.c:        x->x_sym = gensym(buf);
x_interface.c:    post("%s%sbang", x->x_sym->s_name, (*x->x_sym->s_name ? ": " : ""));
x_interface.c:    post("%s%s(gpointer)", x->x_sym->s_name, (*x->x_sym->s_name ? ": " : ""));
x_interface.c:    post("%s%s%g", x->x_sym->s_name, (*x->x_sym->s_name ? ": " : ""), f);
x_interface.c:    if (argc && argv->a_type != A_SYMBOL) startpost("%s:", x->x_sym->s_name);
x_interface.c:    else startpost("%s%s%s", x->x_sym->s_name,
x_interface.c:        (*x->x_sym->s_name ? ": " : ""),
x_interface.c:    startpost("%s%s%s", x->x_sym->s_name, (*x->x_sym->s_name ? ": " : ""),
x_interface.c:        s->s_name);
x_list.c:/* Copyright (c) 1997- Miller Puckette and others.
x_list.c:    list append - append a list to another
x_list.c:    list prepend - prepend a list to another
x_list.c:    list split - first n elements to first outlet, rest to second outlet 
x_list.c:    list trim - trim off "list" selector
x_list.c:    list length - output number of items in list
x_list.c:    list foreach - spit out elements of a list one by one (also in reverse?)
x_list.c:    list array - get items from a named array as a list
x_list.c:    list reverse - permute elements of a list back to front
x_list.c:    list pack - synonym for 'pack'
x_list.c:    list unpack - synonym for 'unpack'
x_list.c:    list cat - build a list by accumulating elements
x_list.c:    list first - output first n elements.
x_list.c:    list last - output last n elements
x_list.c:    list nth - nth item in list, counting from zero
x_list.c:/* -------------- utility functions: storage, copying  -------------- */
x_list.c:/* ------------- fake class to divert inlets to ----------------- */
x_list.c:    x->l_pd = alist_class;
x_list.c:    x->l_n = x->l_npointer = 0;
x_list.c:    x->l_vec = 0;
x_list.c:    for (i = 0; i < x->l_n; i++)
x_list.c:        if (x->l_vec[i].l_a.a_type == A_POINTER)
x_list.c:            gpointer_unset(x->l_vec[i].l_a.a_w.w_gpointer);
x_list.c:    if (x->l_vec)
x_list.c:        freebytes(x->l_vec, x->l_n * sizeof(*x->l_vec));
x_list.c:    if (!(x->l_vec = (t_listelem *)getbytes(argc * sizeof(*x->l_vec))))
x_list.c:        x->l_n = 0;
x_list.c:    x->l_n = argc;
x_list.c:    x->l_npointer = 0;
x_list.c:        x->l_vec[i].l_a = argv[i];
x_list.c:        if (x->l_vec[i].l_a.a_type == A_POINTER)
x_list.c:            x->l_npointer++;
x_list.c:            gpointer_copy(x->l_vec[i].l_a.a_w.w_gpointer, &x->l_vec[i].l_p);
x_list.c:            x->l_vec[i].l_a.a_w.w_gpointer = &x->l_vec[i].l_p;
x_list.c:    if (!(x->l_vec = (t_listelem *)getbytes((argc+1) * sizeof(*x->l_vec))))
x_list.c:        x->l_n = 0;
x_list.c:    x->l_n = argc+1;
x_list.c:    x->l_npointer = 0;
x_list.c:    SETSYMBOL(&x->l_vec[0].l_a, s);
x_list.c:        x->l_vec[i+1].l_a = argv[i];
x_list.c:        if (x->l_vec[i+1].l_a.a_type == A_POINTER)
x_list.c:            x->l_npointer++;            
x_list.c:            gpointer_copy(x->l_vec[i+1].l_a.a_w.w_gpointer, &x->l_vec[i+1].l_p);
x_list.c:            x->l_vec[i+1].l_a.a_w.w_gpointer = &x->l_vec[i+1].l_p;
x_list.c:    for (i = 0; i < x->l_n; i++)
x_list.c:        to[i] = x->l_vec[i].l_a;
x_list.c:    y->l_pd = alist_class;
x_list.c:    y->l_n = x->l_n;
x_list.c:    y->l_npointer = x->l_npointer;
x_list.c:    if (!(y->l_vec = (t_listelem *)getbytes(y->l_n * sizeof(*y->l_vec))))
x_list.c:        y->l_n = 0;
x_list.c:    else for (i = 0; i < x->l_n; i++)
x_list.c:        y->l_vec[i].l_a = x->l_vec[i].l_a;
x_list.c:        if (y->l_vec[i].l_a.a_type == A_POINTER)
x_list.c:            gpointer_copy(y->l_vec[i].l_a.a_w.w_gpointer, &y->l_vec[i].l_p);
x_list.c:            y->l_vec[i].l_a.a_w.w_gpointer = &y->l_vec[i].l_p;
x_list.c:/* ------------- list append --------------------- */
x_list.c:    alist_init(&x->x_alist);
x_list.c:    alist_list(&x->x_alist, 0, argc, argv);
x_list.c:    outlet_new(&x->x_obj, &s_list);
x_list.c:    inlet_new(&x->x_obj, &x->x_alist.l_pd, 0, 0);
x_list.c:    int n, outc = x->x_alist.l_n + argc;
x_list.c:    if (x->x_alist.l_npointer)
x_list.c:        alist_clone(&x->x_alist, &y);
x_list.c:        outlet_list(x->x_obj.ob_outlet, &s_list, outc, outv);
x_list.c:        alist_toatoms(&x->x_alist, outv+argc);
x_list.c:        outlet_list(x->x_obj.ob_outlet, &s_list, outc, outv);
x_list.c:    int n, outc = x->x_alist.l_n + argc + 1;
x_list.c:    if (x->x_alist.l_npointer)
x_list.c:        alist_clone(&x->x_alist, &y);
x_list.c:        outlet_list(x->x_obj.ob_outlet, &s_list, outc, outv);
x_list.c:        alist_toatoms(&x->x_alist, outv + 1 + argc);
x_list.c:        outlet_list(x->x_obj.ob_outlet, &s_list, outc, outv);
x_list.c:    alist_clear(&x->x_alist);
x_list.c:/* ------------- list prepend --------------------- */
x_list.c:    alist_init(&x->x_alist);
x_list.c:    alist_list(&x->x_alist, 0, argc, argv);
x_list.c:    outlet_new(&x->x_obj, &s_list);
x_list.c:    inlet_new(&x->x_obj, &x->x_alist.l_pd, 0, 0);
x_list.c:    int n, outc = x->x_alist.l_n + argc;
x_list.c:    atoms_copy(argc, argv, outv + x->x_alist.l_n);
x_list.c:    if (x->x_alist.l_npointer)
x_list.c:        alist_clone(&x->x_alist, &y);
x_list.c:        outlet_list(x->x_obj.ob_outlet, &s_list, outc, outv);
x_list.c:        alist_toatoms(&x->x_alist, outv);
x_list.c:        outlet_list(x->x_obj.ob_outlet, &s_list, outc, outv);
x_list.c:    int n, outc = x->x_alist.l_n + argc + 1;
x_list.c:    SETSYMBOL(outv + x->x_alist.l_n, s);
x_list.c:    atoms_copy(argc, argv, outv + x->x_alist.l_n + 1);
x_list.c:    if (x->x_alist.l_npointer)
x_list.c:        alist_clone(&x->x_alist, &y);
x_list.c:        outlet_list(x->x_obj.ob_outlet, &s_list, outc, outv);
x_list.c:        alist_toatoms(&x->x_alist, outv);
x_list.c:        outlet_list(x->x_obj.ob_outlet, &s_list, outc, outv);
x_list.c:    alist_clear(&x->x_alist);
x_list.c:/* ------------- list split --------------------- */
x_list.c:    x->x_out1 = outlet_new(&x->x_obj, &s_list);
x_list.c:    x->x_out2 = outlet_new(&x->x_obj, &s_list);
x_list.c:    x->x_out3 = outlet_new(&x->x_obj, &s_list);
x_list.c:    floatinlet_new(&x->x_obj, &x->x_f);
x_list.c:    x->x_f = f;
x_list.c:    int n = x->x_f;
x_list.c:        outlet_list(x->x_out2, &s_list, argc-n, argv+n);
x_list.c:        outlet_list(x->x_out1, &s_list, n, argv);
x_list.c:    else outlet_list(x->x_out3, &s_list, argc, argv);
x_list.c:/* ------------- list trim --------------------- */
x_list.c:    outlet_new(&x->x_obj, &s_list);
x_list.c:        outlet_list(x->x_obj.ob_outlet, &s_list, argc, argv);
x_list.c:    else outlet_anything(x->x_obj.ob_outlet, argv[0].a_w.w_symbol,
x_list.c:        argc-1, argv+1);
x_list.c:    outlet_anything(x->x_obj.ob_outlet, s, argc, argv);
x_list.c:/* ------------- list length --------------------- */
x_list.c:    outlet_new(&x->x_obj, &s_float);
x_list.c:    outlet_float(x->x_obj.ob_outlet, (t_float)argc);
x_list.c:    outlet_float(x->x_obj.ob_outlet, (t_float)argc+1);
x_list.c:/* ------------- list ------------------- */
x_list.c:            newest = list_append_new(s, argc-1, argv+1);
x_list.c:            newest = list_prepend_new(s, argc-1, argv+1);
x_list.c:            error("list %s: unknown function", s2->s_name);
x_midi.c:/* Copyright (c) 1997-2001 Miller Puckette and others.
x_midi.c:/* ----------------------- midiin and sysexin ------------------------- */
x_midi.c:    x->x_outlet1 = outlet_new(&x->x_obj, &s_float);
x_midi.c:    x->x_outlet2 = outlet_new(&x->x_obj, &s_float);
x_midi.c:    pd_bind(&x->x_obj.ob_pd, midiin_sym);
x_midi.c:    outlet_float(x->x_outlet2, atom_getfloatarg(1, ac, av) + 1);
x_midi.c:    outlet_float(x->x_outlet1, atom_getfloatarg(0, ac, av));
x_midi.c:    pd_unbind(&x->x_obj.ob_pd, midiin_sym);
x_midi.c:    x->x_outlet1 = outlet_new(&x->x_obj, &s_float);
x_midi.c:    x->x_outlet2 = outlet_new(&x->x_obj, &s_float);
x_midi.c:    pd_bind(&x->x_obj.ob_pd, sysexin_sym);
x_midi.c:    pd_unbind(&x->x_obj.ob_pd, sysexin_sym);
x_midi.c:    if (midiin_sym->s_thing)
x_midi.c:        pd_list(midiin_sym->s_thing, 0, 2, at);
x_midi.c:    if (sysexin_sym->s_thing)
x_midi.c:        pd_list(sysexin_sym->s_thing, 0, 2, at);
x_midi.c:/* ----------------------- notein ------------------------- */
x_midi.c:    x->x_channel = f;
x_midi.c:    x->x_outlet1 = outlet_new(&x->x_obj, &s_float);
x_midi.c:    x->x_outlet2 = outlet_new(&x->x_obj, &s_float);
x_midi.c:    if (f == 0) x->x_outlet3 = outlet_new(&x->x_obj, &s_float);
x_midi.c:    pd_bind(&x->x_obj.ob_pd, notein_sym);
x_midi.c:    if (x->x_channel != 0)
x_midi.c:        if (channel != x->x_channel) return;
x_midi.c:        outlet_float(x->x_outlet2, velo);
x_midi.c:        outlet_float(x->x_outlet1, pitch);
x_midi.c:        outlet_float(x->x_outlet3, channel);
x_midi.c:        outlet_float(x->x_outlet2, velo);
x_midi.c:        outlet_float(x->x_outlet1, pitch);
x_midi.c:    pd_unbind(&x->x_obj.ob_pd, notein_sym);
x_midi.c:    if (notein_sym->s_thing)
x_midi.c:        pd_list(notein_sym->s_thing, &s_list, 3, at);
x_midi.c:/* ----------------------- ctlin ------------------------- */
x_midi.c:    if (!argc) ctlno = -1;
x_midi.c:    x->x_channel = channel;
x_midi.c:    x->x_ctlno = ctlno;
x_midi.c:    x->x_outlet1 = outlet_new(&x->x_obj, &s_float);
x_midi.c:        if (x->x_ctlno < 0) x->x_outlet2 = outlet_new(&x->x_obj, &s_float);
x_midi.c:        x->x_outlet3 = outlet_new(&x->x_obj, &s_float);
x_midi.c:    pd_bind(&x->x_obj.ob_pd, ctlin_sym);
x_midi.c:    if (x->x_ctlno >= 0 && x->x_ctlno != ctlnumber) return;
x_midi.c:    if (x->x_channel > 0  && x->x_channel != channel) return;
x_midi.c:    if (x->x_channel == 0) outlet_float(x->x_outlet3, channel);
x_midi.c:    if (x->x_ctlno < 0) outlet_float(x->x_outlet2, ctlnumber);
x_midi.c:    outlet_float(x->x_outlet1, value);
x_midi.c:    pd_unbind(&x->x_obj.ob_pd, ctlin_sym);
x_midi.c:    if (ctlin_sym->s_thing)
x_midi.c:        pd_list(ctlin_sym->s_thing, &s_list, 3, at);
x_midi.c:/* ----------------------- pgmin ------------------------- */
x_midi.c:    x->x_channel = f;
x_midi.c:    x->x_outlet1 = outlet_new(&x->x_obj, &s_float);
x_midi.c:    if (f == 0) x->x_outlet2 = outlet_new(&x->x_obj, &s_float);
x_midi.c:    pd_bind(&x->x_obj.ob_pd, pgmin_sym);
x_midi.c:    if (x->x_channel != 0)
x_midi.c:        if (channel != x->x_channel) return;
x_midi.c:        outlet_float(x->x_outlet1, value);
x_midi.c:        outlet_float(x->x_outlet2, channel);
x_midi.c:        outlet_float(x->x_outlet1, value);
x_midi.c:    pd_unbind(&x->x_obj.ob_pd, pgmin_sym);
x_midi.c:    if (pgmin_sym->s_thing)
x_midi.c:        pd_list(pgmin_sym->s_thing, &s_list, 2, at);
x_midi.c:/* ----------------------- bendin ------------------------- */
x_midi.c:    x->x_channel = f;
x_midi.c:    x->x_outlet1 = outlet_new(&x->x_obj, &s_float);
x_midi.c:    if (f == 0) x->x_outlet2 = outlet_new(&x->x_obj, &s_float);
x_midi.c:    pd_bind(&x->x_obj.ob_pd, bendin_sym);
x_midi.c:    if (x->x_channel != 0)
x_midi.c:        if (channel != x->x_channel) return;
x_midi.c:        outlet_float(x->x_outlet1, value);
x_midi.c:        outlet_float(x->x_outlet2, channel);
x_midi.c:        outlet_float(x->x_outlet1, value);
x_midi.c:    pd_unbind(&x->x_obj.ob_pd, bendin_sym);
x_midi.c:    if (bendin_sym->s_thing)
x_midi.c:        pd_list(bendin_sym->s_thing, &s_list, 2, at);
x_midi.c:/* ----------------------- touchin ------------------------- */
x_midi.c:    x->x_channel = f;
x_midi.c:    x->x_outlet1 = outlet_new(&x->x_obj, &s_float);
x_midi.c:    if (f == 0) x->x_outlet2 = outlet_new(&x->x_obj, &s_float);
x_midi.c:    pd_bind(&x->x_obj.ob_pd, touchin_sym);
x_midi.c:    if (x->x_channel)
x_midi.c:        if (channel != x->x_channel) return;
x_midi.c:        outlet_float(x->x_outlet1, value);
x_midi.c:        outlet_float(x->x_outlet2, channel);
x_midi.c:        outlet_float(x->x_outlet1, value);
x_midi.c:    pd_unbind(&x->x_obj.ob_pd, touchin_sym);
x_midi.c:    if (touchin_sym->s_thing)
x_midi.c:        pd_list(touchin_sym->s_thing, &s_list, 2, at);
x_midi.c:/* ----------------------- polytouchin ------------------------- */
x_midi.c:    x->x_channel = f;
x_midi.c:    x->x_outlet1 = outlet_new(&x->x_obj, &s_float);
x_midi.c:    x->x_outlet2 = outlet_new(&x->x_obj, &s_float);
x_midi.c:    if (f == 0) x->x_outlet3 = outlet_new(&x->x_obj, &s_float);
x_midi.c:    pd_bind(&x->x_obj.ob_pd, polytouchin_sym);
x_midi.c:    if (x->x_channel != 0)
x_midi.c:        if (channel != x->x_channel) return;
x_midi.c:        outlet_float(x->x_outlet2, pitch);
x_midi.c:        outlet_float(x->x_outlet1, value);
x_midi.c:        outlet_float(x->x_outlet3, channel);
x_midi.c:        outlet_float(x->x_outlet2, pitch);
x_midi.c:        outlet_float(x->x_outlet1, value);
x_midi.c:    pd_unbind(&x->x_obj.ob_pd, polytouchin_sym);
x_midi.c:    if (polytouchin_sym->s_thing)
x_midi.c:        pd_list(polytouchin_sym->s_thing, &s_list, 3, at);
x_midi.c:/*----------------------- midiclkin--(midi F8 message )---------------------*/
x_midi.c:    x->x_outlet1 = outlet_new(&x->x_obj, &s_float);
x_midi.c:    x->x_outlet2 = outlet_new(&x->x_obj, &s_float);
x_midi.c:    pd_bind(&x->x_obj.ob_pd, midiclkin_sym);
x_midi.c:    outlet_float(x->x_outlet2, count);
x_midi.c:    outlet_float(x->x_outlet1, value);
x_midi.c:    pd_unbind(&x->x_obj.ob_pd, midiclkin_sym);
x_midi.c:    if (midiclkin_sym->s_thing)
x_midi.c:        diff =timing - prev;
x_midi.c:        pd_list(midiclkin_sym->s_thing, &s_list, 2, at);
x_midi.c:/*----------midirealtimein (midi FA,FB,FC,FF message )-----------------*/
x_midi.c:    x->x_outlet1 = outlet_new(&x->x_obj, &s_float);
x_midi.c:    x->x_outlet2 = outlet_new(&x->x_obj, &s_float);
x_midi.c:    pd_bind(&x->x_obj.ob_pd, midirealtimein_sym);
x_midi.c:    outlet_float(x->x_outlet2, portno);
x_midi.c:    outlet_float(x->x_outlet1, byte);
x_midi.c:    pd_unbind(&x->x_obj.ob_pd, midirealtimein_sym);
x_midi.c:    if (midirealtimein_sym->s_thing)
x_midi.c:        pd_list(midirealtimein_sym->s_thing, &s_list, 2, at);
x_midi.c:/* -------------------------- midiout -------------------------- */
x_midi.c:    x->x_portno = portno;
x_midi.c:    floatinlet_new(&x->x_obj, &x->x_portno);
x_midi.c:    outmidi_byte(x->x_portno - 1, f);
x_midi.c:/* -------------------------- noteout -------------------------- */
x_midi.c:    x->x_velo = 0;
x_midi.c:    x->x_channel = channel;
x_midi.c:    floatinlet_new(&x->x_obj, &x->x_velo);
x_midi.c:    floatinlet_new(&x->x_obj, &x->x_channel);
x_midi.c:    int binchan = x->x_channel - 1;
x_midi.c:        (binchan & 15), (int)f, (int)x->x_velo);
x_midi.c:/* -------------------------- ctlout -------------------------- */
x_midi.c:    x->x_ctl = ctl;
x_midi.c:    x->x_channel = channel;
x_midi.c:    floatinlet_new(&x->x_obj, &x->x_ctl);
x_midi.c:    floatinlet_new(&x->x_obj, &x->x_channel);
x_midi.c:    int binchan = x->x_channel - 1;
x_midi.c:        (binchan & 15), (int)(x->x_ctl), (int)f);
x_midi.c:/* -------------------------- pgmout -------------------------- */
x_midi.c:    x->x_channel = channel;
x_midi.c:    floatinlet_new(&x->x_obj, &x->x_channel);
x_midi.c:    int binchan = x->x_channel - 1;
x_midi.c:    int n = f - 1;
x_midi.c:/* -------------------------- bendout -------------------------- */
x_midi.c:    x->x_channel = channel;
x_midi.c:    floatinlet_new(&x->x_obj, &x->x_channel);
x_midi.c:    int binchan = x->x_channel - 1;
x_midi.c:/* -------------------------- touch -------------------------- */
x_midi.c:    x->x_channel = channel;
x_midi.c:    floatinlet_new(&x->x_obj, &x->x_channel);
x_midi.c:    int binchan = x->x_channel - 1;
x_midi.c:/* -------------------------- polytouch -------------------------- */
x_midi.c:    x->x_channel = channel;
x_midi.c:    x->x_pitch = 0;
x_midi.c:    floatinlet_new(&x->x_obj, &x->x_pitch);
x_midi.c:    floatinlet_new(&x->x_obj, &x->x_channel);
x_midi.c:    int binchan = x->x_channel - 1;
x_midi.c:    outmidi_polyaftertouch((binchan >> 4), (binchan & 15), x->x_pitch, n);
x_midi.c:/* -------------------------- makenote -------------------------- */
x_midi.c:    x->x_velo = velo;
x_midi.c:    x->x_dur = dur;
x_midi.c:    floatinlet_new(&x->x_obj, &x->x_velo);
x_midi.c:    floatinlet_new(&x->x_obj, &x->x_dur);
x_midi.c:    x->x_pitchout = outlet_new(&x->x_obj, &s_float);
x_midi.c:    x->x_velout = outlet_new(&x->x_obj, &s_float);
x_midi.c:    x->x_hang = 0;
x_midi.c:    t_makenote *x = hang->h_owner;
x_midi.c:    outlet_float(x->x_velout, 0);
x_midi.c:    outlet_float(x->x_pitchout, hang->h_pitch);
x_midi.c:    if (x->x_hang == hang) x->x_hang = hang->h_next;
x_midi.c:    else for (h2 = x->x_hang; h3 = h2->h_next; h2 = h3)
x_midi.c:            h2->h_next = h3->h_next;
x_midi.c:    clock_free(hang->h_clock);
x_midi.c:    if (!x->x_velo) return;
x_midi.c:    outlet_float(x->x_velout, x->x_velo);
x_midi.c:    outlet_float(x->x_pitchout, f);
x_midi.c:    hang->h_next = x->x_hang;
x_midi.c:    x->x_hang = hang;
x_midi.c:    hang->h_pitch = f;
x_midi.c:    hang->h_owner = x;
x_midi.c:    hang->h_clock = clock_new(hang, (t_method)makenote_tick);
x_midi.c:    clock_delay(hang->h_clock, (x->x_dur >= 0 ? x->x_dur : 0));
x_midi.c:    while (hang = x->x_hang)
x_midi.c:        outlet_float(x->x_velout, 0);
x_midi.c:        outlet_float(x->x_pitchout, hang->h_pitch);
x_midi.c:        x->x_hang = hang->h_next;
x_midi.c:        clock_free(hang->h_clock);
x_midi.c:    while (hang = x->x_hang)
x_midi.c:        x->x_hang = hang->h_next;
x_midi.c:        clock_free(hang->h_clock);
x_midi.c:/* -------------------------- stripnote -------------------------- */
x_midi.c:    floatinlet_new(&x->x_obj, &x->x_velo);
x_midi.c:    x->x_pitchout = outlet_new(&x->x_obj, &s_float);
x_midi.c:    x->x_velout = outlet_new(&x->x_obj, &s_float);
x_midi.c:    if (!x->x_velo) return;
x_midi.c:    outlet_float(x->x_velout, x->x_velo);
x_midi.c:    outlet_float(x->x_pitchout, f);
x_midi.c:/* -------------------------- poly -------------------------- */
x_midi.c:    x->x_n = n;
x_midi.c:    x->x_vec = (t_voice *)getbytes(n * sizeof(*x->x_vec));
x_midi.c:    for (v = x->x_vec, i = n; i--; v++)
x_midi.c:        v->v_pitch = v->v_used = v->v_serial = 0;
x_midi.c:    x->x_vel = 0;
x_midi.c:    x->x_steal = (fsteal != 0);
x_midi.c:    floatinlet_new(&x->x_obj, &x->x_vel);
x_midi.c:    outlet_new(&x->x_obj, &s_float);
x_midi.c:    x->x_pitchout = outlet_new(&x->x_obj, &s_float);
x_midi.c:    x->x_velout = outlet_new(&x->x_obj, &s_float);
x_midi.c:    x->x_serial = 0;
x_midi.c:    if (x->x_vel > 0)
x_midi.c:        for (v = x->x_vec, i = 0, firston = firstoff = 0,
x_midi.c:            serialon = serialoff = 0xffffffff; i < x->x_n; v++, i++)
x_midi.c:            if (v->v_used && v->v_serial < serialon)
x_midi.c:                    firston = v, serialon = v->v_serial, onindex = i;
x_midi.c:            else if (!v->v_used && v->v_serial < serialoff)
x_midi.c:                    firstoff = v, serialoff = v->v_serial, offindex = i;
x_midi.c:            outlet_float(x->x_velout, x->x_vel);
x_midi.c:            outlet_float(x->x_pitchout, firstoff->v_pitch = f);
x_midi.c:            outlet_float(x->x_obj.ob_outlet, offindex+1);
x_midi.c:            firstoff->v_used = 1;
x_midi.c:            firstoff->v_serial = x->x_serial++;
x_midi.c:        else if (firston && x->x_steal)
x_midi.c:            outlet_float(x->x_velout, 0);
x_midi.c:            outlet_float(x->x_pitchout, firston->v_pitch);
x_midi.c:            outlet_float(x->x_obj.ob_outlet, onindex+1);
x_midi.c:            outlet_float(x->x_velout, x->x_vel);
x_midi.c:            outlet_float(x->x_pitchout, firston->v_pitch = f);
x_midi.c:            outlet_float(x->x_obj.ob_outlet, onindex+1);
x_midi.c:            firston->v_serial = x->x_serial++;
x_midi.c:        for (v = x->x_vec, i = 0, firston = 0, serialon = 0xffffffff;
x_midi.c:            i < x->x_n; v++, i++)
x_midi.c:                if (v->v_used && v->v_pitch == f && v->v_serial < serialon)
x_midi.c:                    firston = v, serialon = v->v_serial, onindex = i;
x_midi.c:            firston->v_used = 0;
x_midi.c:            firston->v_serial = x->x_serial++;
x_midi.c:            outlet_float(x->x_velout, 0);
x_midi.c:            outlet_float(x->x_pitchout, firston->v_pitch);
x_midi.c:            outlet_float(x->x_obj.ob_outlet, onindex+1);
x_midi.c:    for (i = 0, v = x->x_vec; i < x->x_n; i++, v++)
x_midi.c:        if (v->v_used)
x_midi.c:        outlet_float(x->x_velout, 0L);
x_midi.c:        outlet_float(x->x_pitchout, v->v_pitch);
x_midi.c:        outlet_float(x->x_obj.ob_outlet, i+1);
x_midi.c:        v->v_used = 0;
x_midi.c:        v->v_serial = x->x_serial++;
x_midi.c:    for (v = x->x_vec, i = x->x_n; i--; v++) v->v_used = v->v_serial = 0;
x_midi.c:    freebytes(x->x_vec, x->x_n * sizeof (*x->x_vec));
x_midi.c:/* -------------------------- bag -------------------------- */
x_midi.c:    x->x_velo = 0;
x_midi.c:    floatinlet_new(&x->x_obj, &x->x_velo);
x_midi.c:    outlet_new(&x->x_obj, &s_float);
x_midi.c:    x->x_first = 0;
x_midi.c:    if (x->x_velo != 0)
x_midi.c:        bagelem->e_next = 0;
x_midi.c:        bagelem->e_value = f;
x_midi.c:        if (!x->x_first) x->x_first = bagelem;
x_midi.c:            for (e2 = x->x_first; e3 = e2->e_next; e2 = e3)
x_midi.c:            e2->e_next = bagelem;
x_midi.c:        if (!x->x_first) return;
x_midi.c:        if (x->x_first->e_value == f)
x_midi.c:            bagelem = x->x_first;
x_midi.c:            x->x_first = x->x_first->e_next;
x_midi.c:        for (e2 = x->x_first; e3 = e2->e_next; e2 = e3)
x_midi.c:            if (e3->e_value == f)
x_midi.c:            e2->e_next = e3->e_next;
x_midi.c:    while (bagelem = x->x_first)
x_midi.c:        outlet_float(x->x_obj.ob_outlet, bagelem->e_value);
x_midi.c:        x->x_first = bagelem->e_next;
x_midi.c:    while (bagelem = x->x_first)
x_midi.c:        x->x_first = bagelem->e_next;
x_misc.c:/* Copyright (c) 1997-1999 Miller Puckette.
x_misc.c:/* -------------------------- random ------------------------------ */
x_misc.c:    x->x_f = f;
x_misc.c:    x->x_state = makeseed();
x_misc.c:    floatinlet_new(&x->x_obj, &x->x_f);
x_misc.c:    outlet_new(&x->x_obj, &s_float);
x_misc.c:    int n = x->x_f, nval;
x_misc.c:    unsigned int randval = x->x_state;
x_misc.c:    x->x_state = randval = randval * 472940017 + 832416023;
x_misc.c:    if (nval >= range) nval = range-1;
x_misc.c:    outlet_float(x->x_obj.ob_outlet, nval);
x_misc.c:    x->x_state = f;
x_misc.c:/* -------------------------- loadbang ------------------------------ */
x_misc.c:    outlet_new(&x->x_obj, &s_bang);
x_misc.c:        outlet_bang(x->x_obj.ob_outlet);
x_misc.c:/* ------------- namecanvas (delete this later) --------------------- */
x_misc.c:    x->x_owner = (t_pd *)canvas_getcurrent();
x_misc.c:    x->x_sym = s;
x_misc.c:    if (*s->s_name) pd_bind(x->x_owner, s);
x_misc.c:    if (*x->x_sym->s_name) pd_unbind(x->x_owner, x->x_sym);
x_misc.c:/* ---------------serial ports (_WIN32 only -- hack) ------------------------- */
x_misc.c:    if (!x->x_open)
x_misc.c:        sys_vgui("com%d_open\n", x->x_portno);
x_misc.c:        x->x_open = 1;
x_misc.c:    sprintf(message, "com%d_send \"\\%3.3o\"\n", x->x_portno, n);
x_misc.c:    x->x_portno = portno;
x_misc.c:    x->x_open = 0;
x_misc.c:/* -------------------------- cputime ------------------------------ */
x_misc.c:        (FILETIME *)&x->x_kerneltime, (FILETIME *)&x->x_usertime);
x_misc.c:        if (!x->x_warned)
x_misc.c:        x->x_warned = 1;
x_misc.c:        x->x_kerneltime.QuadPart = 0;
x_misc.c:        x->x_usertime.QuadPart = 0;
x_misc.c:    times(&x->x_setcputime);
x_misc.c:        newcputime.tms_utime + newcputime.tms_stime -
x_misc.c:            x->x_setcputime.tms_utime - x->x_setcputime.tms_stime) / CLOCKHZ;
x_misc.c:    outlet_float(x->x_obj.ob_outlet, elapsedcpu);
x_misc.c:            ((kerneltime.QuadPart - x->x_kerneltime.QuadPart) +
x_misc.c:                (usertime.QuadPart - x->x_usertime.QuadPart));
x_misc.c:    outlet_float(x->x_obj.ob_outlet, elapsedcpu);
x_misc.c:    outlet_new(&x->x_obj, gensym("float"));
x_misc.c:    inlet_new(&x->x_obj, &x->x_obj.ob_pd, gensym("bang"), gensym("bang2"));
x_misc.c:    x->x_warned = 0;
x_misc.c:/* -------------------------- realtime ------------------------------ */
x_misc.c:    x->x_setrealtime = sys_getrealtime();
x_misc.c:    outlet_float(x->x_obj.ob_outlet,
x_misc.c:        (sys_getrealtime() - x->x_setrealtime) * 1000.);
x_misc.c:    outlet_new(&x->x_obj, gensym("float"));
x_misc.c:    inlet_new(&x->x_obj, &x->x_obj.ob_pd, gensym("bang"), gensym("bang2"));
x_net.c:/* Copyright (c) 1997-1999 Miller Puckette.
x_net.c:#define SOCKET_ERROR -1
x_net.c:    outlet_new(&x->x_obj, &s_float);
x_net.c:    x->x_fd = -1;
x_net.c:    x->x_protocol = (udpflag != 0 ? SOCK_DGRAM : SOCK_STREAM);
x_net.c:    if (x->x_fd >= 0)
x_net.c:    sockfd = socket(AF_INET, x->x_protocol, 0);
x_net.c:    hp = gethostbyname(hostname->s_name);
x_net.c:    if (x->x_protocol == SOCK_STREAM)
x_net.c:    memcpy((char *)&server.sin_addr, (char *)hp->h_addr, hp->h_length);
x_net.c:    x->x_fd = sockfd;
x_net.c:    outlet_float(x->x_obj.ob_outlet, 1);
x_net.c:    if (x->x_fd >= 0)
x_net.c:        sys_closesocket(x->x_fd);
x_net.c:        x->x_fd = -1;
x_net.c:        outlet_float(x->x_obj.ob_outlet, 0);
x_net.c:    if (x->x_fd >= 0)
x_net.c:            int res = send(x->x_fd, bp, length-sent, 0);
x_net.c:            int late = (timeafter - timebefore > 0.005);
x_net.c:                        (int)(1000 * ((timeafter - timebefore) + pleasewarn)));
x_net.c:                else if (late) pleasewarn += timeafter - timebefore;
x_net.c:/* ----------------------------- netreceive ------------------------- */
x_net.c:    outlet_float(x->x_connectout, --x->x_nconnections);
x_net.c:                    outlet_list(x->x_msgout, 0, emsg-msg, at + msg);
x_net.c:                else outlet_float(x->x_msgout, at[msg].a_w.w_float);
x_net.c:                outlet_anything(x->x_msgout, at[msg].a_w.w_symbol,
x_net.c:                    emsg-msg-1, at + msg + 1);
x_net.c:    int fd = accept(x->x_connectsocket, 0, 0);
x_net.c:                (x->x_msgout ? netreceive_doit : 0), 0);
x_net.c:        outlet_float(x->x_connectout, ++x->x_nconnections);
x_net.c:    int old = !strcmp(compatflag->s_name , "old");
x_net.c:        x->x_msgout = 0;
x_net.c:    else x->x_msgout = outlet_new(&x->x_obj, &s_anything);
x_net.c:                (x->x_msgout ? netreceive_doit : 0), 1);
x_net.c:        x->x_connectout = 0;
x_net.c:            sockfd = -1;
x_net.c:            x->x_connectout = outlet_new(&x->x_obj, &s_float);
x_net.c:    x->x_connectsocket = sockfd;
x_net.c:    x->x_nconnections = 0;
x_net.c:    x->x_udp = udp;
x_net.c:    if (x->x_connectsocket >= 0)
x_net.c:        sys_rmpollfn(x->x_connectsocket);
x_net.c:        sys_closesocket(x->x_connectsocket);
x_qlist.c:/* Copyright (c) 1997-1999 Miller Puckette and others.
x_qlist.c:    x->b_binbuf = binbuf_new();
x_qlist.c:    x->b_canvas = canvas_getcurrent();
x_qlist.c:    if (x->b_guiconnect)
x_qlist.c:                 sys_hostfontsize(glist_getfont(x->b_canvas)));
x_qlist.c:        binbuf_gettext(x->b_binbuf, &txt, &ntxt);
x_qlist.c:            sys_vgui("pdtk_textwindow_append .x%lx {%.*s\n}\n", x, j-txt-i, txt+i);
x_qlist.c:            i = (j-txt)+1;
x_qlist.c:        x->b_guiconnect = guiconnect_new(&x->b_ob.ob_pd, gensym(buf));
x_qlist.c:    if (x->b_guiconnect)
x_qlist.c:        guiconnect_notarget(x->b_guiconnect, 1000);
x_qlist.c:        x->b_guiconnect = 0;
x_qlist.c:    binbuf_add(b->b_binbuf, binbuf_getnatom(z), binbuf_getvec(z));
x_qlist.c:/* textobj object - buffer for text, accessible by other accessor objects */
x_qlist.c:    textbuf_init(&x->x_textbuf);
x_qlist.c:           /* bashily unbind #A -- this would create garbage if #A were
x_qlist.c:    asym->s_thing = 0;
x_qlist.c:    pd_bind(&x->x_ob.ob_pd, asym); 
x_qlist.c:    binbuf_clear(x->x_binbuf);
x_qlist.c:        (float)b->x_ob.te_xpix, (float)b->x_ob.te_ypix);
x_qlist.c:    binbuf_addbinbuf(bb, b->x_ob.ob_binbuf);
x_qlist.c:    binbuf_addbinbuf(bb, b->x_binbuf);
x_qlist.c:    binbuf_free(x->b_binbuf);
x_qlist.c:    if (x->b_guiconnect)
x_qlist.c:        guiconnect_notarget(x->b_guiconnect, 1000);
x_qlist.c:    textbuf_init(&x->x_textbuf);
x_qlist.c:    x->x_clock = clock_new(x, (t_method)qlist_tick);
x_qlist.c:    outlet_new(&x->x_ob, &s_list);
x_qlist.c:    x->x_bangout = outlet_new(&x->x_ob, &s_bang);
x_qlist.c:    x->x_onset = 0x7fffffff;
x_qlist.c:    x->x_tempo = 1;
x_qlist.c:    x->x_whenclockset = 0;
x_qlist.c:    x->x_clockdelay = 0;
x_qlist.c:    x->x_rewound = x->x_innext = 0;
x_qlist.c:    x->x_onset = 0;
x_qlist.c:    if (x->x_clock) clock_unset(x->x_clock);
x_qlist.c:    x->x_whenclockset = 0;
x_qlist.c:    x->x_rewound = 1;
x_qlist.c:    if (x->x_innext)
x_qlist.c:    x->x_innext = 1;
x_qlist.c:        int argc = binbuf_getnatom(x->x_binbuf),
x_qlist.c:            count, onset = x->x_onset, onset2, wasrewound;
x_qlist.c:        t_atom *argv = binbuf_getvec(x->x_binbuf);
x_qlist.c:        while (ap->a_type == A_SEMI || ap->a_type == A_COMMA)
x_qlist.c:            if (ap->a_type == A_SEMI) target = 0;
x_qlist.c:        if (!target && ap->a_type == A_FLOAT)
x_qlist.c:            while (onset2 < argc && ap2->a_type == A_FLOAT)
x_qlist.c:            x->x_onset = onset2;
x_qlist.c:                clock_delay(x->x_clock,
x_qlist.c:                    x->x_clockdelay = ap->a_w.w_float * x->x_tempo);
x_qlist.c:                x->x_whenclockset = clock_getsystime();
x_qlist.c:            else outlet_list(x->x_ob.ob_outlet, 0, onset2-onset, ap);
x_qlist.c:            x->x_innext = 0;
x_qlist.c:            (ap2->a_type == A_FLOAT || ap2->a_type == A_SYMBOL))
x_qlist.c:        x->x_onset = onset2;
x_qlist.c:        count = onset2 - onset;
x_qlist.c:            if (ap->a_type != A_SYMBOL) continue;
x_qlist.c:            else if (!(target = ap->a_w.w_symbol->s_thing))
x_qlist.c:                    ap->a_w.w_symbol->s_name);
x_qlist.c:            count--;
x_qlist.c:                x->x_onset = onset2;
x_qlist.c:        wasrewound = x->x_rewound;
x_qlist.c:        x->x_rewound = 0;
x_qlist.c:            if (ap->a_type == A_FLOAT)
x_qlist.c:            else if (ap->a_type == A_SYMBOL)
x_qlist.c:                typedmess(target, ap->a_w.w_symbol, count-1, ap+1);
x_qlist.c:        if (x->x_rewound)
x_qlist.c:            x->x_innext = 0;
x_qlist.c:        x->x_rewound = wasrewound;
x_qlist.c:    x->x_onset = 0x7fffffff;
x_qlist.c:    x->x_whenclockset = 0;
x_qlist.c:    x->x_innext = 0;
x_qlist.c:    outlet_bang(x->x_bangout);
x_qlist.c:        up to do this non-reentrantly after a delay of 0 */
x_qlist.c:    if (x->x_innext)
x_qlist.c:        x->x_whenclockset = clock_getsystime();
x_qlist.c:        x->x_clockdelay = 0;
x_qlist.c:        clock_delay(x->x_clock, 0);
x_qlist.c:    x->x_whenclockset = 0;
x_qlist.c:    binbuf_add(x->x_binbuf, ac, av);
x_qlist.c:    binbuf_add(x->x_binbuf, 1, &a);
x_qlist.c:    binbuf_add(x->x_binbuf, ac, av);
x_qlist.c:    binbuf_clear(x->x_binbuf);
x_qlist.c:    if (!strcmp(format->s_name, "cr"))
x_qlist.c:    else if (*format->s_name)
x_qlist.c:        pd_error(x, "qlist_read: unknown flag: %s", format->s_name);
x_qlist.c:    if (binbuf_read_via_canvas(x->x_binbuf, filename->s_name, x->x_canvas, cr))
x_qlist.c:            pd_error(x, "%s: read failed", filename->s_name);
x_qlist.c:    x->x_onset = 0x7fffffff;
x_qlist.c:    x->x_rewound = 1;
x_qlist.c:    canvas_makefilename(x->x_canvas, filename->s_name,
x_qlist.c:    if (!strcmp(format->s_name, "cr"))
x_qlist.c:    else if (*format->s_name)
x_qlist.c:        pd_error(x, "qlist_read: unknown flag: %s", format->s_name);
x_qlist.c:    if (binbuf_write(x->x_binbuf, buf, "", cr))
x_qlist.c:            pd_error(x, "%s: write failed", filename->s_name);
x_qlist.c:    post("--------- textfile or qlist contents: -----------");
x_qlist.c:    binbuf_print(x->x_binbuf);
x_qlist.c:    if (f < 1e-20) f = 1e-20;
x_qlist.c:    if (x->x_whenclockset != 0)
x_qlist.c:        t_float elapsed = clock_gettimesince(x->x_whenclockset);
x_qlist.c:        t_float left = x->x_clockdelay - elapsed;
x_qlist.c:        left *= newtempo / x->x_tempo;
x_qlist.c:        clock_delay(x->x_clock, left);
x_qlist.c:    x->x_tempo = newtempo;
x_qlist.c:    textbuf_free(&x->x_textbuf);
x_qlist.c:    clock_free(x->x_clock);
x_qlist.c:/* -------------------- textfile ------------------------------- */
x_qlist.c:    textbuf_init(&x->x_textbuf);
x_qlist.c:    outlet_new(&x->x_ob, &s_list);
x_qlist.c:    x->x_bangout = outlet_new(&x->x_ob, &s_bang);
x_qlist.c:    x->x_onset = 0x7fffffff;
x_qlist.c:    x->x_rewound = 0;
x_qlist.c:    x->x_tempo = 1;
x_qlist.c:    x->x_whenclockset = 0;
x_qlist.c:    x->x_clockdelay = 0;
x_qlist.c:    x->x_clock = NULL;
x_qlist.c:    int argc = binbuf_getnatom(x->x_binbuf),
x_qlist.c:        count, onset = x->x_onset, onset2;
x_qlist.c:    t_atom *argv = binbuf_getvec(x->x_binbuf);
x_qlist.c:        (ap->a_type == A_SEMI || ap->a_type == A_COMMA))
x_qlist.c:        (ap2->a_type != A_SEMI && ap2->a_type != A_COMMA))
x_qlist.c:        x->x_onset = onset2;
x_qlist.c:        if (ap->a_type == A_SYMBOL)
x_qlist.c:            outlet_anything(x->x_ob.ob_outlet, ap->a_w.w_symbol,
x_qlist.c:                onset2-onset-1, ap+1);
x_qlist.c:        else outlet_list(x->x_ob.ob_outlet, 0, onset2-onset, ap);
x_qlist.c:        x->x_onset = 0x7fffffff;
x_qlist.c:        outlet_bang(x->x_bangout);
x_qlist.c:    x->x_onset = 0;
x_qlist.c:/* ---------------- global setup function -------------------- */
x_qlist.c:    class_sethelpsymbol(textobj_class, gensym("text-object"));
x_time.c:/* Copyright (c) 1997-1999 Miller Puckette.
x_time.c:/* -------------------------- delay ------------------------------ */
x_time.c:    clock_delay(x->x_clock, x->x_deltime);
x_time.c:    clock_unset(x->x_clock);
x_time.c:    x->x_deltime = g;
x_time.c:    outlet_bang(x->x_obj.ob_outlet);
x_time.c:    clock_free(x->x_clock);
x_time.c:    x->x_clock = clock_new(x, (t_method)delay_tick);
x_time.c:    outlet_new(&x->x_obj, gensym("bang"));
x_time.c:    inlet_new(&x->x_obj, &x->x_obj.ob_pd, gensym("float"), gensym("ft1"));
x_time.c:/* -------------------------- metro ------------------------------ */
x_time.c:    x->x_hit = 0;
x_time.c:    outlet_bang(x->x_obj.ob_outlet);
x_time.c:    if (!x->x_hit) clock_delay(x->x_clock, x->x_deltime);
x_time.c:    else clock_unset(x->x_clock);
x_time.c:    x->x_hit = 1;
x_time.c:    x->x_deltime = g;
x_time.c:    clock_free(x->x_clock);
x_time.c:    x->x_hit = 0;
x_time.c:    x->x_clock = clock_new(x, (t_method)metro_tick);
x_time.c:    outlet_new(&x->x_obj, gensym("bang"));
x_time.c:    inlet_new(&x->x_obj, &x->x_obj.ob_pd, gensym("float"), gensym("ft1"));
x_time.c:/* -------------------------- line ------------------------------ */
x_time.c:    double msectogo = - clock_gettimesince(x->x_targettime);
x_time.c:    if (msectogo < 1E-9)
x_time.c:        outlet_float(x->x_obj.ob_outlet, x->x_targetval);
x_time.c:        outlet_float(x->x_obj.ob_outlet,
x_time.c:            x->x_setval + x->x_1overtimediff * (timenow - x->x_prevtime)
x_time.c:                * (x->x_targetval - x->x_setval));
x_time.c:        if (x->x_grain <= 0)
x_time.c:            x->x_grain = DEFAULTLINEGRAIN;
x_time.c:        clock_delay(x->x_clock,
x_time.c:            (x->x_grain > msectogo ? msectogo : x->x_grain));
x_time.c:    if (x->x_gotinlet && x->x_in1val > 0)
x_time.c:        if (timenow > x->x_targettime) x->x_setval = x->x_targetval;
x_time.c:        else x->x_setval = x->x_setval + x->x_1overtimediff *
x_time.c:            (timenow - x->x_prevtime)
x_time.c:            * (x->x_targetval - x->x_setval);
x_time.c:        x->x_prevtime = timenow;
x_time.c:        x->x_targettime = clock_getsystimeafter(x->x_in1val);
x_time.c:        x->x_targetval = f;
x_time.c:        x->x_gotinlet = 0;
x_time.c:        x->x_1overtimediff = 1./ (x->x_targettime - timenow);
x_time.c:        if (x->x_grain <= 0)
x_time.c:            x->x_grain = DEFAULTLINEGRAIN;
x_time.c:        clock_delay(x->x_clock,
x_time.c:            (x->x_grain > x->x_in1val ? x->x_in1val : x->x_grain));
x_time.c:        clock_unset(x->x_clock);
x_time.c:        x->x_targetval = x->x_setval = f;
x_time.c:        outlet_float(x->x_obj.ob_outlet, f);
x_time.c:    x->x_gotinlet = 0;
x_time.c:    x->x_in1val = g;
x_time.c:    x->x_gotinlet = 1;
x_time.c:    x->x_targetval = x->x_setval;
x_time.c:    clock_unset(x->x_clock);
x_time.c:    clock_unset(x->x_clock);
x_time.c:    x->x_targetval = x->x_setval = f;
x_time.c:    clock_free(x->x_clock);
x_time.c:    x->x_targetval = x->x_setval = f;
x_time.c:    x->x_gotinlet = 0;
x_time.c:    x->x_1overtimediff = 1;
x_time.c:    x->x_clock = clock_new(x, (t_method)line_tick);
x_time.c:    x->x_targettime = x->x_prevtime = clock_getsystime();
x_time.c:    x->x_grain = grain;
x_time.c:    outlet_new(&x->x_obj, gensym("float"));
x_time.c:    inlet_new(&x->x_obj, &x->x_obj.ob_pd, gensym("float"), gensym("ft1"));
x_time.c:    floatinlet_new(&x->x_obj, &x->x_grain);
x_time.c:/* -------------------------- timer ------------------------------ */
x_time.c:    x->x_settime = clock_getsystime();
x_time.c:    outlet_float(x->x_obj.ob_outlet, clock_gettimesince(x->x_settime));
x_time.c:    outlet_new(&x->x_obj, gensym("float"));
x_time.c:    inlet_new(&x->x_obj, &x->x_obj.ob_pd, gensym("bang"), gensym("bang2"));
x_time.c:/* -------------------------- pipe -------------------------- */
x_time.c:        if (argv[argc-1].a_type != A_FLOAT)
x_time.c:            atom_string(&argv[argc-1], stupid, 79);
x_time.c:        else deltime = argv[argc-1].a_w.w_float;
x_time.c:        argc--;
x_time.c:    x->x_n = argc;
x_time.c:    vec = x->x_vec = (t_pipeout *)getbytes(argc * sizeof(*x->x_vec));
x_time.c:    for (i = argc, ap = argv; i--; ap++)
x_time.c:        if (ap->a_type == A_SYMBOL && *ap->a_w.w_symbol->s_name == 'p')
x_time.c:    gp = x->x_gp = (t_gpointer *)t_getbytes(nptr * sizeof (*gp));
x_time.c:    x->x_nptr = nptr;
x_time.c:        if (ap->a_type == A_FLOAT)
x_time.c:            vp->p_atom = *ap;
x_time.c:            vp->p_outlet = outlet_new(&x->x_obj, &s_float);
x_time.c:            if (i) floatinlet_new(&x->x_obj, &vp->p_atom.a_w.w_float);
x_time.c:        else if (ap->a_type == A_SYMBOL)
x_time.c:            char c = *ap->a_w.w_symbol->s_name;
x_time.c:                SETSYMBOL(&vp->p_atom, &s_symbol);
x_time.c:                vp->p_outlet = outlet_new(&x->x_obj, &s_symbol);
x_time.c:                if (i) symbolinlet_new(&x->x_obj, &vp->p_atom.a_w.w_symbol);
x_time.c:                vp->p_atom.a_type = A_POINTER;
x_time.c:                vp->p_atom.a_w.w_gpointer = gp;
x_time.c:                vp->p_outlet = outlet_new(&x->x_obj, &s_pointer);
x_time.c:                if (i) pointerinlet_new(&x->x_obj, gp);
x_time.c:                    ap->a_w.w_symbol->s_name);
x_time.c:                SETFLOAT(&vp->p_atom, 0);
x_time.c:                vp->p_outlet = outlet_new(&x->x_obj, &s_float);
x_time.c:                if (i) floatinlet_new(&x->x_obj, &vp->p_atom.a_w.w_float);
x_time.c:    floatinlet_new(&x->x_obj, &x->x_deltime);
x_time.c:    x->x_hang = 0;
x_time.c:    x->x_deltime = deltime;
x_time.c:    t_pipe *x = h->h_owner;
x_time.c:    for (gp = h->h_gp, i = x->x_nptr; i--; gp++)
x_time.c:    freebytes(h->h_gp, x->x_nptr * sizeof(*h->h_gp));
x_time.c:    clock_free(h->h_clock);
x_time.c:    freebytes(h, sizeof(*h) + (x->x_n - 1) * sizeof(*h->h_vec));
x_time.c:    t_pipe *x = h->h_owner;
x_time.c:    if (x->x_hang == h) x->x_hang = h->h_next;
x_time.c:    else for (h2 = x->x_hang; h3 = h2->h_next; h2 = h3)
x_time.c:            h2->h_next = h3->h_next;
x_time.c:    for (i = x->x_n, p = x->x_vec + (x->x_n - 1), w = h->h_vec + (x->x_n - 1);
x_time.c:        i--; p--, w--)
x_time.c:        switch (p->p_atom.a_type)
x_time.c:        case A_FLOAT: outlet_float(p->p_outlet, w->w_float); break;
x_time.c:        case A_SYMBOL: outlet_symbol(p->p_outlet, w->w_symbol); break;
x_time.c:            if (gpointer_check(w->w_gpointer, 1))
x_time.c:                outlet_pointer(p->p_outlet, w->w_gpointer);
x_time.c:        getbytes(sizeof(*h) + (x->x_n - 1) * sizeof(*h->h_vec));
x_time.c:    int i, n = x->x_n;
x_time.c:    h->h_gp = (t_gpointer *)getbytes(x->x_nptr * sizeof(t_gpointer));
x_time.c:            x->x_deltime = av[n].a_w.w_float;
x_time.c:    for (i = 0, gp = x->x_gp, p = x->x_vec, ap = av; i < ac;
x_time.c:        switch (p->p_atom.a_type)
x_time.c:        case A_FLOAT: p->p_atom.a_w.w_float = atom_getfloat(ap); break;
x_time.c:        case A_SYMBOL: p->p_atom.a_w.w_symbol = atom_getsymbol(ap); break;
x_time.c:            if (ap->a_type != A_POINTER)
x_time.c:                *gp = *(ap->a_w.w_gpointer);
x_time.c:                if (gp->gp_stub) gp->gp_stub->gs_refcount++;
x_time.c:    for (i = 0, gp = x->x_gp, gp2 = h->h_gp, p = x->x_vec, w = h->h_vec;
x_time.c:        if (p->p_atom.a_type == A_POINTER)
x_time.c:            if (gp->gp_stub) gp->gp_stub->gs_refcount++;
x_time.c:            w->w_gpointer = gp2;
x_time.c:        else *w = p->p_atom.a_w;
x_time.c:    h->h_next = x->x_hang;
x_time.c:    x->x_hang = h;
x_time.c:    h->h_owner = x;
x_time.c:    h->h_clock = clock_new(h, (t_method)hang_tick);
x_time.c:    clock_delay(h->h_clock, (x->x_deltime >= 0 ? x->x_deltime : 0));
x_time.c:    while (x->x_hang) hang_tick(x->x_hang);
x_time.c:    while (hang = x->x_hang)
x_time.c:        x->x_hang = hang->h_next;
z.pd:#X obj 242 122 tgl 15 0 empty empty empty 17 7 0 10 -262144 -1 -1 0
z.pd:#X obj 315 101 vsl 15 128 0 127 0 0 empty empty empty 0 -9 0 10 -262144
z.pd:-1 -1 0 1;
z.pd:#X obj 356 103 vradio 15 1 0 8 empty empty empty 0 -8 0 10 -262144
z.pd:-1 -1 0;
z.pd:#X floatatom 43 102 5 0 0 0 - - -;
z.pd:#X coords 0 -1 1 1 107 73 1 100 100;
